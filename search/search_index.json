{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Szoftvertechnik\u00e1k \u00b6 Gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAB00 Szoftvertechnik\u00e1k c. t\u00e1rgyhoz. Jav\u00edt\u00e1s az anyagban A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request -et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod. Felhaszn\u00e1l\u00e1si felt\u00e9telek Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAB00 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) enged\u00e9ly\u00e9vel \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet. Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.","title":"Szoftvertechnik\u00e1k"},{"location":"#szoftvertechnikak","text":"Gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAB00 Szoftvertechnik\u00e1k c. t\u00e1rgyhoz. Jav\u00edt\u00e1s az anyagban A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request -et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod. Felhaszn\u00e1l\u00e1si felt\u00e9telek Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAB00 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) enged\u00e9ly\u00e9vel \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet. Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.","title":"Szoftvertechnik\u00e1k"},{"location":"egyeb/interfesz-es-absztrakt-os/","text":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet. Absztrakt oszt\u00e1ly \u00b6 A fogalmak kor\u00e1bbi t\u00e1rgyak keret\u00e9ben m\u00e1r ismertet\u00e9sre ker\u00fcltek, \u00edgy most csak a legfontosabbakat foglaljuk \u00f6ssze, illetve a C# vonatkoz\u00e1s\u00e1ra t\u00e9r\u00fcnk ki. Absztrakt oszt\u00e1ly Olyan oszt\u00e1ly, mely nem p\u00e9ld\u00e1nyos\u00edthat\u00f3. C# nyelven az oszt\u00e1lydefin\u00edci\u00f3ban az abstract kulcssz\u00f3t kell ki\u00edrni, pl.: abstract class Shape { \u2026 } Absztrakt oszt\u00e1lyoknak lehetnek absztrakt met\u00f3dusaik, melyeknek nem adjuk meg a t\u00f6rzs\u00e9t, ezekn\u00e9l is az abstract kulcssz\u00f3t kell haszn\u00e1lni: \u2026 abstract void Draw (); \u2026 Absztrakt oszt\u00e1lyok haszn\u00e1lat\u00e1nak k\u00e9t c\u00e9lja lehet: Egy oszt\u00e1lyhierarchi\u00e1ban a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot fel tudjuk vinni egy absztrakt k\u00f6z\u00f6s \u0151sbe, \u00edgy elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t. Egys\u00e9gesen tudjuk absztrakt \u0151sk\u00e9nt hivatkozva a lesz\u00e1rmazottakat kezelni (pl. heterog\u00e9n kollekci\u00f3k). .NET k\u00f6rnyezetben, csak\u00fagy, mint Java nyelven, egy oszt\u00e1lynak csak egy \u0151soszt\u00e1lya lehet. Interf\u00e9sz \u00b6 Az interf\u00e9sz nem m\u00e1s, mint egy m\u0171velethalmaz. Tulajdonk\u00e9ppen egy olyan absztrakt oszt\u00e1lynak felel meg, melynek minden m\u0171velete absztrakt. C# nyelven az interface kulcssz\u00f3val tudunk interf\u00e9szt defini\u00e1lni: public interface ISerializable { void WriteToStream ( Stream s ); void LoadFromStream ( Stream s ); } public interface IComparable { int CompareTo ( Object obj ); } M\u00edg egy oszt\u00e1lynak csak egy \u0151se lehet, ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat: public class Rect : Shape , ISerializable , IComparable { \u2026 } Ebben a p\u00e9ld\u00e1ban Rect oszt\u00e1ly a Shape oszt\u00e1lyb\u00f3l sz\u00e1rmazik, valamint az ISerializable \u00e9s IComparable interf\u00e9szeket implement\u00e1lja (k\u00f6telez\u0151en az \u0151soszt\u00e1lyt kell el\u0151sz\u00f6r megadni). Az interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban annak valamennyi m\u0171velet\u00e9t meg kell val\u00f3s\u00edtani, vagyis meg kell \u00edrni a t\u00f6rzs\u00e9t (kiv\u00e9ve azt a ritka esetet, amikor absztrakt m\u0171velettel val\u00f3s\u00edtjuk meg). Interf\u00e9szek haszn\u00e1lat\u00e1nak egy f\u0151 c\u00e9lja van. Interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk az interf\u00e9szt implement\u00e1l\u00f3 valamennyi oszt\u00e1lyt kezelni (pl. heterog\u00e9n kollekci\u00f3). Ennek egy k\u00f6vetkezm\u00e9nye: az interf\u00e9szek lehet\u0151v\u00e9 teszik sz\u00e9les k\u00f6rben haszn\u00e1lhat\u00f3 oszt\u00e1lyok \u00e9s f\u00fcggv\u00e9nyek meg\u00edr\u00e1s\u00e1t . Pl. tudunk \u00edrni egy univerz\u00e1lis Sort sorrendez\u0151 f\u00fcggv\u00e9nyt, mely b\u00e1rmilyen oszt\u00e1llyal haszn\u00e1lhat\u00f3, mely implement\u00e1lja az IComparable interf\u00e9szt. Az interf\u00e9sz alkalmaz\u00e1s\u00e1nak el\u0151nyei m\u00e9g: A kliensnek el\u00e9g a kiszolg\u00e1l\u00f3 objektum interf\u00e9sz\u00e9t ismernie, \u00edgy egyszer\u0171en tudja a kiszolg\u00e1l\u00f3t haszn\u00e1lni. Ha a kliens csak az interf\u00e9szen kereszt\u00fcl haszn\u00e1lja a kiszolg\u00e1l\u00f3t, \u00edgy a kiszolg\u00e1l\u00f3 bels\u0151 implement\u00e1ci\u00f3ja megv\u00e1ltozhat, a klienst nem kell m\u00f3dos\u00edtani (\u00fajra sem kell ford\u00edtani) . Ennek megfelel\u0151en az interf\u00e9sz egy szerz\u0151d\u00e9s is a kiszolg\u00e1l\u00f3 \u00e9s a kliens k\u00f6z\u00f6tt: am\u00edg a kiszolg\u00e1l\u00f3 garant\u00e1lja az interf\u00e9sz t\u00e1mogat\u00e1s\u00e1t, a klienst nem kell v\u00e1ltoztatni. Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa \u00b6 Az absztrakt \u0151s el\u0151nye az interf\u00e9sszel szemben, hogy adhatunk meg a m\u0171veletekre vonatkoz\u00f3an alap\u00e9rtelmezett implement\u00e1ci\u00f3t, illetve vehet\u00fcnk fel tagv\u00e1ltoz\u00f3kat. Az interf\u00e9szek el\u0151nye az absztrakt \u0151ssel szemben, hogy egy oszt\u00e1ly ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat, m\u00edg \u0151se maximum egy lehet. Az interf\u00e9szek haszn\u00e1lat\u00e1nak van m\u00e9g egy k\u00f6vetkezm\u00e9nye, ami bizonyos esetben kellemetlens\u00e9geket okozhat. Amikor az interf\u00e9szbe \u00faj m\u0171veletet vesz\u00fcnk fel, akkor valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt szint\u00e9n b\u0151v\u00edteni kell, k\u00fcl\u00f6nben a k\u00f3d nem fordul. Absztrakt \u0151s b\u0151v\u00edt\u00e9se eset\u00e9n ez nincs \u00edgy: amennyiben \u00faj m\u0171veletet vesz\u00fcnk fel, lehet\u0151s\u00e9g\u00fcnk van azt virtu\u00e1lis f\u00fcggv\u00e9nyk\u00e9nt felvenni, \u00e9s \u00edgy az \u0151sben alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni r\u00e1 . Ez esetben az lesz\u00e1rmazottak ig\u00e9ny szerint tudj\u00e1k ezt fel\u00fcldefini\u00e1lni, erre nincsenek r\u00e1k\u00e9nyszer\u00edtve. Az interf\u00e9szek ezen tulajdons\u00e1ga k\u00fcl\u00f6n\u00f6sen oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek eset\u00e9n lehet kellemetlen. Tegy\u00fck fel, hogy a .NET \u00faj verzi\u00f3j\u00e1nak kiad\u00e1skor a keretrendszer egyik interf\u00e9sz\u00e9be \u00faj m\u0171veletet vesznek fel. Ekkor valamennyi alkalmaz\u00e1sban valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt m\u00f3dos\u00edtani kell, k\u00fcl\u00f6nben nem fordul a k\u00f3d. Ezt k\u00e9tf\u00e9lek\u00e9ppen lehet elker\u00fclni. Vagy \u0151soszt\u00e1ly haszn\u00e1lat\u00e1val, vagy ha m\u00e9gis interf\u00e9szt kellene b\u0151v\u00edteni, akkor ink\u00e1bb \u00faj interf\u00e9szt bevezet\u00e9s\u00e9vel, amely m\u00e1r az \u00faj m\u0171veletet is tartalmazza. B\u00e1r itt az els\u0151 megk\u00f6zel\u00edt\u00e9s (\u0151soszt\u00e1ly alkalmaz\u00e1sa) t\u0171nik els\u0151 \u00e9rz\u00e9sre vonz\u00f3bbnak, ennek is van h\u00e1tr\u00e1nya: ha az alkalmaz\u00e1s fejleszt\u00e9sekor egy keretrendszerbeli \u0151sb\u0151l sz\u00e1rmaztatunk, akkor oszt\u00e1lyunknak m\u00e1r nem lehet m\u00e1s \u0151se, \u00e9s ez bizony sok esetben f\u00e1jdalmas megk\u00f6t\u00e9st jelent. \u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja . B\u0151vebben inform\u00e1ci\u00f3 itt: default interface methods . Mivel mind az interf\u00e9szek, mind az absztrakt \u0151soszt\u00e1lyok alkalmaz\u00e1sa j\u00e1rhat negat\u00edv k\u00f6vetkezm\u00e9nyekkel is, sz\u00e1mos esetben a kett\u0151 egy\u00fcttes haszn\u00e1lat\u00e1val tudjuk kihozni megold\u00e1sunkb\u00f3l a maximumot (vagyis lesz a k\u00f3dunk k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00fagy, hogy nem, vagy csak minim\u00e1lis m\u00e9rt\u00e9kben tartalmaz k\u00f3dduplik\u00e1ci\u00f3t).","title":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly"},{"location":"egyeb/interfesz-es-absztrakt-os/#interfesz-es-absztrakt-ososztaly","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet.","title":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-osztaly","text":"A fogalmak kor\u00e1bbi t\u00e1rgyak keret\u00e9ben m\u00e1r ismertet\u00e9sre ker\u00fcltek, \u00edgy most csak a legfontosabbakat foglaljuk \u00f6ssze, illetve a C# vonatkoz\u00e1s\u00e1ra t\u00e9r\u00fcnk ki. Absztrakt oszt\u00e1ly Olyan oszt\u00e1ly, mely nem p\u00e9ld\u00e1nyos\u00edthat\u00f3. C# nyelven az oszt\u00e1lydefin\u00edci\u00f3ban az abstract kulcssz\u00f3t kell ki\u00edrni, pl.: abstract class Shape { \u2026 } Absztrakt oszt\u00e1lyoknak lehetnek absztrakt met\u00f3dusaik, melyeknek nem adjuk meg a t\u00f6rzs\u00e9t, ezekn\u00e9l is az abstract kulcssz\u00f3t kell haszn\u00e1lni: \u2026 abstract void Draw (); \u2026 Absztrakt oszt\u00e1lyok haszn\u00e1lat\u00e1nak k\u00e9t c\u00e9lja lehet: Egy oszt\u00e1lyhierarchi\u00e1ban a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot fel tudjuk vinni egy absztrakt k\u00f6z\u00f6s \u0151sbe, \u00edgy elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t. Egys\u00e9gesen tudjuk absztrakt \u0151sk\u00e9nt hivatkozva a lesz\u00e1rmazottakat kezelni (pl. heterog\u00e9n kollekci\u00f3k). .NET k\u00f6rnyezetben, csak\u00fagy, mint Java nyelven, egy oszt\u00e1lynak csak egy \u0151soszt\u00e1lya lehet.","title":"Absztrakt oszt\u00e1ly"},{"location":"egyeb/interfesz-es-absztrakt-os/#interfesz","text":"Az interf\u00e9sz nem m\u00e1s, mint egy m\u0171velethalmaz. Tulajdonk\u00e9ppen egy olyan absztrakt oszt\u00e1lynak felel meg, melynek minden m\u0171velete absztrakt. C# nyelven az interface kulcssz\u00f3val tudunk interf\u00e9szt defini\u00e1lni: public interface ISerializable { void WriteToStream ( Stream s ); void LoadFromStream ( Stream s ); } public interface IComparable { int CompareTo ( Object obj ); } M\u00edg egy oszt\u00e1lynak csak egy \u0151se lehet, ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat: public class Rect : Shape , ISerializable , IComparable { \u2026 } Ebben a p\u00e9ld\u00e1ban Rect oszt\u00e1ly a Shape oszt\u00e1lyb\u00f3l sz\u00e1rmazik, valamint az ISerializable \u00e9s IComparable interf\u00e9szeket implement\u00e1lja (k\u00f6telez\u0151en az \u0151soszt\u00e1lyt kell el\u0151sz\u00f6r megadni). Az interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban annak valamennyi m\u0171velet\u00e9t meg kell val\u00f3s\u00edtani, vagyis meg kell \u00edrni a t\u00f6rzs\u00e9t (kiv\u00e9ve azt a ritka esetet, amikor absztrakt m\u0171velettel val\u00f3s\u00edtjuk meg). Interf\u00e9szek haszn\u00e1lat\u00e1nak egy f\u0151 c\u00e9lja van. Interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk az interf\u00e9szt implement\u00e1l\u00f3 valamennyi oszt\u00e1lyt kezelni (pl. heterog\u00e9n kollekci\u00f3). Ennek egy k\u00f6vetkezm\u00e9nye: az interf\u00e9szek lehet\u0151v\u00e9 teszik sz\u00e9les k\u00f6rben haszn\u00e1lhat\u00f3 oszt\u00e1lyok \u00e9s f\u00fcggv\u00e9nyek meg\u00edr\u00e1s\u00e1t . Pl. tudunk \u00edrni egy univerz\u00e1lis Sort sorrendez\u0151 f\u00fcggv\u00e9nyt, mely b\u00e1rmilyen oszt\u00e1llyal haszn\u00e1lhat\u00f3, mely implement\u00e1lja az IComparable interf\u00e9szt. Az interf\u00e9sz alkalmaz\u00e1s\u00e1nak el\u0151nyei m\u00e9g: A kliensnek el\u00e9g a kiszolg\u00e1l\u00f3 objektum interf\u00e9sz\u00e9t ismernie, \u00edgy egyszer\u0171en tudja a kiszolg\u00e1l\u00f3t haszn\u00e1lni. Ha a kliens csak az interf\u00e9szen kereszt\u00fcl haszn\u00e1lja a kiszolg\u00e1l\u00f3t, \u00edgy a kiszolg\u00e1l\u00f3 bels\u0151 implement\u00e1ci\u00f3ja megv\u00e1ltozhat, a klienst nem kell m\u00f3dos\u00edtani (\u00fajra sem kell ford\u00edtani) . Ennek megfelel\u0151en az interf\u00e9sz egy szerz\u0151d\u00e9s is a kiszolg\u00e1l\u00f3 \u00e9s a kliens k\u00f6z\u00f6tt: am\u00edg a kiszolg\u00e1l\u00f3 garant\u00e1lja az interf\u00e9sz t\u00e1mogat\u00e1s\u00e1t, a klienst nem kell v\u00e1ltoztatni.","title":"Interf\u00e9sz"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-os-es-interfesz-osszehasonlitasa","text":"Az absztrakt \u0151s el\u0151nye az interf\u00e9sszel szemben, hogy adhatunk meg a m\u0171veletekre vonatkoz\u00f3an alap\u00e9rtelmezett implement\u00e1ci\u00f3t, illetve vehet\u00fcnk fel tagv\u00e1ltoz\u00f3kat. Az interf\u00e9szek el\u0151nye az absztrakt \u0151ssel szemben, hogy egy oszt\u00e1ly ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat, m\u00edg \u0151se maximum egy lehet. Az interf\u00e9szek haszn\u00e1lat\u00e1nak van m\u00e9g egy k\u00f6vetkezm\u00e9nye, ami bizonyos esetben kellemetlens\u00e9geket okozhat. Amikor az interf\u00e9szbe \u00faj m\u0171veletet vesz\u00fcnk fel, akkor valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt szint\u00e9n b\u0151v\u00edteni kell, k\u00fcl\u00f6nben a k\u00f3d nem fordul. Absztrakt \u0151s b\u0151v\u00edt\u00e9se eset\u00e9n ez nincs \u00edgy: amennyiben \u00faj m\u0171veletet vesz\u00fcnk fel, lehet\u0151s\u00e9g\u00fcnk van azt virtu\u00e1lis f\u00fcggv\u00e9nyk\u00e9nt felvenni, \u00e9s \u00edgy az \u0151sben alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni r\u00e1 . Ez esetben az lesz\u00e1rmazottak ig\u00e9ny szerint tudj\u00e1k ezt fel\u00fcldefini\u00e1lni, erre nincsenek r\u00e1k\u00e9nyszer\u00edtve. Az interf\u00e9szek ezen tulajdons\u00e1ga k\u00fcl\u00f6n\u00f6sen oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek eset\u00e9n lehet kellemetlen. Tegy\u00fck fel, hogy a .NET \u00faj verzi\u00f3j\u00e1nak kiad\u00e1skor a keretrendszer egyik interf\u00e9sz\u00e9be \u00faj m\u0171veletet vesznek fel. Ekkor valamennyi alkalmaz\u00e1sban valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt m\u00f3dos\u00edtani kell, k\u00fcl\u00f6nben nem fordul a k\u00f3d. Ezt k\u00e9tf\u00e9lek\u00e9ppen lehet elker\u00fclni. Vagy \u0151soszt\u00e1ly haszn\u00e1lat\u00e1val, vagy ha m\u00e9gis interf\u00e9szt kellene b\u0151v\u00edteni, akkor ink\u00e1bb \u00faj interf\u00e9szt bevezet\u00e9s\u00e9vel, amely m\u00e1r az \u00faj m\u0171veletet is tartalmazza. B\u00e1r itt az els\u0151 megk\u00f6zel\u00edt\u00e9s (\u0151soszt\u00e1ly alkalmaz\u00e1sa) t\u0171nik els\u0151 \u00e9rz\u00e9sre vonz\u00f3bbnak, ennek is van h\u00e1tr\u00e1nya: ha az alkalmaz\u00e1s fejleszt\u00e9sekor egy keretrendszerbeli \u0151sb\u0151l sz\u00e1rmaztatunk, akkor oszt\u00e1lyunknak m\u00e1r nem lehet m\u00e1s \u0151se, \u00e9s ez bizony sok esetben f\u00e1jdalmas megk\u00f6t\u00e9st jelent. \u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja . B\u0151vebben inform\u00e1ci\u00f3 itt: default interface methods . Mivel mind az interf\u00e9szek, mind az absztrakt \u0151soszt\u00e1lyok alkalmaz\u00e1sa j\u00e1rhat negat\u00edv k\u00f6vetkezm\u00e9nyekkel is, sz\u00e1mos esetben a kett\u0151 egy\u00fcttes haszn\u00e1lat\u00e1val tudjuk kihozni megold\u00e1sunkb\u00f3l a maximumot (vagyis lesz a k\u00f3dunk k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00fagy, hogy nem, vagy csak minim\u00e1lis m\u00e9rt\u00e9kben tartalmaz k\u00f3dduplik\u00e1ci\u00f3t).","title":"Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa"},{"location":"egyeb/uml-kod-kapcsolata/","text":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet. Bevezet\u0151 \u00b6 A fejezet egy r\u00f6vid, v\u00e1zlatos \u00e1ttekint\u00e9st ad az UML oszt\u00e1lydiagram \u00e9s a forr\u00e1sk\u00f3d k\u00f6z\u00f6tti lek\u00e9pez\u00e9s alapjair\u00f3l, a megel\u0151z\u0151 f\u00e9l\u00e9vben Szoftvertechnol\u00f3gia t\u00e1rgyb\u00f3l m\u00e1r tanultak ism\u00e9tl\u00e9sek\u00e9nt. Napjainkban sz\u00e1mos szoftverfejleszt\u00e9si m\u00f3dszertan l\u00e9tezik. Ezek k\u00fcl\u00f6nb\u00f6z\u0151 m\u00e9rt\u00e9kben \u00e9p\u00edtenek arra, illetve k\u00f6vetelik meg, hogy a szoftver elk\u00e9sz\u00edt\u00e9se sor\u00e1n modellez\u00e9st alkalmazzunk. Az azonban k\u00e9ts\u00e9gtelen, hogy m\u00e9g a legagilisabb, legink\u00e1bb \u201ek\u00f3dcentrikus\u201d szeml\u00e9letm\u00f3dok k\u00f6vet\u0151i is hasznosnak \u00edt\u00e9lik a szoftver fontosabb/komplexebb komponenseinek \u00e9s szerkezeti elemeinek vizu\u00e1lis modellez\u00e9s\u00e9t annak grafikus volt\u00e1b\u00f3l ad\u00f3d\u00f3 nagyobb kifejez\u0151 ereje miatt. Tegy\u00fck fel, hogy feladatunk egy alkalmaz\u00e1s, vagy annak adott modulj\u00e1nak elk\u00e9sz\u00edt\u00e9se. A v\u00e1lasztott m\u00f3dszertanunkat k\u00f6vetve \u2013 j\u00f3 es\u00e9llyel t\u00f6bb iter\u00e1ci\u00f3ban \u2013 a k\u00f6vetelm\u00e9ny elemz\u00e9s, anal\u00edzis, tervez\u00e9s, implement\u00e1ci\u00f3 \u00e9s tesztel\u00e9s l\u00e9p\u00e9seit fogjuk \u00e9rinteni. Koncentr\u00e1ljunk most a tervez\u00e9si f\u00e1zisra. Ennek sor\u00e1n elk\u00e9sz\u00fcl a rendszer (legal\u00e1bbis bizonyos r\u00e9szeinek) r\u00e9szletes terve, mely kimenete a r\u00e9szletes/ implement\u00e1ci\u00f3s terv, illetve modell. Ezen a szinten a modellben szerepl\u0151 bizonyos elemek (pl. oszt\u00e1lyok) egy\u00e9rtelm\u0171en lek\u00e9pezhet\u0151k az adott alrendszer implement\u00e1ci\u00f3j\u00e1ul v\u00e1lasztott programoz\u00e1si nyelv elemeire. Ha j\u00f3 a fejleszt\u0151/modellez\u0151 eszk\u00f6z\u00fcnk, akkor az le tudja gener\u00e1lni az oszt\u00e1lyok v\u00e1z\u00e1t (pl. C++, Java, C# oszt\u00e1lyok). A feladatunk ezt k\u00f6vet\u0151en a gener\u00e1lt k\u00f3dban szerepl\u0151 a met\u00f3dusok t\u00f6rzs\u00e9nek kit\u00f6lt\u00e9se. Fogalmak \u00b6 Forward engineering: modellb\u0151l k\u00f3d gener\u00e1l\u00e1sa. A r\u00e9szletes tervb\u0151l a modellez\u0151 eszk\u00f6z le tudja gener\u00e1lni a programv\u00e1zat. El\u0151nye, hogy kevesebbet kell k\u00f3dolni. Reverse engineering: k\u00f3db\u00f3l modell gener\u00e1l\u00e1sa. A m\u00e1r k\u00e9sz k\u00f3d meg\u00e9rt\u00e9s\u00e9t seg\u00edti. Round-trip engineering: az el\u0151z\u0151 kett\u0151 egy\u00fcttes alkalmaz\u00e1sa. A l\u00e9nyeg: a modell \u00e9s a k\u00f3d v\u00e9gig szinkronban van. Ha a k\u00f3dban v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a modellben, ha a modellben v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a k\u00f3dban. Ahhoz, hogy a k\u00f3dgener\u00e1l\u00e1s el\u0151nyeivel \u00e9lni tudjunk, a k\u00f6vetkez\u0151kkel kell tiszt\u00e1ban legy\u00fcnk: ismern\u00fcnk kell, hogy az adott modellez\u0151 eszk\u00f6z az egyes modell elemeket hogyan k\u00e9pezi le az adott programoz\u00e1si nyelv elemeire. A lek\u00e9pez\u00e9s f\u00fcgg a nyelvt\u0151l \u00e9s a modellez\u0151 eszk\u00f6zt\u0151l is, nincs r\u00e1 univerz\u00e1lis szabv\u00e1ny. A lek\u00e9pez\u00e9sek \u00e1ltal\u00e1ban magukt\u00f3l \u00e9rtet\u0151d\u0151ek, t\u00fal nagy elt\u00e9r\u00e9s nem szokott lenni. A k\u00f6vetkez\u0151kben azt tekintj\u00fck \u00e1t, hogy az UML oszt\u00e1lydiagram egyes modellelemei hogyan k\u00e9pz\u0151dnek le forr\u00e1sk\u00f3dra, \u00e9s viszont. Oszt\u00e1lyok lek\u00e9pez\u00e9se \u00b6 Mondhatni trivi\u00e1lisan egyszer\u0171: UML oszt\u00e1ly -> oszt\u00e1ly UML attrib\u00fatum -> tagv\u00e1ltoz\u00f3 UML m\u0171velet -> m\u0171velet/met\u00f3dus Egy p\u00e9lda: , mely a k\u00f6vetkez\u0151 k\u00f3dnak felel meg C# nyelven: public abstract class Shape { private int x ; private int y ; public Shape ( int x , int y ) { this . x = x ; this . y = y ; } public abstract void Draw ( Graphics gr ); } A l\u00e1that\u00f3s\u00e1g kapcs\u00e1n a lek\u00e9pez\u00e9s: +: public -: private #: protected Enn\u00e9l izgalmasabb k\u00e9rd\u00e9sk\u00f6r, hogy milyen m\u00f3don t\u00f6rt\u00e9nik az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatok lek\u00e9pez\u00e9se, ezt a k\u00f6vetkez\u0151 fejezetek ismertetik. I. \u00c1ltal\u00e1nos\u00edt\u00e1s, specializ\u00e1ci\u00f3 kapcsolat \u00b6 C# lek\u00e9pez\u00e9s: public class Base { }; public class Derived : Base { }; II. Asszoci\u00e1ci\u00f3 \u00b6 Ez a kapcsolatt\u00edpus mindig kommunik\u00e1ci\u00f3t jelent az oszt\u00e1lyok objektumai k\u00f6z\u00f6tt. Egy adott oszt\u00e1ly ig\u00e9nybe veszi egy m\u00e1sik oszt\u00e1ly szolg\u00e1ltat\u00e1sait. A) Lek\u00e9pez\u00e9s 0..1 multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n \u00b6 Ebben az esetben egy pointert vagy referenci\u00e1t tartalmaz a kliens oszt\u00e1ly, melyen kereszt\u00fcl ig\u00e9nybe tudja venni a c\u00e9loszt\u00e1ly szolg\u00e1ltat\u00e1sait (meg tudja h\u00edvni annak m\u0171veleteit). P\u00e9lda: C++ lek\u00e9pez\u00e9s: class Application { WindowManager * windowManager ; }; class WindowManager { }; C# lek\u00e9pez\u00e9s (nincsenek pointerek, csak referenci\u00e1k): class Application { WindowManager windowManager ; }; class WindowManager { }; Mink\u00e9t esetben azt l\u00e1tjuk, hogy a kliens oszt\u00e1lyba felvesz\u00fcnk egy pointer vagy referencia tagv\u00e1ltoz\u00f3t, melynek t\u00edpusa megegyezik az asszoci\u00e1ci\u00f3ban hivatkozott c\u00e9loszt\u00e1ly t\u00edpus\u00e1val, illetve a tagv\u00e1ltoz\u00f3 neve az asszoci\u00e1ci\u00f3s kapcsolatra a c\u00e9loszt\u00e1lyra megadott szereppel (role) , mely a p\u00e9ld\u00e1ban a windowManager . A lek\u00e9pez\u00e9s logikus, hiszen a kliens ezen pointeren/referenci\u00e1n kereszt\u00fcl tudja a c\u00e9lobjektumot b\u00e1rmely m\u0171velet\u00e9b\u0151l el\u00e9rni \u00e9s met\u00f3dusait megh\u00edvni. Megjegyz\u00e9s. El\u0151fordulhat, hogy az asszoci\u00e1ci\u00f3 k\u00e9tir\u00e1ny\u00fa, mindk\u00e9t oszt\u00e1ly ig\u00e9nybe veszi a m\u00e1sik szolg\u00e1ltat\u00e1sait. Ilyenkor sokszor nem tessz\u00fck ki az asszoci\u00e1ci\u00f3 mindk\u00e9t v\u00e9g\u00e9re a nyilat, hanem mindk\u00e9t v\u00e9g\u00e9r\u0151l elhagyjuk azt. Ilyen k\u00e9tir\u00e1ny\u00fa kapcsolat eset\u00e9n a szerepet (role) a kapcsolat mindk\u00e9t v\u00e9g\u00e9n meg kell adni. A lek\u00e9pez\u00e9s sor\u00e1n mindk\u00e9t oszt\u00e1lyba felvesz\u00fcnk egy pointert/referenci\u00e1t a m\u00e1sikra. B) Lek\u00e9pez\u00e9s 0..n multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n \u00b6 Ebben az esetben egy kliensoldali objektum t\u00f6bb c\u00e9loldali objektummal van kapcsolatban. P\u00e9lda: Egy WindowManager objektum t\u00f6bb Window objektumot menedzsel. A lek\u00e9pez\u00e9s sor\u00e1n a kliens oszt\u00e1lyba a c\u00e9loszt\u00e1lybeli objektumok valamilyen gy\u0171jtem\u00e9ny\u00e9t vessz\u00fck fel. Ez lehet t\u00f6mb, lista, stb., ami a c\u00e9lunknak az adott helyzetben legink\u00e1bb megfelel. Egy lek\u00e9pz\u00e9si lehet\u0151s\u00e9g a fenti p\u00e9ld\u00e1ra C++ nyelven: class WindowManager { vector < Window *> windows ; }; Illetve C# nyelven: class WindowManager { List < Window > windows ; }; III. Aggreg\u00e1ci\u00f3 (tartalmaz\u00e1s, r\u00e9sz-eg\u00e9sz viszony) \u00b6 \u00c1ltal\u00e1ban a lek\u00e9pez\u00e9se pontosan \u00fagy t\u00f6rt\u00e9nik, mint az asszoci\u00e1ci\u00f3 eset\u00e9ben. IV. F\u00fcgg\u0151s\u00e9g (dependency) \u00b6 A leglaz\u00e1bb kapcsolatot jelenti oszt\u00e1lyok k\u00f6z\u00f6tt. P\u00e9lda: A jelent\u00e9se: a Window oszt\u00e1ly f\u00fcgg a Graphics oszt\u00e1lyt\u00f3l. Vagyis, ha a Graphics oszt\u00e1ly megv\u00e1ltozik, akkor lehet, hogy a Window oszt\u00e1lyt is meg kell v\u00e1ltoztatni. Ezt a kapcsolatt\u00edpust akkor szoktuk haszn\u00e1lni, ha a f\u00fcgg\u0151s\u00e9gi kapcsolat elej\u00e9n lev\u0151 oszt\u00e1ly met\u00f3dusai param\u00e9terlist\u00e1j\u00e1ban/visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben szerepel a kapcsolat v\u00e9g\u00e9n lev\u0151 oszt\u00e1ly. A p\u00e9ld\u00e1ban a Window oszt\u00e1ly onDraw m\u0171velete param\u00e9terk\u00e9nt megkapja a Graphics oszt\u00e1ly egy objektum\u00e1t, \u00edgy f\u00fcgg t\u0151le, hiszen a met\u00f3dus t\u00f6rzs\u00e9ben \u00edgy meg tudja h\u00edvni a Graphics oszt\u00e1ly met\u00f3dusait. Ha pl. a Graphics oszt\u00e1ly FillRect met\u00f3dus\u00e1nak nev\u00e9t megv\u00e1ltoztatjuk, akkor ezt a v\u00e1ltoz\u00e1st \u00e1t kell vezetni a h\u00edv\u00e1sok hely\u00e9n, vagyis a Window oszt\u00e1ly onDraw met\u00f3dus\u00e1nak t\u00f6rzs\u00e9ben is.","title":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete"},{"location":"egyeb/uml-kod-kapcsolata/#az-uml-osztalydiagram-es-a-kod-kapcsolatanak-elmelete","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet.","title":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete"},{"location":"egyeb/uml-kod-kapcsolata/#bevezeto","text":"A fejezet egy r\u00f6vid, v\u00e1zlatos \u00e1ttekint\u00e9st ad az UML oszt\u00e1lydiagram \u00e9s a forr\u00e1sk\u00f3d k\u00f6z\u00f6tti lek\u00e9pez\u00e9s alapjair\u00f3l, a megel\u0151z\u0151 f\u00e9l\u00e9vben Szoftvertechnol\u00f3gia t\u00e1rgyb\u00f3l m\u00e1r tanultak ism\u00e9tl\u00e9sek\u00e9nt. Napjainkban sz\u00e1mos szoftverfejleszt\u00e9si m\u00f3dszertan l\u00e9tezik. Ezek k\u00fcl\u00f6nb\u00f6z\u0151 m\u00e9rt\u00e9kben \u00e9p\u00edtenek arra, illetve k\u00f6vetelik meg, hogy a szoftver elk\u00e9sz\u00edt\u00e9se sor\u00e1n modellez\u00e9st alkalmazzunk. Az azonban k\u00e9ts\u00e9gtelen, hogy m\u00e9g a legagilisabb, legink\u00e1bb \u201ek\u00f3dcentrikus\u201d szeml\u00e9letm\u00f3dok k\u00f6vet\u0151i is hasznosnak \u00edt\u00e9lik a szoftver fontosabb/komplexebb komponenseinek \u00e9s szerkezeti elemeinek vizu\u00e1lis modellez\u00e9s\u00e9t annak grafikus volt\u00e1b\u00f3l ad\u00f3d\u00f3 nagyobb kifejez\u0151 ereje miatt. Tegy\u00fck fel, hogy feladatunk egy alkalmaz\u00e1s, vagy annak adott modulj\u00e1nak elk\u00e9sz\u00edt\u00e9se. A v\u00e1lasztott m\u00f3dszertanunkat k\u00f6vetve \u2013 j\u00f3 es\u00e9llyel t\u00f6bb iter\u00e1ci\u00f3ban \u2013 a k\u00f6vetelm\u00e9ny elemz\u00e9s, anal\u00edzis, tervez\u00e9s, implement\u00e1ci\u00f3 \u00e9s tesztel\u00e9s l\u00e9p\u00e9seit fogjuk \u00e9rinteni. Koncentr\u00e1ljunk most a tervez\u00e9si f\u00e1zisra. Ennek sor\u00e1n elk\u00e9sz\u00fcl a rendszer (legal\u00e1bbis bizonyos r\u00e9szeinek) r\u00e9szletes terve, mely kimenete a r\u00e9szletes/ implement\u00e1ci\u00f3s terv, illetve modell. Ezen a szinten a modellben szerepl\u0151 bizonyos elemek (pl. oszt\u00e1lyok) egy\u00e9rtelm\u0171en lek\u00e9pezhet\u0151k az adott alrendszer implement\u00e1ci\u00f3j\u00e1ul v\u00e1lasztott programoz\u00e1si nyelv elemeire. Ha j\u00f3 a fejleszt\u0151/modellez\u0151 eszk\u00f6z\u00fcnk, akkor az le tudja gener\u00e1lni az oszt\u00e1lyok v\u00e1z\u00e1t (pl. C++, Java, C# oszt\u00e1lyok). A feladatunk ezt k\u00f6vet\u0151en a gener\u00e1lt k\u00f3dban szerepl\u0151 a met\u00f3dusok t\u00f6rzs\u00e9nek kit\u00f6lt\u00e9se.","title":"Bevezet\u0151"},{"location":"egyeb/uml-kod-kapcsolata/#fogalmak","text":"Forward engineering: modellb\u0151l k\u00f3d gener\u00e1l\u00e1sa. A r\u00e9szletes tervb\u0151l a modellez\u0151 eszk\u00f6z le tudja gener\u00e1lni a programv\u00e1zat. El\u0151nye, hogy kevesebbet kell k\u00f3dolni. Reverse engineering: k\u00f3db\u00f3l modell gener\u00e1l\u00e1sa. A m\u00e1r k\u00e9sz k\u00f3d meg\u00e9rt\u00e9s\u00e9t seg\u00edti. Round-trip engineering: az el\u0151z\u0151 kett\u0151 egy\u00fcttes alkalmaz\u00e1sa. A l\u00e9nyeg: a modell \u00e9s a k\u00f3d v\u00e9gig szinkronban van. Ha a k\u00f3dban v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a modellben, ha a modellben v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a k\u00f3dban. Ahhoz, hogy a k\u00f3dgener\u00e1l\u00e1s el\u0151nyeivel \u00e9lni tudjunk, a k\u00f6vetkez\u0151kkel kell tiszt\u00e1ban legy\u00fcnk: ismern\u00fcnk kell, hogy az adott modellez\u0151 eszk\u00f6z az egyes modell elemeket hogyan k\u00e9pezi le az adott programoz\u00e1si nyelv elemeire. A lek\u00e9pez\u00e9s f\u00fcgg a nyelvt\u0151l \u00e9s a modellez\u0151 eszk\u00f6zt\u0151l is, nincs r\u00e1 univerz\u00e1lis szabv\u00e1ny. A lek\u00e9pez\u00e9sek \u00e1ltal\u00e1ban magukt\u00f3l \u00e9rtet\u0151d\u0151ek, t\u00fal nagy elt\u00e9r\u00e9s nem szokott lenni. A k\u00f6vetkez\u0151kben azt tekintj\u00fck \u00e1t, hogy az UML oszt\u00e1lydiagram egyes modellelemei hogyan k\u00e9pz\u0151dnek le forr\u00e1sk\u00f3dra, \u00e9s viszont.","title":"Fogalmak"},{"location":"egyeb/uml-kod-kapcsolata/#osztalyok-lekepezese","text":"Mondhatni trivi\u00e1lisan egyszer\u0171: UML oszt\u00e1ly -> oszt\u00e1ly UML attrib\u00fatum -> tagv\u00e1ltoz\u00f3 UML m\u0171velet -> m\u0171velet/met\u00f3dus Egy p\u00e9lda: , mely a k\u00f6vetkez\u0151 k\u00f3dnak felel meg C# nyelven: public abstract class Shape { private int x ; private int y ; public Shape ( int x , int y ) { this . x = x ; this . y = y ; } public abstract void Draw ( Graphics gr ); } A l\u00e1that\u00f3s\u00e1g kapcs\u00e1n a lek\u00e9pez\u00e9s: +: public -: private #: protected Enn\u00e9l izgalmasabb k\u00e9rd\u00e9sk\u00f6r, hogy milyen m\u00f3don t\u00f6rt\u00e9nik az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatok lek\u00e9pez\u00e9se, ezt a k\u00f6vetkez\u0151 fejezetek ismertetik.","title":"Oszt\u00e1lyok lek\u00e9pez\u00e9se"},{"location":"egyeb/uml-kod-kapcsolata/#i-altalanositas-specializacio-kapcsolat","text":"C# lek\u00e9pez\u00e9s: public class Base { }; public class Derived : Base { };","title":"I. \u00c1ltal\u00e1nos\u00edt\u00e1s, specializ\u00e1ci\u00f3 kapcsolat"},{"location":"egyeb/uml-kod-kapcsolata/#ii-asszociacio","text":"Ez a kapcsolatt\u00edpus mindig kommunik\u00e1ci\u00f3t jelent az oszt\u00e1lyok objektumai k\u00f6z\u00f6tt. Egy adott oszt\u00e1ly ig\u00e9nybe veszi egy m\u00e1sik oszt\u00e1ly szolg\u00e1ltat\u00e1sait.","title":"II. Asszoci\u00e1ci\u00f3"},{"location":"egyeb/uml-kod-kapcsolata/#a-lekepezes-01-multiplicitasu-asszociacios-kapcsolat-eseten","text":"Ebben az esetben egy pointert vagy referenci\u00e1t tartalmaz a kliens oszt\u00e1ly, melyen kereszt\u00fcl ig\u00e9nybe tudja venni a c\u00e9loszt\u00e1ly szolg\u00e1ltat\u00e1sait (meg tudja h\u00edvni annak m\u0171veleteit). P\u00e9lda: C++ lek\u00e9pez\u00e9s: class Application { WindowManager * windowManager ; }; class WindowManager { }; C# lek\u00e9pez\u00e9s (nincsenek pointerek, csak referenci\u00e1k): class Application { WindowManager windowManager ; }; class WindowManager { }; Mink\u00e9t esetben azt l\u00e1tjuk, hogy a kliens oszt\u00e1lyba felvesz\u00fcnk egy pointer vagy referencia tagv\u00e1ltoz\u00f3t, melynek t\u00edpusa megegyezik az asszoci\u00e1ci\u00f3ban hivatkozott c\u00e9loszt\u00e1ly t\u00edpus\u00e1val, illetve a tagv\u00e1ltoz\u00f3 neve az asszoci\u00e1ci\u00f3s kapcsolatra a c\u00e9loszt\u00e1lyra megadott szereppel (role) , mely a p\u00e9ld\u00e1ban a windowManager . A lek\u00e9pez\u00e9s logikus, hiszen a kliens ezen pointeren/referenci\u00e1n kereszt\u00fcl tudja a c\u00e9lobjektumot b\u00e1rmely m\u0171velet\u00e9b\u0151l el\u00e9rni \u00e9s met\u00f3dusait megh\u00edvni. Megjegyz\u00e9s. El\u0151fordulhat, hogy az asszoci\u00e1ci\u00f3 k\u00e9tir\u00e1ny\u00fa, mindk\u00e9t oszt\u00e1ly ig\u00e9nybe veszi a m\u00e1sik szolg\u00e1ltat\u00e1sait. Ilyenkor sokszor nem tessz\u00fck ki az asszoci\u00e1ci\u00f3 mindk\u00e9t v\u00e9g\u00e9re a nyilat, hanem mindk\u00e9t v\u00e9g\u00e9r\u0151l elhagyjuk azt. Ilyen k\u00e9tir\u00e1ny\u00fa kapcsolat eset\u00e9n a szerepet (role) a kapcsolat mindk\u00e9t v\u00e9g\u00e9n meg kell adni. A lek\u00e9pez\u00e9s sor\u00e1n mindk\u00e9t oszt\u00e1lyba felvesz\u00fcnk egy pointert/referenci\u00e1t a m\u00e1sikra.","title":"A) Lek\u00e9pez\u00e9s 0..1 multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n"},{"location":"egyeb/uml-kod-kapcsolata/#b-lekepezes-0n-multiplicitasu-asszociacios-kapcsolat-eseten","text":"Ebben az esetben egy kliensoldali objektum t\u00f6bb c\u00e9loldali objektummal van kapcsolatban. P\u00e9lda: Egy WindowManager objektum t\u00f6bb Window objektumot menedzsel. A lek\u00e9pez\u00e9s sor\u00e1n a kliens oszt\u00e1lyba a c\u00e9loszt\u00e1lybeli objektumok valamilyen gy\u0171jtem\u00e9ny\u00e9t vessz\u00fck fel. Ez lehet t\u00f6mb, lista, stb., ami a c\u00e9lunknak az adott helyzetben legink\u00e1bb megfelel. Egy lek\u00e9pz\u00e9si lehet\u0151s\u00e9g a fenti p\u00e9ld\u00e1ra C++ nyelven: class WindowManager { vector < Window *> windows ; }; Illetve C# nyelven: class WindowManager { List < Window > windows ; };","title":"B) Lek\u00e9pez\u00e9s 0..n multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n"},{"location":"egyeb/uml-kod-kapcsolata/#iii-aggregacio-tartalmazas-resz-egesz-viszony","text":"\u00c1ltal\u00e1ban a lek\u00e9pez\u00e9se pontosan \u00fagy t\u00f6rt\u00e9nik, mint az asszoci\u00e1ci\u00f3 eset\u00e9ben.","title":"III. Aggreg\u00e1ci\u00f3 (tartalmaz\u00e1s, r\u00e9sz-eg\u00e9sz viszony)"},{"location":"egyeb/uml-kod-kapcsolata/#iv-fuggoseg-dependency","text":"A leglaz\u00e1bb kapcsolatot jelenti oszt\u00e1lyok k\u00f6z\u00f6tt. P\u00e9lda: A jelent\u00e9se: a Window oszt\u00e1ly f\u00fcgg a Graphics oszt\u00e1lyt\u00f3l. Vagyis, ha a Graphics oszt\u00e1ly megv\u00e1ltozik, akkor lehet, hogy a Window oszt\u00e1lyt is meg kell v\u00e1ltoztatni. Ezt a kapcsolatt\u00edpust akkor szoktuk haszn\u00e1lni, ha a f\u00fcgg\u0151s\u00e9gi kapcsolat elej\u00e9n lev\u0151 oszt\u00e1ly met\u00f3dusai param\u00e9terlist\u00e1j\u00e1ban/visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben szerepel a kapcsolat v\u00e9g\u00e9n lev\u0151 oszt\u00e1ly. A p\u00e9ld\u00e1ban a Window oszt\u00e1ly onDraw m\u0171velete param\u00e9terk\u00e9nt megkapja a Graphics oszt\u00e1ly egy objektum\u00e1t, \u00edgy f\u00fcgg t\u0151le, hiszen a met\u00f3dus t\u00f6rzs\u00e9ben \u00edgy meg tudja h\u00edvni a Graphics oszt\u00e1ly met\u00f3dusait. Ha pl. a Graphics oszt\u00e1ly FillRect met\u00f3dus\u00e1nak nev\u00e9t megv\u00e1ltoztatjuk, akkor ezt a v\u00e1ltoz\u00e1st \u00e1t kell vezetni a h\u00edv\u00e1sok hely\u00e9n, vagyis a Window oszt\u00e1ly onDraw met\u00f3dus\u00e1nak t\u00f6rzs\u00e9ben is.","title":"IV. F\u00fcgg\u0151s\u00e9g (dependency)"},{"location":"gyakorlatvezetoknek/","text":"Gyakorlatvezet\u0151knek \u00b6 COMING SOON","title":"Gyakorlatvezet\u0151knek"},{"location":"gyakorlatvezetoknek/#gyakorlatvezetoknek","text":"COMING SOON","title":"Gyakorlatvezet\u0151knek"},{"location":"hazi/","text":"H\u00e1zi feladatok \u00b6 COMING SOON","title":"H\u00e1zi feladatok"},{"location":"hazi/#hazi-feladatok","text":"COMING SOON","title":"H\u00e1zi feladatok"},{"location":"hazi/VisualStudio/","text":"Visual Studio & .NET SDK telep\u00edt\u00e9se \u00b6 COMING SOON","title":"Visual Studio & .NET SDK telep\u00edt\u00e9se"},{"location":"hazi/VisualStudio/#visual-studio-net-sdk-telepitese","text":"COMING SOON","title":"Visual Studio &amp; .NET SDK telep\u00edt\u00e9se"},{"location":"hazi/1-model-es-kod-kapcsolata/","text":"1. HF - A modell \u00e9s a k\u00f3d kapcsolata \u00b6 COMING SOON","title":"1. HF - A modell \u00e9s a k\u00f3d kapcsolata"},{"location":"hazi/1-model-es-kod-kapcsolata/#1-hf-a-modell-es-a-kod-kapcsolata","text":"COMING SOON","title":"1. HF - A modell \u00e9s a k\u00f3d kapcsolata"},{"location":"hazi/2-modern-nyelvi-eszkozok/","text":"2. HF - Modern nyelvi eszk\u00f6z\u00f6k \u00b6 COMING SOON","title":"2. HF - Modern nyelvi eszk\u00f6z\u00f6k"},{"location":"hazi/2-modern-nyelvi-eszkozok/#2-hf-modern-nyelvi-eszkozok","text":"COMING SOON","title":"2. HF - Modern nyelvi eszk\u00f6z\u00f6k"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/","text":"3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa \u00b6 COMING SOON","title":"3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#3-hf-felhasznaloi-felulet-kialakitasa","text":"COMING SOON","title":"3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/","text":"4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se \u00b6 COMING SOON","title":"4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#4-hf-tobbszalu-alkalmazasok-fejlesztese","text":"COMING SOON","title":"4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se"},{"location":"hazi/5-document-view-architectura/","text":"5. HF - Document-View architekt\u00fara \u00b6 COMING SOON","title":"5. HF - Document-View architekt\u00fara"},{"location":"hazi/5-document-view-architectura/#5-hf-document-view-architektura","text":"COMING SOON","title":"5. HF - Document-View architekt\u00fara"},{"location":"labor/1-model-es-kod-kapcsolata/","text":"1. A modell \u00e9s a k\u00f3d kapcsolata \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja: Ismerked\u00e9s a hallgat\u00f3kkal/gyakorlatvezet\u0151vel A gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyek pontos\u00edt\u00e1sa Elindul\u00e1s Visual Studio-val \u00e9s .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9vel. Egy egyszer\u0171 Hello World .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja Gyakorlatvezet\u0151knek A hallgat\u00f3k kor\u00e1bbi tanulm\u00e1nyaik sor\u00e1n C++ gyakorlaton m\u00e1r haszn\u00e1lt\u00e1k a Visual Studio k\u00f6rnyezet, \u00edgy a c\u00e9l jelen esetben az ismeretek feleleven\u00edt\u00e9se \u00e9s \u00e9let\u00fcnk els\u0151 C# alkalmaz\u00e1s\u00e1nak elk\u00e9sz\u00edt\u00e9se. Ugyanakkor el\u0151fordulhat, hogy a hallgat\u00f3k nem eml\u00e9keznek pontosan a Visual Studio haszn\u00e1lat\u00e1ra, \u00edgy a feladatok megold\u00e1sa sor\u00e1n ezeket folyamatosan eleven\u00edts\u00fck fel (pl. Solution Explorer, F5-futtat\u00e1s, breakpoint haszn\u00e1lat, stb.) El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Visual Studio-b\u00f3l a legfrissebb verzi\u00f3t c\u00e9lszer\u0171 feltenni. A Community Edition, Professional \u00e9s az Enterprise verzi\u00f3 is megfelel. A Community Edition ingyenes, let\u00f6lthet\u0151 a Microsoft honlapj\u00e1r\u00f3l. A Professional fizet\u0151s, de az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ez is ingyenesen el\u00e9rhet\u0151 ( https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben). Visual Studio Class Diagram t\u00e1mogat\u00e1s Jelen gyakorlat bizonyos feladatain\u00e1l (\u00e9s az els\u0151 h\u00e1zi feladat eset\u00e9ben is) a Visual Studio Class Designer t\u00e1mogat\u00e1s\u00e1t haszn\u00e1ljuk. A Visual Studio nem teszi fel minden esetben a Class Designer komponenst a telep\u00edt\u00e9s sor\u00e1n. Ha nem lehet Class Diagram-ot felvenni a Visual Studio projektbe (mert a Class Diagram nem szerepel a list\u00e1ban az Add New Item parancs sor\u00e1n megjelen\u0151 ablak list\u00e1j\u00e1ban \u2013 err\u0151l a jelen \u00fatmutat\u00f3 k\u00e9s\u0151bbi fejezet\u00e9ben b\u0151vebben), akkor a Class Diagram komponenst ut\u00f3lag kell telep\u00edteni: Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel). A megjelen\u0151 ablakban \u201eIndividual components\u201d f\u00fcl kiv\u00e1laszt\u00e1sa A keres\u0151mez\u0151be \u201eclass designer\u201d beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \u201eClass Designer\u201d elem ki van pip\u00e1lva. Amit \u00e9rdemes \u00e1tn\u00e9zned: A gyakorlathoz nem kapcsol\u00f3dik a t\u00e1rgyb\u00f3l el\u0151ad\u00e1s. Ugyanakkor a gyakorlat \u00e9p\u00edt az UML alapismeretekre, illetve az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d egym\u00e1sra t\u00f6rt\u00e9n\u0151 lek\u00e9pez\u00e9s\u00e9nek alapjaira. Gyakorlat menete \u00b6 A gyakorlatvezet\u0151 a gyakorlat elej\u00e9n \u00f6sszefoglalja a gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyeket: \u2022 A t\u00e1rgyi adatlapon ezek t\u00f6bbs\u00e9ge megtal\u00e1lhat\u00f3 \u2022 Az otthoni feladatokr\u00f3l inform\u00e1ci\u00f3 a t\u00e1rgy honlapj\u00e1n tal\u00e1lhat\u00f3. Visual Studio fejleszt\u0151eszk\u00f6zzel, .NET alkalmaz\u00e1sokat fogunk k\u00e9sz\u00edteni C# nyelven. A C# hasonl\u00edt a Java-hoz, fokozatosan ismerj\u00fck meg a k\u00fcl\u00f6nbs\u00e9geket. A gyakorlat vezetett, gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok. 1. Feladat - \u201eHello world\u201d .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se \u00b6 A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely a konzolra ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget. Az alkalmaz\u00e1st C# nyelven k\u00e9sz\u00edtj\u00fck el. A leford\u00edtott alkalmaz\u00e1s futtat\u00e1s\u00e1t a .NET runtime v\u00e9gzi. A ford\u00edt\u00e1s/futtat\u00e1s elm\u00e9leti h\u00e1tter\u00e9t, valamint a .NET alapjait az els\u0151 el\u0151ad\u00e1s ismerteti. A solution \u00e9s azon bel\u00fcli projekt l\u00e9trehoz\u00e1s\u00e1nak l\u00e9p\u00e9sei Visual Studio 2022 eset\u00e9n: \u00daj projekt var\u00e1zsl\u00f3 elind\u00edt\u00e1sa, melyre k\u00e9t m\u00f3d is van Ind\u00edt\u00f3ablak seg\u00edts\u00e9g\u00e9vel Ind\u00edtsuk el a Visual Studio-t A megjelen\u0151 ind\u00edt\u00f3ablak jobb oldali s\u00e1vj\u00e1ban \u201eCreate new project\u201d M\u00e1r fut\u00f3 Visual Studio-ban File/New-Project A Create new project var\u00e1zsl\u00f3ban a \u201eConsole app\u201d (\u00e9s NEM a \u201eConsole app (.NET Framework)\u201d sablont v\u00e1lasszuk ki, ebb\u0151l is a C#-osat. Azt, hogy C#-os, a sablon ikonj\u00e1nak bal fels\u0151 sarka jelzi. Ha nem l\u00e1tjuk a list\u00e1ban, r\u00e1 kell keresni/sz\u0171rni. R\u00e1kereshet\u00fcnk a fels\u0151 keres\u0151s\u00e1vban a \u201econsole\u201d be\u00edr\u00e1s\u00e1val. Vagy az alatta lev\u0151 leny\u00edl\u00f3 mez\u0151k seg\u00edts\u00e9g\u00e9vel: az els\u0151ben (nyelvkiv\u00e1laszt\u00f3) \u201eC#\u201d, a harmadikban (projektt\u00edpus kiv\u00e1laszt\u00f3) \u201eConsole\u201d. 3. Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon: Project name: Hello World Location: a laborokban a c:\\work\\ mapp\u00e1ba dolgozzunk, ehhez van \u00edr\u00e1si jogunk. Solution name: Hello World (elvileg ez be is lesz \u00edrva, mire ide\u00e9r\u00fcnk) Place solution and project in the same directory: nincs pipa (de nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge). Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon: Framework: .NET 6 (Long-term support) . A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be (ennek magyar\u00e1zat\u00e1ra mindj\u00e1rt visszat\u00e9r\u00fcnk). A projekttel egy \u00faj solution is l\u00e9trej\u00f6n, mely strukt\u00far\u00e1ja a Visual Studio Solution Explorer ablak\u00e1ban tekinthet\u0151 \u00e1t. Egy solution t\u00f6bb projectb\u0151l \u00e1llhat, egy project pedig t\u00f6bb f\u00e1jlb\u00f3l. A solution a teljes munkak\u00f6rnyezetet fogja \u00f6ssze (egy .sln kiterjeszt\u00e9s\u0171 f\u00e1jl tartozik hozz\u00e1), m\u00edg egy projekt kimenete egy .exe vagy .dll f\u00e1jl jellemz\u0151en, vagyis egy \u00f6sszetett alkalmaz\u00e1s/rendszer egy komponens\u00e9t \u00e1ll\u00edtja el\u0151. A projektf\u00e1jlok kiterjeszt\u00e9se C# alkalmaz\u00e1sok eset\u00e9n .csproj . A Program.cs f\u00e1jlunk tartalma a k\u00f6vetkez\u0151: using System.Text ; namespace HelloWorld { class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); } } } Vegy\u00fcnk fel egy Console.ReadKey() sort: using System.Text ; namespace HelloWorld { class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); Console . ReadKey (); } } } Futtassuk az alkalmaz\u00e1st (pl. az F5 billenty\u0171 haszn\u00e1lat\u00e1val). A k\u00f3d fel\u00e9p\u00edt\u00e9se nagyon hasonl\u00edt a Java-hoz, illetve a C++-hoz. Az oszt\u00e1lyaink n\u00e9vterekbe szervezettek. N\u00e9vtereket hat\u00f3k\u00f6rbe \u201ehozni\u201d a using kulcssz\u00f3val tudjuk. N\u00e9vteret defini\u00e1lni a namespace kulcssz\u00f3val tudunk. Egy konzolos C# alkalmaz\u00e1sban az alkalmaz\u00e1sunk bel\u00e9p\u00e9si pontj\u00e1t egy statikus Main nev\u0171 f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1val adjuk meg. Az oszt\u00e1lyunk neve b\u00e1rmi lehet, a VS egy Program nev\u0171 oszt\u00e1lyt gener\u00e1lt eset\u00fcnkben. A Main f\u00fcggv\u00e9ny param\u00e9terlist\u00e1ja k\u00f6t\u00f6tt: vagy ne adjunk meg param\u00e9tereket, vagy egy string[] -\u00f6t adjunk meg, amiben fut\u00e1s k\u00f6zben megkapjuk az parancssori argumentumokat. .NET-ben a standard ki \u00e9s bemenet kezel\u00e9s\u00e9re a System n\u00e9vt\u00e9r Console oszt\u00e1lya haszn\u00e1land\u00f3. A WriteLine statikus m\u0171velet\u00e9vel egy sort tudunk ki\u00edrni, a ReadKey m\u0171velettel egy billenty\u0171 lenyom\u00e1s\u00e1ra v\u00e1rakozhatunk. Top level statements \u00e9s Implicit usings A projekt l\u00e9trehoz\u00e1sakor kor\u00e1bban bepip\u00e1ltuk a \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet. Ha ezt nem tett\u00fck volna meg, akkor a Program.cs f\u00e1jlunkban mind\u00f6ssze egyetlen \u00e9rdemi sort tal\u00e1ltunk volna: // See https://aka.ms/new-console-template for more information Console . WriteLine ( \"Hello World!\" ); Ez m\u0171k\u00f6d\u00e9s\u00e9ben ekvivalens a fenti Program oszt\u00e1lyt \u00e9s ebben Main f\u00fcggv\u00e9nyt tartalmaz\u00f3 k\u00f3ddal. N\u00e9zz\u00fck, mik teszik ezt lehet\u0151v\u00e9 (ezekr\u0151l pl. itt https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements olvashatunk b\u0151vebben, mindkett\u0151 C# 10 \u00fajdons\u00e1g): Top level statements . Ennek az a l\u00e9nyege, hogy mindenf\u00e9le oszt\u00e1ly/Main \u00e9s egy\u00e9b f\u00fcggv\u00e9nydefin\u00edci\u00f3 n\u00e9lk\u00fcl a projektben egyetlen forr\u00e1sf\u00e1jlban k\u00f6zvetlen\u00fcl is \u00edrhatunk k\u00f3dot. Ez esetben ezt a sz\u00ednfalak m\u00f6g\u00f6tt a ford\u00edt\u00f3 berakja egy \u00e1ltalunk nem l\u00e1that\u00f3 oszt\u00e1ly statikus Main f\u00fcggv\u00e9ny\u00e9be. A bevezet\u00e9s\u00e9nek a motiv\u00e1ci\u00f3ja az volt, hogy a nagyon egyszer\u0171, \u201escript\u201d szer\u0171 alkalmaz\u00e1sok eset\u00e9n kevesebb legyen a boilerplate k\u00f3d. Implicit global usings . Annak f\u00fcggv\u00e9ny\u00e9ben, hogy pontosan milyen projektt\u00edpust hoztunk l\u00e9tre, bizonyos alapn\u00e9vterek a sz\u00ednfalak m\u00f6g\u00f6tt automatikusan using-olva lesznek minden forr\u00e1sf\u00e1jlban (ehhez a compiler a \u201eglobal using\u201d utas\u00edt\u00e1st haszn\u00e1lja). A l\u00e9nyeg: a fejleszt\u0151knek \u00edgy bizonyos, gyakran haszn\u00e1lt n\u00e9vtereket (pl. System.IO, System.Collections.Generic stb.) nem kell a forr\u00e1sf\u00e1jlonk\u00e9nt using-olni. Inconsistent visibility vagy inconsistent accessibility hiba A f\u00e9l\u00e9v sor\u00e1n a programoz\u00e1si feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n tal\u00e1lkozhatunk \u201einconsistent visibility\u201d-re vagy \u201einconsistent accessibility\u201d-re panaszkod\u00f3 ford\u00edt\u00e1si hiba\u00fczenetekkel. A jelens\u00e9g h\u00e1tter\u00e9ben az \u00e1ll, hogy .NET k\u00f6rnyezetben lehet\u0151s\u00e9g van az egyes t\u00edpusok (oszt\u00e1ly, interf\u00e9sz, stb.) l\u00e1that\u00f3s\u00e1g\u00e1nak szab\u00e1lyoz\u00e1s\u00e1ra: internal vagy nem adjuk meg a l\u00e1that\u00f3s\u00e1got: a t\u00edpus csak az adott szerelv\u00e9nyen (.exe, .dll)/projekten, bel\u00fcl l\u00e1that\u00f3 public : a t\u00edpus m\u00e1s szerelv\u00e9nyek/projektek sz\u00e1m\u00e1ra is l\u00e1that\u00f3 A hiba legegyszer\u0171bben \u00fagy h\u00e1r\u00edthat\u00f3 el, ha minden t\u00edpusunkat publikusnak defini\u00e1ljuk, pl.: public class HardDisk { \u2026 } Elm\u00e9leti \u00e1ttekint\u00e9s \u00b6 Az alfejezetek nem tartalmaznak feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismertetik a kapcsol\u00f3d\u00f3 elm\u00e9leti t\u00e9mak\u00f6r\u00f6ket, p\u00e9ld\u00e1kkal illusztr\u00e1lva. A) Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete [hallgat\u00f3]* \u00b6 Az anyag itt el\u00e9rhet\u0151: Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolata . Ez a t\u00e9mak\u00f6r kor\u00e1bbi f\u00e9l\u00e9vben a Szoftvertechnol\u00f3gia t\u00e1rgy keret\u00e9ben ker\u00fclt ismertet\u00e9sre. B) Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly [hallgat\u00f3]* \u00b6 Az anyag itt el\u00e9rhet\u0151: Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly . T\u00e9mak\u00f6r\u00f6k: Absztrakt oszt\u00e1ly fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven Interf\u00e9sz fogalma \u00e9s defini\u00e1l\u00e1sa C# nyel Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa 2. Feladat - Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se \u00b6 Feladat: Egy sz\u00e1m\u00edt\u00f3g\u00e9palkatr\u00e9sz nyilv\u00e1ntart\u00f3 alkalmaz\u00e1s kifejleszt\u00e9s\u00e9vel b\u00edztak meg benn\u00fcnket. B\u0151vebben: K\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00fa alkatr\u00e9szeket kell tudni kezelni. Kezdetben a HardDisk , SoundCard \u00e9s LedDisplay t\u00edpusokat kell t\u00e1mogatni, de a rendszer legyen k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00faj t\u00edpusokkal. Az alkatr\u00e9szekhez tartoz\u00f3 adatok: beszerz\u00e9s \u00e9ve, \u00e9letkora (sz\u00e1m\u00edtott), beszerz\u00e9si \u00e1ra \u00e9s aktu\u00e1lis \u00e1ra (sz\u00e1m\u00edtott), de ezeken fel\u00fcl t\u00edpusf\u00fcgg\u0151 adatokat is tartalmazhatnak (pl. a HardDisk eset\u00e9ben a kapacit\u00e1s). Az aktu\u00e1lis \u00e1r f\u00fcgg az alkatr\u00e9sz t\u00edpus\u00e1t\u00f3l, a beszerz\u00e9si \u00e1rt\u00f3l \u00e9s az alkatr\u00e9sz gy\u00e1rt\u00e1si \u00e9v\u00e9t\u0151l. Pl. min\u00e9l \u00f6regebb egy alkatr\u00e9sz, ann\u00e1l nagyobb kedvezm\u00e9nyt adunk r\u00e1, de a kedvezm\u00e9ny m\u00e9rt\u00e9ke f\u00fcgg az alkatr\u00e9sz t\u00edpust\u00f3l is. List\u00e1zni kell tudni a k\u00e9szleten lev\u0151 alkatr\u00e9szeket. A LedDisplay oszt\u00e1lynak k\u00f6telez\u0151en egy DisplayBase oszt\u00e1lyb\u00f3l kell sz\u00e1rmaznia, \u00e9s a DisplayBase oszt\u00e1ly forr\u00e1sk\u00f3dja nem megv\u00e1ltoztathat\u00f3. Jelen p\u00e9ld\u00e1ban ennek nincs sok \u00e9rtelme, a gyakorlatban azonban gyakran tal\u00e1lkozunk hasonl\u00f3 helyzettel, amikor is az \u00e1ltalunk haszn\u00e1lt keretrendszer/platform el\u0151\u00edrja, hogy adott esetben egy-egy be\u00e9p\u00edtett oszt\u00e1lyb\u00f3l kell sz\u00e1rmaztassunk. Tipikusan ez a helyzet, amikor ablakokkal, \u0171rlapokkal, saj\u00e1t vez\u00e9rl\u0151t\u00edpusokkal dolgozunk: ezeket a keretrendszer be\u00e9p\u00edtett oszt\u00e1lyaib\u00f3l kell sz\u00e1rmaztatnunk, \u00e9s a keretrendszer - pl. Java, .NET - forr\u00e1sk\u00f3dja nem \u00e1ll rendelkez\u00e9s\u00fcnkre (de legal\u00e1bbis biztosan nem akarjuk megv\u00e1ltoztatni). A p\u00e9ld\u00e1nkban a DisplayBase -b\u0151l val\u00f3 sz\u00e1rmaztat\u00e1s el\u0151\u00edr\u00e1s\u00e1val ezt a helyzetet szimul\u00e1ljuk. A megval\u00f3s\u00edt\u00e1s sor\u00e1n jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9l\u00fcnk: az alkatr\u00e9szeket csak mem\u00f3ri\u00e1ban tarjuk nyilv\u00e1n, a list\u00e1z\u00e1s is a lehet\u0151 legegyszer\u0171bb, egyszer\u0171en csak ki\u00edrjuk a nyilv\u00e1ntartott alkatr\u00e9szek adatait a konzolra. A kezdeti egyeztet\u00e9sek sor\u00e1n a megrendel\u0151nkt\u0151l a k\u00f6vetkez\u0151 inform\u00e1ci\u00f3t kapjuk: egy bels\u0151 munkat\u00e1rsuk m\u00e1r elindult a fejleszt\u00e9ssel, de id\u0151 hi\u00e1ny\u00e1ban csak f\u00e9lk\u00e9sz megold\u00e1sig jutott. A feladatunk r\u00e9sz\u00e9t k\u00e9pezi a f\u00e9lk\u00e9sz megold\u00e1s megismer\u00e9se, illetve ebb\u0151l kiindulva kell a feladatot megval\u00f3s\u00edtani. Nyissuk meg a megrendel\u0151nkt\u0151l kapott forr\u00e1sk\u00f3d solution-j\u00e9t (EquipmentP\u00e9lda \u2013 Kiindul\u00e1s mappa) Visual Studio alatt (EquipmentInventory.sln). A Solution Explorerben szemmel fussuk \u00e1t a f\u00e1jlokat. Az meg\u00e9rt\u00e9st seg\u00edten\u00e9, ha egy oszt\u00e1lydiagramon megjelen\u00edten\u00e9nk az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatokat. Vegy\u00fcnk is fel egy oszt\u00e1lydiagramot a projekt\u00fcnkbe. A Solution Explorerben a projekten (\u00e9s nem a solution-\u00f6n!) jobb gombbal kattintva a felugr\u00f3 men\u00fcben az Add/New Item \u2026 elemet v\u00e1lasztva, majd a megjelen\u0151 ablakban a Class Diagram elemet v\u00e1lasszuk ki, az ablak alj\u00e1n a diagram nev\u00e9nek a Main.cd-t adjuk meg, \u00e9s OK-zuk le az ablakot. Note Megjegyz\u00e9s: ha a Class Diagram elem nem jelenik meg a list\u00e1ban, akkor nincs telep\u00edtve a VS megfelel\u0151 komponense. Err\u0151l jelen dokumentum El\u0151felt\u00e9telek fejezet\u00e9ben olvashatsz b\u0151vebben. Ekkor a Solution Explorerben megjelenik a Main.cd diagramf\u00e1jl, duplakattint\u00e1ssal nyissuk meg. A diagramunk jelenleg \u00fcres. A Solution Explorerb\u0151l drag&drop-pal dobjuk r\u00e1 a .cs forr\u00e1sf\u00e1jlokat a diagramra. Ekkor a VS megn\u00e9zi, milyen oszt\u00e1lyok vannak ezekben a forr\u00e1sf\u00e1jlokban, \u00e9s visszafejti \u0151ket UML oszt\u00e1lyokk\u00e1. Alak\u00edtsuk ki a k\u00f6vetkez\u0151 \u00e1br\u00e1nak megfelel\u0151 elrendez\u00e9st (az oszt\u00e1lyok tagjainak megjelen\u00edt\u00e9s\u00e9t a t\u00e9glalapuk jobb fels\u0151 sark\u00e1ban lev\u0151 duplany\u00edlra kattint\u00e1ssal \u00e9rhetj\u00fck el): Az oszt\u00e1lyokhoz tartoz\u00f3 forr\u00e1sk\u00f3dot is megn\u00e9zhetj\u00fck, ak\u00e1r a diagramon a megfelel\u0151 oszt\u00e1lyra dupl\u00e1n kattintva, ak\u00e1r a Solution Explorerb\u0151l a .cs f\u00e1jlokat megnyitva. A k\u00f6vetkez\u0151ket tapasztaljuk: A SoundCard , HardDisk \u00e9s LedDisplay oszt\u00e1lyok viszonylag j\u00f3l kidolgozottak, rendelkeznek a sz\u00fcks\u00e9ges attrib\u00fatumokkal \u00e9s lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyekkel. Az LedDisplay a k\u00f6vetelm\u00e9nyeknek megfelel\u0151en a DisplayBase oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Az EquipmentInventory felel\u0151s ugyan a k\u00e9szleten lev\u0151 alkatr\u00e9szek nyilv\u00e1ntart\u00e1s\u00e1\u00e9rt, de gyakorlatilag semmi nincs ebb\u0151l megval\u00f3s\u00edtva. Tal\u00e1lunk egy IEquipment interf\u00e9szt, GetAge \u00e9s GetPrice m\u0171veletekkel \u00c1lljunk neki a megold\u00e1s kidolgoz\u00e1s\u00e1nak. El\u0151sz\u00f6r is az alapkoncepci\u00f3kat fektess\u00fck le. Az EquipmentInventory oszt\u00e1lyban egy heterog\u00e9n kollekci\u00f3ban t\u00e1roljuk a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusokat. Ez a kulcsa az alkatr\u00e9szek egys\u00e9ges kezel\u00e9s\u00e9nek, vagyis annak, hogy a megold\u00e1sunk \u00faj alkatr\u00e9szt\u00edpusokkal k\u00f6nnyen b\u0151v\u00edthet\u0151 legyen. Mint kor\u00e1bban taglaltuk, az egys\u00e9ges kezel\u00e9st vagy k\u00f6z\u00f6s \u0151soszt\u00e1ly, vagy k\u00f6z\u00f6s interf\u00e9sz bevezet\u00e9s\u00e9vel lehet megoldani. Eset\u00fcnkben a k\u00f6z\u00f6s \u0151soszt\u00e1ly (pl. EquipmentBase ) \u00fagy t\u0171nik, kiesik, mert ennek bevezet\u00e9s\u00e9vel az LedDisplay oszt\u00e1lynak k\u00e9t \u0151soszt\u00e1lya is lenne: a k\u00f6telez\u0151nek kik\u00f6t\u00f6tt DisplayBase , \u00e9s az \u00e1ltalunk az egys\u00e9ges kezel\u00e9sre bevezetett EquipmentBase . Ez nem lehets\u00e9ges, .NET k\u00f6rnyezetben egy oszt\u00e1lynak csak egy \u0151se lehet. Az a megold\u00e1s pedig, hogy a DisplayBase -t \u00fagy m\u00f3dos\u00edtjuk, hogy \u0151 is az EquipmentBase -b\u0151l sz\u00e1rmazik, a k\u00f6vetelm\u00e9ny\u00fcnknek megfelel\u0151en nem lehets\u00e9ges (kik\u00f6t\u00e9s volt, hogy a forr\u00e1sk\u00f3dja nem m\u00f3dos\u00edthat\u00f3). Marad teh\u00e1t az interf\u00e9sz alap\u00fa megk\u00f6zel\u00edt\u00e9s. Minden bizonnyal az alkalmaz\u00e1s kor\u00e1bbi fejleszt\u0151je is erre a k\u00f6vetkeztet\u00e9sre jutott, ez\u00e9rt is vezette be az IEquipment interf\u00e9szt. Vegy\u00fcnk fel egy IEquipment t\u00edpus\u00fa elemekb\u0151l \u00e1ll\u00f3 generikus list\u00e1t (ne property-t hanem field-et!) az EquipmentInventory oszt\u00e1lyba. A l\u00e1that\u00f3s\u00e1ga \u2013 az egys\u00e9gbez\u00e1r\u00e1sra t\u00f6rekedve \u2013 legyen private. A neve legyen equipment (ne legyen \u201es\u201d a v\u00e9g\u00e9n, angolban az equipment t\u00f6bbes sz\u00e1ma is equipment). A tagv\u00e1ltoz\u00f3 felv\u00e9tel\u00e9hez a Visual Studio Class Details ablak\u00e1t haszn\u00e1ljuk. Ha az ablak nem l\u00e1that\u00f3, a View/Other Windows/Class Details men\u00fc kiv\u00e1laszt\u00e1s\u00e1val jelen\u00edthet\u0151 meg. A tagv\u00e1ltoz\u00f3 t\u00edpusa teh\u00e1t List<IEquipment> . A .NET List t\u00edpusa egy dinamikusan ny\u00fajt\u00f3zkod\u00f3 generikus t\u00f6mb (mint Java-ban az ArrayList ). A diagramon az EquipmentInventory oszt\u00e1lyra pillantva azt l\u00e1tjuk, hogy csak a tagv\u00e1ltoz\u00f3 neve jelenik meg, a t\u00edpusa nem. A diagram h\u00e1tter\u00e9n jobb gombbal kattintva a Change Members Format men\u00fcb\u0151l a Display Full Signature -t v\u00e1lasszuk ki. Ezt k\u00f6vet\u0151en a diagramon l\u00e1that\u00f3v\u00e1 v\u00e1lik a tagv\u00e1ltoz\u00f3k t\u00edpusa, valamint a m\u0171veletek teljes szignat\u00far\u00e1ja. Az EquipmentInventory oszt\u00e1lyon dupl\u00e1n kattintva elnavig\u00e1lhatunk a forr\u00e1sk\u00f3dba, \u00e9s mint l\u00e1that\u00f3, val\u00f3ban egy lista t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k\u00e9nt jelenik meg a k\u00f3dban: class EquipmentInventory { private List < IEquipment > equipment ; Ennek egyr\u00e9szt \u00f6r\u00fcl\u00fcnk, mert a Visual Studio t\u00e1mogatja a round-trip engineering technik\u00e1t: a modellt \u00e9rint\u0151 v\u00e1ltoz\u00e1sokat azonnal \u00e1tvezeti a k\u00f3dba, \u00e9s viszont . M\u00e1sr\u00e9szt a kor\u00e1bbiakban azt taglaltuk, hogy ha egy oszt\u00e1lyban egy gy\u0171jtem\u00e9ny tag van egy m\u00e1sik oszt\u00e1ly elemeib\u0151l, akkor annak az UML modellben egy 1-t\u00f6bb t\u00edpus\u00fa asszoci\u00e1ci\u00f3s kapcsolatk\u00e9nt \u201eillik\u201d megjelennie a k\u00e9t oszt\u00e1ly k\u00f6z\u00f6tt. A modell\u00fcnkben egyel\u0151re nem ezt tapasztaljuk. Szerencs\u00e9re a VS modellez\u0151 fel\u00fclete r\u00e1vehet\u0151, hogy ilyen form\u00e1ban jelen\u00edtse meg ezt a kapcsolatt\u00edpust. Ehhez kattintsunk a diagramon jobb gombbal az equipment tagv\u00e1ltoz\u00f3n, \u00e9s a men\u00fcb\u0151l v\u00e1lasszuk ki a Show as Collection Association elemet. Az IEquipment oszt\u00e1lyt ezt k\u00f6vet\u0151en mozgassuk ki jobbra, hogy kell\u0151 hely legyen a diagramon az asszoci\u00e1ci\u00f3s kapcsolat \u00e9s a kapcsolaton lev\u0151 szerep (role) adatainak megjelen\u00edt\u00e9s\u00e9re: A dupla ny\u00edl v\u00e9gz\u0151d\u00e9s a \u201et\u00f6bbes\u201d oldalon nem szabv\u00e1nyos UML, de ne szomorodjunk el t\u0151le k\u00fcl\u00f6n\u00f6sebben, nincs semmi jelent\u0151s\u00e9ge. Annak mindenk\u00e9ppen \u00f6r\u00fcl\u00fcnk, hogy a kapcsolatot reprezent\u00e1l\u00f3 ny\u00edl az IEquipment v\u00e9g\u00e9n a szerepben a tagv\u00e1ltoz\u00f3 neve (s\u0151t, m\u00e9g a pontos t\u00edpusa is) fel van t\u00fcntetve. Navig\u00e1ljunk el az EquipmentInventory forr\u00e1sk\u00f3dj\u00e1hoz, \u00e9s \u00edrjuk meg a konstruktor\u00e1t, ami inicializ\u00e1lja az equipment gy\u0171jtem\u00e9nyt! public EquipmentInventory () { equipment = new List < IEquipment >(); } Ezut\u00e1n \u00edrjuk meg a ListAll met\u00f3dust, ami ki\u00edrja az elemek \u00e9letkor\u00e1t, \u00e9s az aktu\u00e1lis \u00e9rt\u00e9k\u00fcket: public void ListAll () { foreach ( IEquipment eq in equipment ) { Console . WriteLine ( $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\" ); } } Az elemeken a foreach utas\u00edt\u00e1ssal iter\u00e1lunk v\u00e9gig. A foreach utas\u00edt\u00e1s haszn\u00e1lata sor\u00e1n az in kulcssz\u00f3 ut\u00e1n egy gy\u0171jtem\u00e9nynek kell \u00e1llnia, az in el\u0151tt pedig egy v\u00e1ltoz\u00f3 deklar\u00e1ci\u00f3nak (eset\u00fcnkben IEquipment eq), ahol a t\u00edpus a gy\u0171jtem\u00e9ny elemt\u00edpusa. Minden iter\u00e1ci\u00f3ban ez a v\u00e1ltoz\u00f3 a gy\u0171jtem\u00e9ny iter\u00e1ci\u00f3beli \u00e9rt\u00e9k\u00e9t veszi fel. A Console.WriteLine m\u0171veletnek vagy egy egyszer\u0171 stringet adunk meg, vagy, mint eset\u00fcnkben, egy form\u00e1z\u00e1si stringet. A behelyettes\u00edt\u00e9seket string interpol\u00e1ci\u00f3val oldottuk meg: a behelyettes\u00edtend\u0151 \u00e9rt\u00e9keket {} k\u00f6z\u00f6tt kell megadni. Ha string interpol\u00e1ci\u00f3t haszn\u00e1lunk, a stringnek $ jellel kell kezd\u0151dnie. \u00cdrjunk meg egy AddEquipment nev\u0171 f\u00fcggv\u00e9nyt, ami felvesz egy \u00faj eszk\u00f6zt a k\u00e9szletbe: public void AddEquipment ( IEquipment eq ) { equipment . Add ( eq ); } Kor\u00e1bbi d\u00f6nt\u00e9s\u00fcnk \u00e9rtelm\u00e9ben az IEquipment interf\u00e9szt haszn\u00e1ljuk az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusok egys\u00e9ges kezel\u00e9s\u00e9re. Est\u00fcnkben mind a SoundCard, mind a HardDisk oszt\u00e1ly rendelkezik GetAge() \u00e9s GetPrice() met\u00f3dussal, m\u00e9gsem tudjuk \u0151ket egys\u00e9gesen kezelni (pl. k\u00f6z\u00f6s list\u00e1ban t\u00e1rolni). Ahhoz, hogy ezt meg tudjuk tenni, el kell \u00e9rn\u00fcnk, hogy mindk\u00e9t oszt\u00e1ly megval\u00f3s\u00edtsa az IEquipment interf\u00e9szt. M\u00f3dos\u00edtsuk a forr\u00e1sukat: public class SoundCard : IEquipment { ... public class HardDisk : IEquipment { ... Ezt k\u00f6vet\u0151en a SoundCard \u00e9s HardDisk oszt\u00e1lyban implement\u00e1lnunk kell az IEquipment interf\u00e9szben lev\u0151 met\u00f3dusokat. Azt tapasztaljuk, hogy ezzel nincs most teend\u0151k, a GetPrice \u00e9s GetAge f\u00fcggv\u00e9nyek m\u00e1r meg vannak \u00edrva mindk\u00e9t helyen. Pr\u00f3bak\u00e9ppen a Program.cs f\u00e1jlban tal\u00e1lhat\u00f3 Main f\u00fcggv\u00e9ny\u00fcnkben hozzunk l\u00e9tre egy EquipmentInventory objektumot, t\u00f6lts\u00fck fel HardDisk \u00e9s SoundCard objektumokkal, majd list\u00e1zzuk a k\u00e9sztelet a konzolra. Ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra! static void Main ( string [] args ) { EquipmentInventory ei = new EquipmentInventory (); ei . AddEquipment ( new HardDisk ( 2021 , 30000 , 80 )); ei . AddEquipment ( new HardDisk ( 2020 , 25000 , 120 )); ei . AddEquipment ( new HardDisk ( 2020 , 25000 , 250 )); ei . AddEquipment ( new SoundCard ( 2021 , 8000 )); ei . AddEquipment ( new SoundCard ( 2020 , 7000 )); ei . AddEquipment ( new SoundCard ( 2020 , 6000 )); ei . ListAll (); Console . ReadKey (); } Az alkalmaz\u00e1st futtatva azt tapasztaljuk, hogy b\u00e1r megold\u00e1sunk kezdetleges, de m\u0171k\u00f6dik: Folytassuk a munk\u00e1t a LedDisplay oszt\u00e1llyal. A DisplayBase \u0151s forr\u00e1sk\u00f3dj\u00e1t a k\u00f6vetelm\u00e9nyek miatt nem m\u00f3dos\u00edthatjuk. De ez semmif\u00e9le probl\u00e9m\u00e1t nem okoz, a LedDisplay oszt\u00e1lyunk fogja az IEquipment interf\u00e9szt implement\u00e1lni, m\u00f3dos\u00edtsuk a k\u00f3dot ennek megfelel\u0151en: public class LedDisplay : DisplayBase , IEquipment A LedDisplay oszt\u00e1lyban m\u00e1r meg kell \u00edrni az interf\u00e9szben szerepl\u0151 f\u00fcggv\u00e9nyeket: public double GetPrice () { return this . price ; } public int GetAge () { return DateTime . Today . Year - this . manufacturingYear ; } B\u0151v\u00edts\u00fck a Main f\u00fcggv\u00e9ny\u00fcnket is, vegy\u00fcnk fel k\u00e9t LedDisplay objektumot a k\u00e9szlet\u00fcnkbe (itt is \u00e9l, hogy ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra! ei . AddEquipment ( new LedDisplay ( 2020 , 80000 , 17 , 16 ) ); ei . AddEquipment ( new LedDisplay ( 2021 , 70000 , 17 , 12 ) ); ei . ListAll (); Console . ReadKey (); Tesztel\u00e9sk\u00e9ppen futtassuk az alkalmaz\u00e1st. 3. Feladat - Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja \u00b6 \u00c9rt\u00e9kelj\u00fck a jelenlegi, interf\u00e9sz alap\u00fa megold\u00e1sunkat. Az egyik f\u0151 probl\u00e9ma, hogy k\u00f3dunk tele van a karbantarthat\u00f3s\u00e1got \u00e9s b\u0151v\u00edthet\u0151s\u00e9get rombol\u00f3 k\u00f3dduplik\u00e1ci\u00f3val: A yearOfCreation \u00e9s newPrice tagok minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis LedDisplay -t) k\u00f6z\u00f6sek, ezeket \u00faj t\u00edpus bevezet\u00e9sekor is copy-paste technik\u00e1val \u00e1t kell venni. A GetAge f\u00fcggv\u00e9ny implement\u00e1ci\u00f3ja szinten minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis LedDisplay -t) azonos, szint\u00e9n copy-paste-tel \u201eszapor\u00edtand\u00f3\u201d. A konstruktorok yearOfCreation \u00e9s newPrice tagokat inicializ\u00e1l\u00f3 sorai szint\u00e9n duplik\u00e1ltak az egyes oszt\u00e1lyokban. B\u00e1r ez a k\u00f3dduplik\u00e1ci\u00f3 egyel\u0151re nem t\u0171nik jelent\u0151snek, \u00faj alkatr\u00e9sz t\u00edpusok bevezet\u00e9s\u00e9vel egyre ink\u00e1bb elm\u00e9rgesedik a helyzet, jobb id\u0151ben elej\u00e9t venni a j\u00f6v\u0151beli f\u00e1jdalmaknak. A m\u00e1sik probl\u00e9ma abb\u00f3l ad\u00f3dik, hogy az alkatr\u00e9sz adatok list\u00e1z\u00e1sa jelenleg f\u00e1jdalmasan hi\u00e1nyos, nem jelenik meg az alkatr\u00e9sz t\u00edpusa (csak a kora \u00e9s az \u00e1ra). A t\u00edpus megjelen\u00edt\u00e9s\u00e9hez az IEquipment interf\u00e9szt b\u0151v\u00edteni kell, pl. egy GetDescription nev\u0171 m\u0171velet bevezet\u00e9s\u00e9vel. Vegy\u00fcnk is fel egy GetDescription f\u00fcggv\u00e9nyt az interf\u00e9szbe! public interface IEquipment { double GetPrice (); int GetAge (); string GetDescription (); } Ekkor minden IEquipment interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban meg kellene val\u00f3s\u00edtani ezt a met\u00f3dust is, ami sok oszt\u00e1ly eset\u00e9n sok munka (valamint egy t\u00f6bbkomponens\u0171, vagyis t\u00f6bb DLL-b\u0151l \u00e1ll\u00f3 alkalmaz\u00e1s eset\u00e9ben, amikor ezek nem egy fejleszt\u0151 c\u00e9g kez\u00e9ben vannak, sokszor nem is megoldhat\u00f3). A build parancs futtat\u00e1s\u00e1val ellen\u0151rizz\u00fck, hogy a GetDescription felv\u00e9tele ut\u00e1n h\u00e1rom helyen is ford\u00edt\u00e1si hib\u00e1t kapunk. Interf\u00e9szben alap\u00e9rtelmezett implement\u00e1ci\u00f3 megad\u00e1sa \u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja . B\u0151vebben inform\u00e1ci\u00f3 itt: default interface methods . public interface IEquipment { double GetPrice (); int GetAge (); string GetDescription () { return \"EquipmentBase\" ; } } Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelent egy k\u00f6z\u00f6s absztrakt \u0151s bevezet\u00e9se (kiv\u00e9ve az LedDiplay oszt\u00e1lyt, amire m\u00e9g visszat\u00e9r\u00fcnk). Ebbe fel tudjuk k\u00f6lt\u00f6ztetni a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot, valamint az \u00fajonnan bevezetett GetDescription m\u0171velethez egy alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni. Legyen az \u00faj absztrakt \u0151soszt\u00e1lyunk neve EquipmentBase . K\u00e9rd\u00e9s, sz\u00fcks\u00e9g van-e a tov\u00e1bbiakban az IEquipment interf\u00e9szre, vagy az teljesen kiv\u00e1lthat\u00f3 az \u00faj EquipmentBase oszt\u00e1llyal. Az IEquipment interf\u00e9szt meg kell tartsuk, mert a LedDisplay oszt\u00e1lyunkat nem tudjuk az EquipmentBase -b\u0151l sz\u00e1rmaztatni: m\u00e1r van egy k\u00f6telez\u0151en el\u0151\u00edrt \u0151soszt\u00e1lya, a DisplayBase : emiatt az EquipmentInventory a tov\u00e1bbfejlesztett megold\u00e1sunkban is IEquipment interf\u00e9szk\u00e9nt hivatkozik az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szekre. \u00c1lljunk is neki az \u00e1talak\u00edt\u00e1snak. Legyen az oszt\u00e1lydiagramunk az akt\u00edv tabf\u00fcl. A Toolbox-b\u00f3l drag&drop-pal dobjunk fel egy Abstract Class elemet a diagramra, a neve legyen EquipmentBase . A k\u00f6vetkez\u0151kben azt kell el\u00e9rj\u00fck, hogy a SoundCard \u00e9s a HardDisk oszt\u00e1lyok sz\u00e1rmazzanak az EquipmentBase -b\u0151l (a LedDisplay -nek m\u00e1r van m\u00e1sik \u0151se, \u00edgy ott ezt nem tudjuk megtenni). Ehhez v\u00e1lasszuk ki az Inheritance kapcsolatot a Toolbox-ban, majd h\u00fazzunk egy-egy vonalat a gyermekoszt\u00e1lyb\u00f3l kiindulva az \u0151soszt\u00e1lyba a SoundCard \u00e9s HardDisk eset\u00e9ben egyar\u00e1nt. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben alak\u00edtsuk \u00e1t \u00fagy a k\u00f3dot, hogy ne a HardDisk \u00e9s SoundCard val\u00f3s\u00edts\u00e1k meg k\u00fcl\u00f6n-k\u00fcl\u00f6n az IEquipment interf\u00e9szt, hanem a k\u00f6z\u00f6s \u0151s\u00fck, az EquipmentBase egyszer. Ehhez m\u00f3dos\u00edtsuk az EquipmentBase oszt\u00e1lyt \u00fagy, hogy val\u00f3s\u00edtsa meg az interf\u00e9szt (ak\u00e1r a diagramon h\u00fazzunk be egy inheritance kapcsolatot az EquipmentBase -b\u0151l az IEquipment -be, vagy az EquipmentBase forr\u00e1sk\u00f3dj\u00e1t m\u00f3dos\u00edtsuk). A HardDisk \u00e9s SoundCard oszt\u00e1lyokb\u00f3l t\u00f6r\u00f6lj\u00fck az IEquipment megval\u00f3s\u00edt\u00e1s\u00e1t (az \u0151s m\u00e1r implement\u00e1lja). A diagramunk \u00e9s a forr\u00e1sk\u00f3dunk vonatkoz\u00f3 r\u00e9szei ezt k\u00f6vet\u0151en \u00edgy n\u00e9znek ki: public abstract class EquipmentBase : IEquipment { } public class HardDisk : EquipmentBase { \u2026 public class SoundCard : EquipmentBase { \u2026 A k\u00f3dunk m\u00e9g nem fordul, ennek t\u00f6bb oka is van. Az EquipmentBase implement\u00e1lja az IEquipment interf\u00e9szt, de m\u00e9g nincsenek benne implement\u00e1lva az interf\u00e9sz m\u0171veletei. Vagy gener\u00e1ltassuk le a met\u00f3dusokat a smart tag haszn\u00e1lat\u00e1val, vagy g\u00e9pelj\u00fck be a k\u00f6vetkez\u0151 elveknek megfelel\u0151en: A newPrice \u00e9s earOfCreation duplik\u00e1lva vannak a HardDisk \u00e9s SoundCard oszt\u00e1lyokban: mozgassuk (\u00e9s ne m\u00e1soljuk!) \u00e1t ezeket a k\u00f6z\u00f6s EquipmentBase \u0151sbe, \u00e9s protected l\u00e1that\u00f3s\u00e1got adjunk meg. A GetAge m\u0171velet duplik\u00e1lva van a HardDisk \u00e9s SoundCard oszt\u00e1lyokban, ezekb\u0151l t\u00f6r\u00f6lj\u00fck ki az implement\u00e1ci\u00f3t \u00e9s vigy\u00fck \u00e1t az EquipmentBase oszt\u00e1lyba. A GetPrice m\u0171veletet absztrakt m\u0171veletk\u00e9nt vegy\u00fck fel az \u0151sbe. Ez sz\u00e1nd\u00e9kos tervez\u0151i d\u00f6nt\u00e9s, \u00edgy r\u00e1k\u00e9nyszer\u00edtj\u00fck a lesz\u00e1rmazott oszt\u00e1lyokat, hogy mindenk\u00e9ppen defini\u00e1lj\u00e1k fel\u00fcl ezt a m\u0171veletet. A GetDescription eset\u00e9ben viszont pont ford\u00edtottja a helyzet: ezt virtu\u00e1lisnak defini\u00e1ljuk (\u00e9s nem absztraktnak), vagyis m\u00e1r az \u0151sben is adunk meg implement\u00e1ci\u00f3t. \u00cdgy a lesz\u00e1rmazottak nincsenek r\u00e1k\u00e9nyszer\u00edtve a m\u0171velet fel\u00fcldefini\u00e1l\u00e1s\u00e1ra. A fentieknek megfelel\u0151 k\u00f3d a k\u00f6vetkez\u0151: public abstract class EquipmentBase : IEquipment { protected int yearOfCreation ; protected int newPrice ; public int GetAge () { return DateTime . Today . Year - yearOfCreation ; } public abstract double GetPrice (); public virtual string GetDescription () { return \"EquipmentBase\" ; } } N\u00e9h\u00e1ny kieg\u00e9sz\u00edt\u0151 gondolat a k\u00f3dr\u00e9szletre vonatkoz\u00f3an: Az absztrakt oszt\u00e1lyok eset\u00e9ben az abstract kulcssz\u00f3t ki kell \u00edrni a class sz\u00f3 el\u00e9. Az absztrakt m\u0171veletek eset\u00e9ben az abstract kulcssz\u00f3t kell megadni .NET k\u00f6rnyezetben lehet\u0151s\u00e9g\u00fcnk van szab\u00e1lyozni, hogy egy m\u0171velet virtu\u00e1lis-e vagy sem. Ebb\u0151l a szempontb\u00f3l a C++ nyelvhez hasonl\u00edt. Amennyiben egy m\u0171veletet virtu\u00e1liss\u00e1 szeretn\u00e9nk tenni, a virtual kulcssz\u00f3t kell a m\u0171veletre megadni. Eml\u00e9keztet\u0151: akkor defini\u00e1ljunk egy m\u0171veletet virtu\u00e1lisnak, ha a lesz\u00e1rmazottak azt fel\u00fcldefini\u00e1l(hat)j\u00e1k. Csak ekkor garant\u00e1lt, hogy egy \u0151sreferenci\u00e1n megh\u00edvva az adott m\u0171veletet a lesz\u00e1rmazottbeli verzi\u00f3 h\u00edv\u00f3dik meg. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t az EquipmentBase lesz\u00e1rmazottakra. C# nyelven az absztrakt \u00e9s virtu\u00e1lis m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor a lesz\u00e1rmazottban meg kell adni az override kulcssz\u00f3t. Els\u0151 l\u00e9p\u00e9sben a GetPrice m\u0171veletet defini\u00e1ljuk fel\u00fcl: public class HardDisk : EquipmentBase { \u2026 public override double GetPrice () { return yearOfCreation < ( DateTime . Today . Year - 4 ) ? 0 : newPrice - ( DateTime . Today . Year - yearOfCreation ) * 5000 ; } } public class SoundCard : EquipmentBase { \u2026 public override double GetPrice () { return yearOfCreation < ( DateTime . Today . Year - 4 ) ? 0 : newPrice - ( DateTime . Today . Year - yearOfCreation ) * 2000 ; } } A k\u00f6vetkez\u0151kben l\u00e9p\u00e9sben a GetDescription m\u0171veletet \u00edrjuk meg a HardDisk \u00e9s SoundCard oszt\u00e1lyokban. Mivel itt az \u0151sbeli virtu\u00e1lis f\u00fcggv\u00e9nyt defini\u00e1ljuk fel\u00fcl, szint\u00e9n meg kell adni az override kulcssz\u00f3t: public class HardDisk : EquipmentBase { \u2026 public override string GetDescription () { return \"HardDisk\" ; } } public class SoundCard : EquipmentBase { \u2026 public override string GetDescription () { return \"SoundCard\" ; } } Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, mi\u00e9rt d\u00f6nt\u00f6ttek \u00fagy a C# nyelv tervez\u0151i, hogy a m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor egy extra kulcssz\u00f3t kelljen megadni, hasonl\u00f3ra pl. a C++ nyelv eset\u00e9ben nem volt sz\u00fcks\u00e9g. Az ok egyszer\u0171: a k\u00f3d \u00edgy kifejez\u0151bb. A lesz\u00e1rmazottak k\u00f3dj\u00e1t n\u00e9zve az override sz\u00f3 azonnal egy\u00e9rtelm\u0171v\u00e9 teszi, hogy valamelyik \u0151sben ez a m\u0171velet absztrakt vagy virtu\u00e1lis, nem kell valamennyi \u0151s k\u00f3dj\u00e1t ehhez \u00e1ttekinteni. A LedDisplay oszt\u00e1lyunk \u0151se meg van k\u00f6tve, annak k\u00f3dja nem m\u00f3dos\u00edthat\u00f3, \u00edgy nem tudjuk az EquipmentBase -b\u0151l sz\u00e1rmaztatni. A GetAge m\u0171veletet \u00edgy nem tudjuk t\u00f6r\u00f6lni, ez a k\u00f3dduplik\u00e1ci\u00f3 itt megmarad (de csak a LedDisplay eset\u00e9ben, ami csak egy oszt\u00e1ly a sok k\u00f6z\u00fcl!). Megjegyz\u00e9s: val\u00f3j\u00e1ban egy kis plusz munk\u00e1val ett\u0151l a duplik\u00e1ci\u00f3t\u00f3l is meg tudn\u00e1nk szabadulni. Ehhez valamelyik oszt\u00e1lyban (pl. EquipmentBase ) fel kellene venni egy statikus seg\u00e9df\u00fcggv\u00e9nyt, mely param\u00e9terben megkapn\u00e1 a gy\u00e1rt\u00e1si \u00e9vet, \u00e9s visszaadn\u00e1 az \u00e9letkort. Az EquipmentBase.GetAge \u00e9s a LedDisplay.GetAge ezt a seg\u00e9df\u00fcggv\u00e9nyt haszn\u00e1ln\u00e1 kimenete el\u0151\u00e1ll\u00edt\u00e1s\u00e1ra. A LedDisplay oszt\u00e1lyunkban ad\u00f3sak vagyunk m\u00e9g a GetDescription meg\u00edr\u00e1s\u00e1val: public class LedDisplay : DisplayBase , IEquipment { \u2026 public string GetDescription () { return \"LedDisplay\" ; } } Figyelj\u00fck meg, hogy itt NEM adtuk meg az override kulcssz\u00f3t. Mikor egy interf\u00e9sz f\u00fcggv\u00e9nyt implement\u00e1lunk, az override-ot nem kell/szabad ki\u00edrni. M\u00f3dos\u00edtsuk az EquipmentInventory.ListAll m\u0171velet\u00e9t, hogy az elemek le\u00edr\u00e1s\u00e1t is \u00edrja ki a kimenetre: public void ListAll () { foreach ( IEquipment eq in equipment ) { Console . WriteLine ( $\"Le\u00edr\u00e1s: {eq.GetDescription()}\\t\" + $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\" ); } } \u00cdgy m\u00e1r sokkal informat\u00edvabb kimetet kapunk az alkalmaz\u00e1s futtat\u00e1sakor: A k\u00f3dunkat \u00e1ttekintve m\u00e9g egy helyen tal\u00e1lunk k\u00f3dduplik\u00e1ci\u00f3t. Valamennyi EquipmentBase lesz\u00e1rmazott ( HardDisk , SoundCard ) konstruktor\u00e1ban ott van ez a k\u00e9t sor: this . yearOfCreation = yearOfCreation ; this . newPrice = newPrice ; Ha belegondolunk, ezek a yearOfCreatio \u00e9s newPrice tagok az \u0151sben vannak defini\u00e1lva, \u00edgy egy\u00e9bk\u00e9nt is az \u0151 felel\u0151ss\u00e9ge kellene legyen ezek inicializ\u00e1l\u00e1sa. Vegy\u00fcnk is fel egy megfelel\u0151 konstruktort az EquipmentBase -ben: public abstract class EquipmentBase : IEquipment { \u2026 public EquipmentBase ( int yearOfCreation , int newPrice ) { this . yearOfCreation = yearOfCreation ; this . newPrice = newPrice ; } \u2026 } A HardDisk \u00e9s SoundCard lesz\u00e1rmazottak konstruktor\u00e1nak t\u00f6rzs\u00e9b\u0151l vegy\u00fck ki a k\u00e9t tag inicializ\u00e1l\u00e1s\u00e1t, helyette a base kulcssz\u00f3val hivatkozva h\u00edvjuk meg az \u0151s konstruktor\u00e1t: public class HardDisk : EquipmentBase { \u2026 public HardDisk ( int yearOfCreation , int newPrice , int capacityGB ): base ( yearOfCreation , newPrice ) { this . capacityGB = capacityGB ; } \u2026 } public class SoundCard : EquipmentBase { \u2026 public SoundCard ( int yearOfCreation , int newPrice ): base ( yearOfCreation , newPrice ) { } \u2026 } \u00c9rt\u00e9kel\u00e9s \u00b6 Az interf\u00e9sz \u00e9s absztrakt \u0151s egy\u00fcttes haszn\u00e1lat\u00e1val siker\u00fclt a legkevesebb kompromisszummal j\u00e1r\u00f3 megold\u00e1st kidolgoznunk: IEquipment interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk kezelni az alkatr\u00e9szek valamennyi t\u00edpus\u00e1t, m\u00e9g azokat is, melyekn\u00e9l az \u0151soszt\u00e1ly meg volt k\u00f6tve (puszt\u00e1n absztrakt \u0151s haszn\u00e1lat\u00e1val ezt nem tudtuk volna el\u00e9rni). Az EquipmentBase absztrakt \u0151s bevezet\u00e9s\u00e9vel egy kiv\u00e9telt\u0151l eltekintve a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szt\u00edpusokra k\u00f6z\u00f6s k\u00f3dot fel tudtuk vinni egy k\u00f6z\u00f6s \u0151sbe, \u00edgy el tudtuk ker\u00fclni a k\u00f3dduplik\u00e1ci\u00f3t. Az EquipmentBase absztrakt \u0151s bevezet\u00e9s\u00e9vel alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni az \u00fajonnan bevezetett IEquipment m\u0171veletek eset\u00e9ben (pl. GetDescripton ), \u00edgy nem vagyunk r\u00e1k\u00e9nyszer\u00edtve, hogy minden IEquipment implement\u00e1ci\u00f3s oszt\u00e1lyban meg kelljen azt adni. Z\u00e1r\u00e1sk\u00e9ppen vess\u00fcnk egy pillant\u00e1st megold\u00e1sunk UML (szer\u0171) oszt\u00e1lydiagramj\u00e1ra: Megjegyz\u00e9s - opcion\u00e1lis h\u00e1zi gyakorl\u00f3 feladat \u00b6 Jelen megold\u00e1sunk nem t\u00e1mogatja az alkatr\u00e9szspecifikus adatok (pl. HardDisk eset\u00e9ben a kapacit\u00e1s) megjelen\u00edt\u00e9s\u00e9t a list\u00e1z\u00e1s sor\u00e1n. Ahhoz, hogy ezt meg tudjuk tenni, az alkatr\u00e9sz adatok form\u00e1zott stringbe \u00edr\u00e1s\u00e1t az EqipmentInventory oszt\u00e1lyb\u00f3l az alkatr\u00e9sz oszt\u00e1lyokba kellene vinni, a k\u00f6vetkez\u0151 elveknek megfelel\u0151en: Bevezethet\u00fcnk ehhez az IEquipment interf\u00e9szbe egy GetFormattedString m\u0171veletet, mely egy string t\u00edpus\u00fa objektummal t\u00e9r vissza. Alternat\u00edv megold\u00e1s lehet, ha a System.Object ToString() m\u0171velet\u00e9t defini\u00e1ljuk fel\u00fcl. .NET-ben ugyanis minden t\u00edpus implicit m\u00f3don a System.Object -b\u0151l sz\u00e1rmazik, aminek van egy virtu\u00e1lis ToString() m\u0171velete. Az EquipmentBase -ben meg\u00edrjuk a k\u00f6z\u00f6s tagok (le\u00edr\u00e1s, \u00e1r, kor) stringbe form\u00e1z\u00e1s\u00e1t. Amennyiben egy alkatr\u00e9sz t\u00edpusspecifikus adattal is rendelkezik, akkor oszt\u00e1ly\u00e1ban override-oljuk a stringbe form\u00e1z\u00f3 f\u00fcggv\u00e9nyt: ennek a f\u00fcggv\u00e9nynek egyr\u00e9szt meg kell h\u00edvnia az \u0151s v\u00e1ltozat\u00e1t (a base kulcssz\u00f3 haszn\u00e1lat\u00e1val), majd ehhez hozz\u00e1 kell f\u0171zni a saj\u00e1t form\u00e1zott adatait, \u00e9s ezzel a stringgel kell visszat\u00e9rnie.","title":"1. A modell \u00e9s a k\u00f3d kapcsolata"},{"location":"labor/1-model-es-kod-kapcsolata/#1-a-modell-es-a-kod-kapcsolata","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n","title":"1. A modell \u00e9s a k\u00f3d kapcsolata"},{"location":"labor/1-model-es-kod-kapcsolata/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja: Ismerked\u00e9s a hallgat\u00f3kkal/gyakorlatvezet\u0151vel A gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyek pontos\u00edt\u00e1sa Elindul\u00e1s Visual Studio-val \u00e9s .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9vel. Egy egyszer\u0171 Hello World .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja Gyakorlatvezet\u0151knek A hallgat\u00f3k kor\u00e1bbi tanulm\u00e1nyaik sor\u00e1n C++ gyakorlaton m\u00e1r haszn\u00e1lt\u00e1k a Visual Studio k\u00f6rnyezet, \u00edgy a c\u00e9l jelen esetben az ismeretek feleleven\u00edt\u00e9se \u00e9s \u00e9let\u00fcnk els\u0151 C# alkalmaz\u00e1s\u00e1nak elk\u00e9sz\u00edt\u00e9se. Ugyanakkor el\u0151fordulhat, hogy a hallgat\u00f3k nem eml\u00e9keznek pontosan a Visual Studio haszn\u00e1lat\u00e1ra, \u00edgy a feladatok megold\u00e1sa sor\u00e1n ezeket folyamatosan eleven\u00edts\u00fck fel (pl. Solution Explorer, F5-futtat\u00e1s, breakpoint haszn\u00e1lat, stb.)","title":"A gyakorlat c\u00e9lja"},{"location":"labor/1-model-es-kod-kapcsolata/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Visual Studio-b\u00f3l a legfrissebb verzi\u00f3t c\u00e9lszer\u0171 feltenni. A Community Edition, Professional \u00e9s az Enterprise verzi\u00f3 is megfelel. A Community Edition ingyenes, let\u00f6lthet\u0151 a Microsoft honlapj\u00e1r\u00f3l. A Professional fizet\u0151s, de az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ez is ingyenesen el\u00e9rhet\u0151 ( https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben). Visual Studio Class Diagram t\u00e1mogat\u00e1s Jelen gyakorlat bizonyos feladatain\u00e1l (\u00e9s az els\u0151 h\u00e1zi feladat eset\u00e9ben is) a Visual Studio Class Designer t\u00e1mogat\u00e1s\u00e1t haszn\u00e1ljuk. A Visual Studio nem teszi fel minden esetben a Class Designer komponenst a telep\u00edt\u00e9s sor\u00e1n. Ha nem lehet Class Diagram-ot felvenni a Visual Studio projektbe (mert a Class Diagram nem szerepel a list\u00e1ban az Add New Item parancs sor\u00e1n megjelen\u0151 ablak list\u00e1j\u00e1ban \u2013 err\u0151l a jelen \u00fatmutat\u00f3 k\u00e9s\u0151bbi fejezet\u00e9ben b\u0151vebben), akkor a Class Diagram komponenst ut\u00f3lag kell telep\u00edteni: Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel). A megjelen\u0151 ablakban \u201eIndividual components\u201d f\u00fcl kiv\u00e1laszt\u00e1sa A keres\u0151mez\u0151be \u201eclass designer\u201d beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \u201eClass Designer\u201d elem ki van pip\u00e1lva. Amit \u00e9rdemes \u00e1tn\u00e9zned: A gyakorlathoz nem kapcsol\u00f3dik a t\u00e1rgyb\u00f3l el\u0151ad\u00e1s. Ugyanakkor a gyakorlat \u00e9p\u00edt az UML alapismeretekre, illetve az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d egym\u00e1sra t\u00f6rt\u00e9n\u0151 lek\u00e9pez\u00e9s\u00e9nek alapjaira.","title":"El\u0151felt\u00e9telek"},{"location":"labor/1-model-es-kod-kapcsolata/#gyakorlat-menete","text":"A gyakorlatvezet\u0151 a gyakorlat elej\u00e9n \u00f6sszefoglalja a gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyeket: \u2022 A t\u00e1rgyi adatlapon ezek t\u00f6bbs\u00e9ge megtal\u00e1lhat\u00f3 \u2022 Az otthoni feladatokr\u00f3l inform\u00e1ci\u00f3 a t\u00e1rgy honlapj\u00e1n tal\u00e1lhat\u00f3. Visual Studio fejleszt\u0151eszk\u00f6zzel, .NET alkalmaz\u00e1sokat fogunk k\u00e9sz\u00edteni C# nyelven. A C# hasonl\u00edt a Java-hoz, fokozatosan ismerj\u00fck meg a k\u00fcl\u00f6nbs\u00e9geket. A gyakorlat vezetett, gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok.","title":"Gyakorlat menete"},{"location":"labor/1-model-es-kod-kapcsolata/#1-feladat-hello-world-net-konzol-alkalmazas-elkeszitese","text":"A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely a konzolra ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget. Az alkalmaz\u00e1st C# nyelven k\u00e9sz\u00edtj\u00fck el. A leford\u00edtott alkalmaz\u00e1s futtat\u00e1s\u00e1t a .NET runtime v\u00e9gzi. A ford\u00edt\u00e1s/futtat\u00e1s elm\u00e9leti h\u00e1tter\u00e9t, valamint a .NET alapjait az els\u0151 el\u0151ad\u00e1s ismerteti. A solution \u00e9s azon bel\u00fcli projekt l\u00e9trehoz\u00e1s\u00e1nak l\u00e9p\u00e9sei Visual Studio 2022 eset\u00e9n: \u00daj projekt var\u00e1zsl\u00f3 elind\u00edt\u00e1sa, melyre k\u00e9t m\u00f3d is van Ind\u00edt\u00f3ablak seg\u00edts\u00e9g\u00e9vel Ind\u00edtsuk el a Visual Studio-t A megjelen\u0151 ind\u00edt\u00f3ablak jobb oldali s\u00e1vj\u00e1ban \u201eCreate new project\u201d M\u00e1r fut\u00f3 Visual Studio-ban File/New-Project A Create new project var\u00e1zsl\u00f3ban a \u201eConsole app\u201d (\u00e9s NEM a \u201eConsole app (.NET Framework)\u201d sablont v\u00e1lasszuk ki, ebb\u0151l is a C#-osat. Azt, hogy C#-os, a sablon ikonj\u00e1nak bal fels\u0151 sarka jelzi. Ha nem l\u00e1tjuk a list\u00e1ban, r\u00e1 kell keresni/sz\u0171rni. R\u00e1kereshet\u00fcnk a fels\u0151 keres\u0151s\u00e1vban a \u201econsole\u201d be\u00edr\u00e1s\u00e1val. Vagy az alatta lev\u0151 leny\u00edl\u00f3 mez\u0151k seg\u00edts\u00e9g\u00e9vel: az els\u0151ben (nyelvkiv\u00e1laszt\u00f3) \u201eC#\u201d, a harmadikban (projektt\u00edpus kiv\u00e1laszt\u00f3) \u201eConsole\u201d. 3. Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon: Project name: Hello World Location: a laborokban a c:\\work\\ mapp\u00e1ba dolgozzunk, ehhez van \u00edr\u00e1si jogunk. Solution name: Hello World (elvileg ez be is lesz \u00edrva, mire ide\u00e9r\u00fcnk) Place solution and project in the same directory: nincs pipa (de nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge). Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon: Framework: .NET 6 (Long-term support) . A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be (ennek magyar\u00e1zat\u00e1ra mindj\u00e1rt visszat\u00e9r\u00fcnk). A projekttel egy \u00faj solution is l\u00e9trej\u00f6n, mely strukt\u00far\u00e1ja a Visual Studio Solution Explorer ablak\u00e1ban tekinthet\u0151 \u00e1t. Egy solution t\u00f6bb projectb\u0151l \u00e1llhat, egy project pedig t\u00f6bb f\u00e1jlb\u00f3l. A solution a teljes munkak\u00f6rnyezetet fogja \u00f6ssze (egy .sln kiterjeszt\u00e9s\u0171 f\u00e1jl tartozik hozz\u00e1), m\u00edg egy projekt kimenete egy .exe vagy .dll f\u00e1jl jellemz\u0151en, vagyis egy \u00f6sszetett alkalmaz\u00e1s/rendszer egy komponens\u00e9t \u00e1ll\u00edtja el\u0151. A projektf\u00e1jlok kiterjeszt\u00e9se C# alkalmaz\u00e1sok eset\u00e9n .csproj . A Program.cs f\u00e1jlunk tartalma a k\u00f6vetkez\u0151: using System.Text ; namespace HelloWorld { class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); } } } Vegy\u00fcnk fel egy Console.ReadKey() sort: using System.Text ; namespace HelloWorld { class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); Console . ReadKey (); } } } Futtassuk az alkalmaz\u00e1st (pl. az F5 billenty\u0171 haszn\u00e1lat\u00e1val). A k\u00f3d fel\u00e9p\u00edt\u00e9se nagyon hasonl\u00edt a Java-hoz, illetve a C++-hoz. Az oszt\u00e1lyaink n\u00e9vterekbe szervezettek. N\u00e9vtereket hat\u00f3k\u00f6rbe \u201ehozni\u201d a using kulcssz\u00f3val tudjuk. N\u00e9vteret defini\u00e1lni a namespace kulcssz\u00f3val tudunk. Egy konzolos C# alkalmaz\u00e1sban az alkalmaz\u00e1sunk bel\u00e9p\u00e9si pontj\u00e1t egy statikus Main nev\u0171 f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1val adjuk meg. Az oszt\u00e1lyunk neve b\u00e1rmi lehet, a VS egy Program nev\u0171 oszt\u00e1lyt gener\u00e1lt eset\u00fcnkben. A Main f\u00fcggv\u00e9ny param\u00e9terlist\u00e1ja k\u00f6t\u00f6tt: vagy ne adjunk meg param\u00e9tereket, vagy egy string[] -\u00f6t adjunk meg, amiben fut\u00e1s k\u00f6zben megkapjuk az parancssori argumentumokat. .NET-ben a standard ki \u00e9s bemenet kezel\u00e9s\u00e9re a System n\u00e9vt\u00e9r Console oszt\u00e1lya haszn\u00e1land\u00f3. A WriteLine statikus m\u0171velet\u00e9vel egy sort tudunk ki\u00edrni, a ReadKey m\u0171velettel egy billenty\u0171 lenyom\u00e1s\u00e1ra v\u00e1rakozhatunk. Top level statements \u00e9s Implicit usings A projekt l\u00e9trehoz\u00e1sakor kor\u00e1bban bepip\u00e1ltuk a \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet. Ha ezt nem tett\u00fck volna meg, akkor a Program.cs f\u00e1jlunkban mind\u00f6ssze egyetlen \u00e9rdemi sort tal\u00e1ltunk volna: // See https://aka.ms/new-console-template for more information Console . WriteLine ( \"Hello World!\" ); Ez m\u0171k\u00f6d\u00e9s\u00e9ben ekvivalens a fenti Program oszt\u00e1lyt \u00e9s ebben Main f\u00fcggv\u00e9nyt tartalmaz\u00f3 k\u00f3ddal. N\u00e9zz\u00fck, mik teszik ezt lehet\u0151v\u00e9 (ezekr\u0151l pl. itt https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements olvashatunk b\u0151vebben, mindkett\u0151 C# 10 \u00fajdons\u00e1g): Top level statements . Ennek az a l\u00e9nyege, hogy mindenf\u00e9le oszt\u00e1ly/Main \u00e9s egy\u00e9b f\u00fcggv\u00e9nydefin\u00edci\u00f3 n\u00e9lk\u00fcl a projektben egyetlen forr\u00e1sf\u00e1jlban k\u00f6zvetlen\u00fcl is \u00edrhatunk k\u00f3dot. Ez esetben ezt a sz\u00ednfalak m\u00f6g\u00f6tt a ford\u00edt\u00f3 berakja egy \u00e1ltalunk nem l\u00e1that\u00f3 oszt\u00e1ly statikus Main f\u00fcggv\u00e9ny\u00e9be. A bevezet\u00e9s\u00e9nek a motiv\u00e1ci\u00f3ja az volt, hogy a nagyon egyszer\u0171, \u201escript\u201d szer\u0171 alkalmaz\u00e1sok eset\u00e9n kevesebb legyen a boilerplate k\u00f3d. Implicit global usings . Annak f\u00fcggv\u00e9ny\u00e9ben, hogy pontosan milyen projektt\u00edpust hoztunk l\u00e9tre, bizonyos alapn\u00e9vterek a sz\u00ednfalak m\u00f6g\u00f6tt automatikusan using-olva lesznek minden forr\u00e1sf\u00e1jlban (ehhez a compiler a \u201eglobal using\u201d utas\u00edt\u00e1st haszn\u00e1lja). A l\u00e9nyeg: a fejleszt\u0151knek \u00edgy bizonyos, gyakran haszn\u00e1lt n\u00e9vtereket (pl. System.IO, System.Collections.Generic stb.) nem kell a forr\u00e1sf\u00e1jlonk\u00e9nt using-olni. Inconsistent visibility vagy inconsistent accessibility hiba A f\u00e9l\u00e9v sor\u00e1n a programoz\u00e1si feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n tal\u00e1lkozhatunk \u201einconsistent visibility\u201d-re vagy \u201einconsistent accessibility\u201d-re panaszkod\u00f3 ford\u00edt\u00e1si hiba\u00fczenetekkel. A jelens\u00e9g h\u00e1tter\u00e9ben az \u00e1ll, hogy .NET k\u00f6rnyezetben lehet\u0151s\u00e9g van az egyes t\u00edpusok (oszt\u00e1ly, interf\u00e9sz, stb.) l\u00e1that\u00f3s\u00e1g\u00e1nak szab\u00e1lyoz\u00e1s\u00e1ra: internal vagy nem adjuk meg a l\u00e1that\u00f3s\u00e1got: a t\u00edpus csak az adott szerelv\u00e9nyen (.exe, .dll)/projekten, bel\u00fcl l\u00e1that\u00f3 public : a t\u00edpus m\u00e1s szerelv\u00e9nyek/projektek sz\u00e1m\u00e1ra is l\u00e1that\u00f3 A hiba legegyszer\u0171bben \u00fagy h\u00e1r\u00edthat\u00f3 el, ha minden t\u00edpusunkat publikusnak defini\u00e1ljuk, pl.: public class HardDisk { \u2026 }","title":"1. Feladat - \u201eHello world\u201d .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se"},{"location":"labor/1-model-es-kod-kapcsolata/#elmeleti-attekintes","text":"Az alfejezetek nem tartalmaznak feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismertetik a kapcsol\u00f3d\u00f3 elm\u00e9leti t\u00e9mak\u00f6r\u00f6ket, p\u00e9ld\u00e1kkal illusztr\u00e1lva.","title":"Elm\u00e9leti \u00e1ttekint\u00e9s"},{"location":"labor/1-model-es-kod-kapcsolata/#a-az-uml-osztalydiagram-es-a-kod-kapcsolatanak-elmelete-hallgato","text":"Az anyag itt el\u00e9rhet\u0151: Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolata . Ez a t\u00e9mak\u00f6r kor\u00e1bbi f\u00e9l\u00e9vben a Szoftvertechnol\u00f3gia t\u00e1rgy keret\u00e9ben ker\u00fclt ismertet\u00e9sre.","title":"A) Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete [hallgat\u00f3]*"},{"location":"labor/1-model-es-kod-kapcsolata/#b-interfesz-es-absztrakt-ososztaly-hallgato","text":"Az anyag itt el\u00e9rhet\u0151: Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly . T\u00e9mak\u00f6r\u00f6k: Absztrakt oszt\u00e1ly fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven Interf\u00e9sz fogalma \u00e9s defini\u00e1l\u00e1sa C# nyel Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa","title":"B) Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly [hallgat\u00f3]*"},{"location":"labor/1-model-es-kod-kapcsolata/#2-feladat-az-uml-es-a-kod-kapcsolatanak-szemleltetese","text":"Feladat: Egy sz\u00e1m\u00edt\u00f3g\u00e9palkatr\u00e9sz nyilv\u00e1ntart\u00f3 alkalmaz\u00e1s kifejleszt\u00e9s\u00e9vel b\u00edztak meg benn\u00fcnket. B\u0151vebben: K\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00fa alkatr\u00e9szeket kell tudni kezelni. Kezdetben a HardDisk , SoundCard \u00e9s LedDisplay t\u00edpusokat kell t\u00e1mogatni, de a rendszer legyen k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00faj t\u00edpusokkal. Az alkatr\u00e9szekhez tartoz\u00f3 adatok: beszerz\u00e9s \u00e9ve, \u00e9letkora (sz\u00e1m\u00edtott), beszerz\u00e9si \u00e1ra \u00e9s aktu\u00e1lis \u00e1ra (sz\u00e1m\u00edtott), de ezeken fel\u00fcl t\u00edpusf\u00fcgg\u0151 adatokat is tartalmazhatnak (pl. a HardDisk eset\u00e9ben a kapacit\u00e1s). Az aktu\u00e1lis \u00e1r f\u00fcgg az alkatr\u00e9sz t\u00edpus\u00e1t\u00f3l, a beszerz\u00e9si \u00e1rt\u00f3l \u00e9s az alkatr\u00e9sz gy\u00e1rt\u00e1si \u00e9v\u00e9t\u0151l. Pl. min\u00e9l \u00f6regebb egy alkatr\u00e9sz, ann\u00e1l nagyobb kedvezm\u00e9nyt adunk r\u00e1, de a kedvezm\u00e9ny m\u00e9rt\u00e9ke f\u00fcgg az alkatr\u00e9sz t\u00edpust\u00f3l is. List\u00e1zni kell tudni a k\u00e9szleten lev\u0151 alkatr\u00e9szeket. A LedDisplay oszt\u00e1lynak k\u00f6telez\u0151en egy DisplayBase oszt\u00e1lyb\u00f3l kell sz\u00e1rmaznia, \u00e9s a DisplayBase oszt\u00e1ly forr\u00e1sk\u00f3dja nem megv\u00e1ltoztathat\u00f3. Jelen p\u00e9ld\u00e1ban ennek nincs sok \u00e9rtelme, a gyakorlatban azonban gyakran tal\u00e1lkozunk hasonl\u00f3 helyzettel, amikor is az \u00e1ltalunk haszn\u00e1lt keretrendszer/platform el\u0151\u00edrja, hogy adott esetben egy-egy be\u00e9p\u00edtett oszt\u00e1lyb\u00f3l kell sz\u00e1rmaztassunk. Tipikusan ez a helyzet, amikor ablakokkal, \u0171rlapokkal, saj\u00e1t vez\u00e9rl\u0151t\u00edpusokkal dolgozunk: ezeket a keretrendszer be\u00e9p\u00edtett oszt\u00e1lyaib\u00f3l kell sz\u00e1rmaztatnunk, \u00e9s a keretrendszer - pl. Java, .NET - forr\u00e1sk\u00f3dja nem \u00e1ll rendelkez\u00e9s\u00fcnkre (de legal\u00e1bbis biztosan nem akarjuk megv\u00e1ltoztatni). A p\u00e9ld\u00e1nkban a DisplayBase -b\u0151l val\u00f3 sz\u00e1rmaztat\u00e1s el\u0151\u00edr\u00e1s\u00e1val ezt a helyzetet szimul\u00e1ljuk. A megval\u00f3s\u00edt\u00e1s sor\u00e1n jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9l\u00fcnk: az alkatr\u00e9szeket csak mem\u00f3ri\u00e1ban tarjuk nyilv\u00e1n, a list\u00e1z\u00e1s is a lehet\u0151 legegyszer\u0171bb, egyszer\u0171en csak ki\u00edrjuk a nyilv\u00e1ntartott alkatr\u00e9szek adatait a konzolra. A kezdeti egyeztet\u00e9sek sor\u00e1n a megrendel\u0151nkt\u0151l a k\u00f6vetkez\u0151 inform\u00e1ci\u00f3t kapjuk: egy bels\u0151 munkat\u00e1rsuk m\u00e1r elindult a fejleszt\u00e9ssel, de id\u0151 hi\u00e1ny\u00e1ban csak f\u00e9lk\u00e9sz megold\u00e1sig jutott. A feladatunk r\u00e9sz\u00e9t k\u00e9pezi a f\u00e9lk\u00e9sz megold\u00e1s megismer\u00e9se, illetve ebb\u0151l kiindulva kell a feladatot megval\u00f3s\u00edtani. Nyissuk meg a megrendel\u0151nkt\u0151l kapott forr\u00e1sk\u00f3d solution-j\u00e9t (EquipmentP\u00e9lda \u2013 Kiindul\u00e1s mappa) Visual Studio alatt (EquipmentInventory.sln). A Solution Explorerben szemmel fussuk \u00e1t a f\u00e1jlokat. Az meg\u00e9rt\u00e9st seg\u00edten\u00e9, ha egy oszt\u00e1lydiagramon megjelen\u00edten\u00e9nk az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatokat. Vegy\u00fcnk is fel egy oszt\u00e1lydiagramot a projekt\u00fcnkbe. A Solution Explorerben a projekten (\u00e9s nem a solution-\u00f6n!) jobb gombbal kattintva a felugr\u00f3 men\u00fcben az Add/New Item \u2026 elemet v\u00e1lasztva, majd a megjelen\u0151 ablakban a Class Diagram elemet v\u00e1lasszuk ki, az ablak alj\u00e1n a diagram nev\u00e9nek a Main.cd-t adjuk meg, \u00e9s OK-zuk le az ablakot. Note Megjegyz\u00e9s: ha a Class Diagram elem nem jelenik meg a list\u00e1ban, akkor nincs telep\u00edtve a VS megfelel\u0151 komponense. Err\u0151l jelen dokumentum El\u0151felt\u00e9telek fejezet\u00e9ben olvashatsz b\u0151vebben. Ekkor a Solution Explorerben megjelenik a Main.cd diagramf\u00e1jl, duplakattint\u00e1ssal nyissuk meg. A diagramunk jelenleg \u00fcres. A Solution Explorerb\u0151l drag&drop-pal dobjuk r\u00e1 a .cs forr\u00e1sf\u00e1jlokat a diagramra. Ekkor a VS megn\u00e9zi, milyen oszt\u00e1lyok vannak ezekben a forr\u00e1sf\u00e1jlokban, \u00e9s visszafejti \u0151ket UML oszt\u00e1lyokk\u00e1. Alak\u00edtsuk ki a k\u00f6vetkez\u0151 \u00e1br\u00e1nak megfelel\u0151 elrendez\u00e9st (az oszt\u00e1lyok tagjainak megjelen\u00edt\u00e9s\u00e9t a t\u00e9glalapuk jobb fels\u0151 sark\u00e1ban lev\u0151 duplany\u00edlra kattint\u00e1ssal \u00e9rhetj\u00fck el): Az oszt\u00e1lyokhoz tartoz\u00f3 forr\u00e1sk\u00f3dot is megn\u00e9zhetj\u00fck, ak\u00e1r a diagramon a megfelel\u0151 oszt\u00e1lyra dupl\u00e1n kattintva, ak\u00e1r a Solution Explorerb\u0151l a .cs f\u00e1jlokat megnyitva. A k\u00f6vetkez\u0151ket tapasztaljuk: A SoundCard , HardDisk \u00e9s LedDisplay oszt\u00e1lyok viszonylag j\u00f3l kidolgozottak, rendelkeznek a sz\u00fcks\u00e9ges attrib\u00fatumokkal \u00e9s lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyekkel. Az LedDisplay a k\u00f6vetelm\u00e9nyeknek megfelel\u0151en a DisplayBase oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Az EquipmentInventory felel\u0151s ugyan a k\u00e9szleten lev\u0151 alkatr\u00e9szek nyilv\u00e1ntart\u00e1s\u00e1\u00e9rt, de gyakorlatilag semmi nincs ebb\u0151l megval\u00f3s\u00edtva. Tal\u00e1lunk egy IEquipment interf\u00e9szt, GetAge \u00e9s GetPrice m\u0171veletekkel \u00c1lljunk neki a megold\u00e1s kidolgoz\u00e1s\u00e1nak. El\u0151sz\u00f6r is az alapkoncepci\u00f3kat fektess\u00fck le. Az EquipmentInventory oszt\u00e1lyban egy heterog\u00e9n kollekci\u00f3ban t\u00e1roljuk a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusokat. Ez a kulcsa az alkatr\u00e9szek egys\u00e9ges kezel\u00e9s\u00e9nek, vagyis annak, hogy a megold\u00e1sunk \u00faj alkatr\u00e9szt\u00edpusokkal k\u00f6nnyen b\u0151v\u00edthet\u0151 legyen. Mint kor\u00e1bban taglaltuk, az egys\u00e9ges kezel\u00e9st vagy k\u00f6z\u00f6s \u0151soszt\u00e1ly, vagy k\u00f6z\u00f6s interf\u00e9sz bevezet\u00e9s\u00e9vel lehet megoldani. Eset\u00fcnkben a k\u00f6z\u00f6s \u0151soszt\u00e1ly (pl. EquipmentBase ) \u00fagy t\u0171nik, kiesik, mert ennek bevezet\u00e9s\u00e9vel az LedDisplay oszt\u00e1lynak k\u00e9t \u0151soszt\u00e1lya is lenne: a k\u00f6telez\u0151nek kik\u00f6t\u00f6tt DisplayBase , \u00e9s az \u00e1ltalunk az egys\u00e9ges kezel\u00e9sre bevezetett EquipmentBase . Ez nem lehets\u00e9ges, .NET k\u00f6rnyezetben egy oszt\u00e1lynak csak egy \u0151se lehet. Az a megold\u00e1s pedig, hogy a DisplayBase -t \u00fagy m\u00f3dos\u00edtjuk, hogy \u0151 is az EquipmentBase -b\u0151l sz\u00e1rmazik, a k\u00f6vetelm\u00e9ny\u00fcnknek megfelel\u0151en nem lehets\u00e9ges (kik\u00f6t\u00e9s volt, hogy a forr\u00e1sk\u00f3dja nem m\u00f3dos\u00edthat\u00f3). Marad teh\u00e1t az interf\u00e9sz alap\u00fa megk\u00f6zel\u00edt\u00e9s. Minden bizonnyal az alkalmaz\u00e1s kor\u00e1bbi fejleszt\u0151je is erre a k\u00f6vetkeztet\u00e9sre jutott, ez\u00e9rt is vezette be az IEquipment interf\u00e9szt. Vegy\u00fcnk fel egy IEquipment t\u00edpus\u00fa elemekb\u0151l \u00e1ll\u00f3 generikus list\u00e1t (ne property-t hanem field-et!) az EquipmentInventory oszt\u00e1lyba. A l\u00e1that\u00f3s\u00e1ga \u2013 az egys\u00e9gbez\u00e1r\u00e1sra t\u00f6rekedve \u2013 legyen private. A neve legyen equipment (ne legyen \u201es\u201d a v\u00e9g\u00e9n, angolban az equipment t\u00f6bbes sz\u00e1ma is equipment). A tagv\u00e1ltoz\u00f3 felv\u00e9tel\u00e9hez a Visual Studio Class Details ablak\u00e1t haszn\u00e1ljuk. Ha az ablak nem l\u00e1that\u00f3, a View/Other Windows/Class Details men\u00fc kiv\u00e1laszt\u00e1s\u00e1val jelen\u00edthet\u0151 meg. A tagv\u00e1ltoz\u00f3 t\u00edpusa teh\u00e1t List<IEquipment> . A .NET List t\u00edpusa egy dinamikusan ny\u00fajt\u00f3zkod\u00f3 generikus t\u00f6mb (mint Java-ban az ArrayList ). A diagramon az EquipmentInventory oszt\u00e1lyra pillantva azt l\u00e1tjuk, hogy csak a tagv\u00e1ltoz\u00f3 neve jelenik meg, a t\u00edpusa nem. A diagram h\u00e1tter\u00e9n jobb gombbal kattintva a Change Members Format men\u00fcb\u0151l a Display Full Signature -t v\u00e1lasszuk ki. Ezt k\u00f6vet\u0151en a diagramon l\u00e1that\u00f3v\u00e1 v\u00e1lik a tagv\u00e1ltoz\u00f3k t\u00edpusa, valamint a m\u0171veletek teljes szignat\u00far\u00e1ja. Az EquipmentInventory oszt\u00e1lyon dupl\u00e1n kattintva elnavig\u00e1lhatunk a forr\u00e1sk\u00f3dba, \u00e9s mint l\u00e1that\u00f3, val\u00f3ban egy lista t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k\u00e9nt jelenik meg a k\u00f3dban: class EquipmentInventory { private List < IEquipment > equipment ; Ennek egyr\u00e9szt \u00f6r\u00fcl\u00fcnk, mert a Visual Studio t\u00e1mogatja a round-trip engineering technik\u00e1t: a modellt \u00e9rint\u0151 v\u00e1ltoz\u00e1sokat azonnal \u00e1tvezeti a k\u00f3dba, \u00e9s viszont . M\u00e1sr\u00e9szt a kor\u00e1bbiakban azt taglaltuk, hogy ha egy oszt\u00e1lyban egy gy\u0171jtem\u00e9ny tag van egy m\u00e1sik oszt\u00e1ly elemeib\u0151l, akkor annak az UML modellben egy 1-t\u00f6bb t\u00edpus\u00fa asszoci\u00e1ci\u00f3s kapcsolatk\u00e9nt \u201eillik\u201d megjelennie a k\u00e9t oszt\u00e1ly k\u00f6z\u00f6tt. A modell\u00fcnkben egyel\u0151re nem ezt tapasztaljuk. Szerencs\u00e9re a VS modellez\u0151 fel\u00fclete r\u00e1vehet\u0151, hogy ilyen form\u00e1ban jelen\u00edtse meg ezt a kapcsolatt\u00edpust. Ehhez kattintsunk a diagramon jobb gombbal az equipment tagv\u00e1ltoz\u00f3n, \u00e9s a men\u00fcb\u0151l v\u00e1lasszuk ki a Show as Collection Association elemet. Az IEquipment oszt\u00e1lyt ezt k\u00f6vet\u0151en mozgassuk ki jobbra, hogy kell\u0151 hely legyen a diagramon az asszoci\u00e1ci\u00f3s kapcsolat \u00e9s a kapcsolaton lev\u0151 szerep (role) adatainak megjelen\u00edt\u00e9s\u00e9re: A dupla ny\u00edl v\u00e9gz\u0151d\u00e9s a \u201et\u00f6bbes\u201d oldalon nem szabv\u00e1nyos UML, de ne szomorodjunk el t\u0151le k\u00fcl\u00f6n\u00f6sebben, nincs semmi jelent\u0151s\u00e9ge. Annak mindenk\u00e9ppen \u00f6r\u00fcl\u00fcnk, hogy a kapcsolatot reprezent\u00e1l\u00f3 ny\u00edl az IEquipment v\u00e9g\u00e9n a szerepben a tagv\u00e1ltoz\u00f3 neve (s\u0151t, m\u00e9g a pontos t\u00edpusa is) fel van t\u00fcntetve. Navig\u00e1ljunk el az EquipmentInventory forr\u00e1sk\u00f3dj\u00e1hoz, \u00e9s \u00edrjuk meg a konstruktor\u00e1t, ami inicializ\u00e1lja az equipment gy\u0171jtem\u00e9nyt! public EquipmentInventory () { equipment = new List < IEquipment >(); } Ezut\u00e1n \u00edrjuk meg a ListAll met\u00f3dust, ami ki\u00edrja az elemek \u00e9letkor\u00e1t, \u00e9s az aktu\u00e1lis \u00e9rt\u00e9k\u00fcket: public void ListAll () { foreach ( IEquipment eq in equipment ) { Console . WriteLine ( $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\" ); } } Az elemeken a foreach utas\u00edt\u00e1ssal iter\u00e1lunk v\u00e9gig. A foreach utas\u00edt\u00e1s haszn\u00e1lata sor\u00e1n az in kulcssz\u00f3 ut\u00e1n egy gy\u0171jtem\u00e9nynek kell \u00e1llnia, az in el\u0151tt pedig egy v\u00e1ltoz\u00f3 deklar\u00e1ci\u00f3nak (eset\u00fcnkben IEquipment eq), ahol a t\u00edpus a gy\u0171jtem\u00e9ny elemt\u00edpusa. Minden iter\u00e1ci\u00f3ban ez a v\u00e1ltoz\u00f3 a gy\u0171jtem\u00e9ny iter\u00e1ci\u00f3beli \u00e9rt\u00e9k\u00e9t veszi fel. A Console.WriteLine m\u0171veletnek vagy egy egyszer\u0171 stringet adunk meg, vagy, mint eset\u00fcnkben, egy form\u00e1z\u00e1si stringet. A behelyettes\u00edt\u00e9seket string interpol\u00e1ci\u00f3val oldottuk meg: a behelyettes\u00edtend\u0151 \u00e9rt\u00e9keket {} k\u00f6z\u00f6tt kell megadni. Ha string interpol\u00e1ci\u00f3t haszn\u00e1lunk, a stringnek $ jellel kell kezd\u0151dnie. \u00cdrjunk meg egy AddEquipment nev\u0171 f\u00fcggv\u00e9nyt, ami felvesz egy \u00faj eszk\u00f6zt a k\u00e9szletbe: public void AddEquipment ( IEquipment eq ) { equipment . Add ( eq ); } Kor\u00e1bbi d\u00f6nt\u00e9s\u00fcnk \u00e9rtelm\u00e9ben az IEquipment interf\u00e9szt haszn\u00e1ljuk az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusok egys\u00e9ges kezel\u00e9s\u00e9re. Est\u00fcnkben mind a SoundCard, mind a HardDisk oszt\u00e1ly rendelkezik GetAge() \u00e9s GetPrice() met\u00f3dussal, m\u00e9gsem tudjuk \u0151ket egys\u00e9gesen kezelni (pl. k\u00f6z\u00f6s list\u00e1ban t\u00e1rolni). Ahhoz, hogy ezt meg tudjuk tenni, el kell \u00e9rn\u00fcnk, hogy mindk\u00e9t oszt\u00e1ly megval\u00f3s\u00edtsa az IEquipment interf\u00e9szt. M\u00f3dos\u00edtsuk a forr\u00e1sukat: public class SoundCard : IEquipment { ... public class HardDisk : IEquipment { ... Ezt k\u00f6vet\u0151en a SoundCard \u00e9s HardDisk oszt\u00e1lyban implement\u00e1lnunk kell az IEquipment interf\u00e9szben lev\u0151 met\u00f3dusokat. Azt tapasztaljuk, hogy ezzel nincs most teend\u0151k, a GetPrice \u00e9s GetAge f\u00fcggv\u00e9nyek m\u00e1r meg vannak \u00edrva mindk\u00e9t helyen. Pr\u00f3bak\u00e9ppen a Program.cs f\u00e1jlban tal\u00e1lhat\u00f3 Main f\u00fcggv\u00e9ny\u00fcnkben hozzunk l\u00e9tre egy EquipmentInventory objektumot, t\u00f6lts\u00fck fel HardDisk \u00e9s SoundCard objektumokkal, majd list\u00e1zzuk a k\u00e9sztelet a konzolra. Ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra! static void Main ( string [] args ) { EquipmentInventory ei = new EquipmentInventory (); ei . AddEquipment ( new HardDisk ( 2021 , 30000 , 80 )); ei . AddEquipment ( new HardDisk ( 2020 , 25000 , 120 )); ei . AddEquipment ( new HardDisk ( 2020 , 25000 , 250 )); ei . AddEquipment ( new SoundCard ( 2021 , 8000 )); ei . AddEquipment ( new SoundCard ( 2020 , 7000 )); ei . AddEquipment ( new SoundCard ( 2020 , 6000 )); ei . ListAll (); Console . ReadKey (); } Az alkalmaz\u00e1st futtatva azt tapasztaljuk, hogy b\u00e1r megold\u00e1sunk kezdetleges, de m\u0171k\u00f6dik: Folytassuk a munk\u00e1t a LedDisplay oszt\u00e1llyal. A DisplayBase \u0151s forr\u00e1sk\u00f3dj\u00e1t a k\u00f6vetelm\u00e9nyek miatt nem m\u00f3dos\u00edthatjuk. De ez semmif\u00e9le probl\u00e9m\u00e1t nem okoz, a LedDisplay oszt\u00e1lyunk fogja az IEquipment interf\u00e9szt implement\u00e1lni, m\u00f3dos\u00edtsuk a k\u00f3dot ennek megfelel\u0151en: public class LedDisplay : DisplayBase , IEquipment A LedDisplay oszt\u00e1lyban m\u00e1r meg kell \u00edrni az interf\u00e9szben szerepl\u0151 f\u00fcggv\u00e9nyeket: public double GetPrice () { return this . price ; } public int GetAge () { return DateTime . Today . Year - this . manufacturingYear ; } B\u0151v\u00edts\u00fck a Main f\u00fcggv\u00e9ny\u00fcnket is, vegy\u00fcnk fel k\u00e9t LedDisplay objektumot a k\u00e9szlet\u00fcnkbe (itt is \u00e9l, hogy ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra! ei . AddEquipment ( new LedDisplay ( 2020 , 80000 , 17 , 16 ) ); ei . AddEquipment ( new LedDisplay ( 2021 , 70000 , 17 , 12 ) ); ei . ListAll (); Console . ReadKey (); Tesztel\u00e9sk\u00e9ppen futtassuk az alkalmaz\u00e1st.","title":"2. Feladat - Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se"},{"location":"labor/1-model-es-kod-kapcsolata/#3-feladat-az-interfesz-es-az-absztrakt-ososztaly-alkalmazastechnikaja","text":"\u00c9rt\u00e9kelj\u00fck a jelenlegi, interf\u00e9sz alap\u00fa megold\u00e1sunkat. Az egyik f\u0151 probl\u00e9ma, hogy k\u00f3dunk tele van a karbantarthat\u00f3s\u00e1got \u00e9s b\u0151v\u00edthet\u0151s\u00e9get rombol\u00f3 k\u00f3dduplik\u00e1ci\u00f3val: A yearOfCreation \u00e9s newPrice tagok minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis LedDisplay -t) k\u00f6z\u00f6sek, ezeket \u00faj t\u00edpus bevezet\u00e9sekor is copy-paste technik\u00e1val \u00e1t kell venni. A GetAge f\u00fcggv\u00e9ny implement\u00e1ci\u00f3ja szinten minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis LedDisplay -t) azonos, szint\u00e9n copy-paste-tel \u201eszapor\u00edtand\u00f3\u201d. A konstruktorok yearOfCreation \u00e9s newPrice tagokat inicializ\u00e1l\u00f3 sorai szint\u00e9n duplik\u00e1ltak az egyes oszt\u00e1lyokban. B\u00e1r ez a k\u00f3dduplik\u00e1ci\u00f3 egyel\u0151re nem t\u0171nik jelent\u0151snek, \u00faj alkatr\u00e9sz t\u00edpusok bevezet\u00e9s\u00e9vel egyre ink\u00e1bb elm\u00e9rgesedik a helyzet, jobb id\u0151ben elej\u00e9t venni a j\u00f6v\u0151beli f\u00e1jdalmaknak. A m\u00e1sik probl\u00e9ma abb\u00f3l ad\u00f3dik, hogy az alkatr\u00e9sz adatok list\u00e1z\u00e1sa jelenleg f\u00e1jdalmasan hi\u00e1nyos, nem jelenik meg az alkatr\u00e9sz t\u00edpusa (csak a kora \u00e9s az \u00e1ra). A t\u00edpus megjelen\u00edt\u00e9s\u00e9hez az IEquipment interf\u00e9szt b\u0151v\u00edteni kell, pl. egy GetDescription nev\u0171 m\u0171velet bevezet\u00e9s\u00e9vel. Vegy\u00fcnk is fel egy GetDescription f\u00fcggv\u00e9nyt az interf\u00e9szbe! public interface IEquipment { double GetPrice (); int GetAge (); string GetDescription (); } Ekkor minden IEquipment interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban meg kellene val\u00f3s\u00edtani ezt a met\u00f3dust is, ami sok oszt\u00e1ly eset\u00e9n sok munka (valamint egy t\u00f6bbkomponens\u0171, vagyis t\u00f6bb DLL-b\u0151l \u00e1ll\u00f3 alkalmaz\u00e1s eset\u00e9ben, amikor ezek nem egy fejleszt\u0151 c\u00e9g kez\u00e9ben vannak, sokszor nem is megoldhat\u00f3). A build parancs futtat\u00e1s\u00e1val ellen\u0151rizz\u00fck, hogy a GetDescription felv\u00e9tele ut\u00e1n h\u00e1rom helyen is ford\u00edt\u00e1si hib\u00e1t kapunk. Interf\u00e9szben alap\u00e9rtelmezett implement\u00e1ci\u00f3 megad\u00e1sa \u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja . B\u0151vebben inform\u00e1ci\u00f3 itt: default interface methods . public interface IEquipment { double GetPrice (); int GetAge (); string GetDescription () { return \"EquipmentBase\" ; } } Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelent egy k\u00f6z\u00f6s absztrakt \u0151s bevezet\u00e9se (kiv\u00e9ve az LedDiplay oszt\u00e1lyt, amire m\u00e9g visszat\u00e9r\u00fcnk). Ebbe fel tudjuk k\u00f6lt\u00f6ztetni a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot, valamint az \u00fajonnan bevezetett GetDescription m\u0171velethez egy alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni. Legyen az \u00faj absztrakt \u0151soszt\u00e1lyunk neve EquipmentBase . K\u00e9rd\u00e9s, sz\u00fcks\u00e9g van-e a tov\u00e1bbiakban az IEquipment interf\u00e9szre, vagy az teljesen kiv\u00e1lthat\u00f3 az \u00faj EquipmentBase oszt\u00e1llyal. Az IEquipment interf\u00e9szt meg kell tartsuk, mert a LedDisplay oszt\u00e1lyunkat nem tudjuk az EquipmentBase -b\u0151l sz\u00e1rmaztatni: m\u00e1r van egy k\u00f6telez\u0151en el\u0151\u00edrt \u0151soszt\u00e1lya, a DisplayBase : emiatt az EquipmentInventory a tov\u00e1bbfejlesztett megold\u00e1sunkban is IEquipment interf\u00e9szk\u00e9nt hivatkozik az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szekre. \u00c1lljunk is neki az \u00e1talak\u00edt\u00e1snak. Legyen az oszt\u00e1lydiagramunk az akt\u00edv tabf\u00fcl. A Toolbox-b\u00f3l drag&drop-pal dobjunk fel egy Abstract Class elemet a diagramra, a neve legyen EquipmentBase . A k\u00f6vetkez\u0151kben azt kell el\u00e9rj\u00fck, hogy a SoundCard \u00e9s a HardDisk oszt\u00e1lyok sz\u00e1rmazzanak az EquipmentBase -b\u0151l (a LedDisplay -nek m\u00e1r van m\u00e1sik \u0151se, \u00edgy ott ezt nem tudjuk megtenni). Ehhez v\u00e1lasszuk ki az Inheritance kapcsolatot a Toolbox-ban, majd h\u00fazzunk egy-egy vonalat a gyermekoszt\u00e1lyb\u00f3l kiindulva az \u0151soszt\u00e1lyba a SoundCard \u00e9s HardDisk eset\u00e9ben egyar\u00e1nt. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben alak\u00edtsuk \u00e1t \u00fagy a k\u00f3dot, hogy ne a HardDisk \u00e9s SoundCard val\u00f3s\u00edts\u00e1k meg k\u00fcl\u00f6n-k\u00fcl\u00f6n az IEquipment interf\u00e9szt, hanem a k\u00f6z\u00f6s \u0151s\u00fck, az EquipmentBase egyszer. Ehhez m\u00f3dos\u00edtsuk az EquipmentBase oszt\u00e1lyt \u00fagy, hogy val\u00f3s\u00edtsa meg az interf\u00e9szt (ak\u00e1r a diagramon h\u00fazzunk be egy inheritance kapcsolatot az EquipmentBase -b\u0151l az IEquipment -be, vagy az EquipmentBase forr\u00e1sk\u00f3dj\u00e1t m\u00f3dos\u00edtsuk). A HardDisk \u00e9s SoundCard oszt\u00e1lyokb\u00f3l t\u00f6r\u00f6lj\u00fck az IEquipment megval\u00f3s\u00edt\u00e1s\u00e1t (az \u0151s m\u00e1r implement\u00e1lja). A diagramunk \u00e9s a forr\u00e1sk\u00f3dunk vonatkoz\u00f3 r\u00e9szei ezt k\u00f6vet\u0151en \u00edgy n\u00e9znek ki: public abstract class EquipmentBase : IEquipment { } public class HardDisk : EquipmentBase { \u2026 public class SoundCard : EquipmentBase { \u2026 A k\u00f3dunk m\u00e9g nem fordul, ennek t\u00f6bb oka is van. Az EquipmentBase implement\u00e1lja az IEquipment interf\u00e9szt, de m\u00e9g nincsenek benne implement\u00e1lva az interf\u00e9sz m\u0171veletei. Vagy gener\u00e1ltassuk le a met\u00f3dusokat a smart tag haszn\u00e1lat\u00e1val, vagy g\u00e9pelj\u00fck be a k\u00f6vetkez\u0151 elveknek megfelel\u0151en: A newPrice \u00e9s earOfCreation duplik\u00e1lva vannak a HardDisk \u00e9s SoundCard oszt\u00e1lyokban: mozgassuk (\u00e9s ne m\u00e1soljuk!) \u00e1t ezeket a k\u00f6z\u00f6s EquipmentBase \u0151sbe, \u00e9s protected l\u00e1that\u00f3s\u00e1got adjunk meg. A GetAge m\u0171velet duplik\u00e1lva van a HardDisk \u00e9s SoundCard oszt\u00e1lyokban, ezekb\u0151l t\u00f6r\u00f6lj\u00fck ki az implement\u00e1ci\u00f3t \u00e9s vigy\u00fck \u00e1t az EquipmentBase oszt\u00e1lyba. A GetPrice m\u0171veletet absztrakt m\u0171veletk\u00e9nt vegy\u00fck fel az \u0151sbe. Ez sz\u00e1nd\u00e9kos tervez\u0151i d\u00f6nt\u00e9s, \u00edgy r\u00e1k\u00e9nyszer\u00edtj\u00fck a lesz\u00e1rmazott oszt\u00e1lyokat, hogy mindenk\u00e9ppen defini\u00e1lj\u00e1k fel\u00fcl ezt a m\u0171veletet. A GetDescription eset\u00e9ben viszont pont ford\u00edtottja a helyzet: ezt virtu\u00e1lisnak defini\u00e1ljuk (\u00e9s nem absztraktnak), vagyis m\u00e1r az \u0151sben is adunk meg implement\u00e1ci\u00f3t. \u00cdgy a lesz\u00e1rmazottak nincsenek r\u00e1k\u00e9nyszer\u00edtve a m\u0171velet fel\u00fcldefini\u00e1l\u00e1s\u00e1ra. A fentieknek megfelel\u0151 k\u00f3d a k\u00f6vetkez\u0151: public abstract class EquipmentBase : IEquipment { protected int yearOfCreation ; protected int newPrice ; public int GetAge () { return DateTime . Today . Year - yearOfCreation ; } public abstract double GetPrice (); public virtual string GetDescription () { return \"EquipmentBase\" ; } } N\u00e9h\u00e1ny kieg\u00e9sz\u00edt\u0151 gondolat a k\u00f3dr\u00e9szletre vonatkoz\u00f3an: Az absztrakt oszt\u00e1lyok eset\u00e9ben az abstract kulcssz\u00f3t ki kell \u00edrni a class sz\u00f3 el\u00e9. Az absztrakt m\u0171veletek eset\u00e9ben az abstract kulcssz\u00f3t kell megadni .NET k\u00f6rnyezetben lehet\u0151s\u00e9g\u00fcnk van szab\u00e1lyozni, hogy egy m\u0171velet virtu\u00e1lis-e vagy sem. Ebb\u0151l a szempontb\u00f3l a C++ nyelvhez hasonl\u00edt. Amennyiben egy m\u0171veletet virtu\u00e1liss\u00e1 szeretn\u00e9nk tenni, a virtual kulcssz\u00f3t kell a m\u0171veletre megadni. Eml\u00e9keztet\u0151: akkor defini\u00e1ljunk egy m\u0171veletet virtu\u00e1lisnak, ha a lesz\u00e1rmazottak azt fel\u00fcldefini\u00e1l(hat)j\u00e1k. Csak ekkor garant\u00e1lt, hogy egy \u0151sreferenci\u00e1n megh\u00edvva az adott m\u0171veletet a lesz\u00e1rmazottbeli verzi\u00f3 h\u00edv\u00f3dik meg. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t az EquipmentBase lesz\u00e1rmazottakra. C# nyelven az absztrakt \u00e9s virtu\u00e1lis m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor a lesz\u00e1rmazottban meg kell adni az override kulcssz\u00f3t. Els\u0151 l\u00e9p\u00e9sben a GetPrice m\u0171veletet defini\u00e1ljuk fel\u00fcl: public class HardDisk : EquipmentBase { \u2026 public override double GetPrice () { return yearOfCreation < ( DateTime . Today . Year - 4 ) ? 0 : newPrice - ( DateTime . Today . Year - yearOfCreation ) * 5000 ; } } public class SoundCard : EquipmentBase { \u2026 public override double GetPrice () { return yearOfCreation < ( DateTime . Today . Year - 4 ) ? 0 : newPrice - ( DateTime . Today . Year - yearOfCreation ) * 2000 ; } } A k\u00f6vetkez\u0151kben l\u00e9p\u00e9sben a GetDescription m\u0171veletet \u00edrjuk meg a HardDisk \u00e9s SoundCard oszt\u00e1lyokban. Mivel itt az \u0151sbeli virtu\u00e1lis f\u00fcggv\u00e9nyt defini\u00e1ljuk fel\u00fcl, szint\u00e9n meg kell adni az override kulcssz\u00f3t: public class HardDisk : EquipmentBase { \u2026 public override string GetDescription () { return \"HardDisk\" ; } } public class SoundCard : EquipmentBase { \u2026 public override string GetDescription () { return \"SoundCard\" ; } } Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, mi\u00e9rt d\u00f6nt\u00f6ttek \u00fagy a C# nyelv tervez\u0151i, hogy a m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor egy extra kulcssz\u00f3t kelljen megadni, hasonl\u00f3ra pl. a C++ nyelv eset\u00e9ben nem volt sz\u00fcks\u00e9g. Az ok egyszer\u0171: a k\u00f3d \u00edgy kifejez\u0151bb. A lesz\u00e1rmazottak k\u00f3dj\u00e1t n\u00e9zve az override sz\u00f3 azonnal egy\u00e9rtelm\u0171v\u00e9 teszi, hogy valamelyik \u0151sben ez a m\u0171velet absztrakt vagy virtu\u00e1lis, nem kell valamennyi \u0151s k\u00f3dj\u00e1t ehhez \u00e1ttekinteni. A LedDisplay oszt\u00e1lyunk \u0151se meg van k\u00f6tve, annak k\u00f3dja nem m\u00f3dos\u00edthat\u00f3, \u00edgy nem tudjuk az EquipmentBase -b\u0151l sz\u00e1rmaztatni. A GetAge m\u0171veletet \u00edgy nem tudjuk t\u00f6r\u00f6lni, ez a k\u00f3dduplik\u00e1ci\u00f3 itt megmarad (de csak a LedDisplay eset\u00e9ben, ami csak egy oszt\u00e1ly a sok k\u00f6z\u00fcl!). Megjegyz\u00e9s: val\u00f3j\u00e1ban egy kis plusz munk\u00e1val ett\u0151l a duplik\u00e1ci\u00f3t\u00f3l is meg tudn\u00e1nk szabadulni. Ehhez valamelyik oszt\u00e1lyban (pl. EquipmentBase ) fel kellene venni egy statikus seg\u00e9df\u00fcggv\u00e9nyt, mely param\u00e9terben megkapn\u00e1 a gy\u00e1rt\u00e1si \u00e9vet, \u00e9s visszaadn\u00e1 az \u00e9letkort. Az EquipmentBase.GetAge \u00e9s a LedDisplay.GetAge ezt a seg\u00e9df\u00fcggv\u00e9nyt haszn\u00e1ln\u00e1 kimenete el\u0151\u00e1ll\u00edt\u00e1s\u00e1ra. A LedDisplay oszt\u00e1lyunkban ad\u00f3sak vagyunk m\u00e9g a GetDescription meg\u00edr\u00e1s\u00e1val: public class LedDisplay : DisplayBase , IEquipment { \u2026 public string GetDescription () { return \"LedDisplay\" ; } } Figyelj\u00fck meg, hogy itt NEM adtuk meg az override kulcssz\u00f3t. Mikor egy interf\u00e9sz f\u00fcggv\u00e9nyt implement\u00e1lunk, az override-ot nem kell/szabad ki\u00edrni. M\u00f3dos\u00edtsuk az EquipmentInventory.ListAll m\u0171velet\u00e9t, hogy az elemek le\u00edr\u00e1s\u00e1t is \u00edrja ki a kimenetre: public void ListAll () { foreach ( IEquipment eq in equipment ) { Console . WriteLine ( $\"Le\u00edr\u00e1s: {eq.GetDescription()}\\t\" + $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\" ); } } \u00cdgy m\u00e1r sokkal informat\u00edvabb kimetet kapunk az alkalmaz\u00e1s futtat\u00e1sakor: A k\u00f3dunkat \u00e1ttekintve m\u00e9g egy helyen tal\u00e1lunk k\u00f3dduplik\u00e1ci\u00f3t. Valamennyi EquipmentBase lesz\u00e1rmazott ( HardDisk , SoundCard ) konstruktor\u00e1ban ott van ez a k\u00e9t sor: this . yearOfCreation = yearOfCreation ; this . newPrice = newPrice ; Ha belegondolunk, ezek a yearOfCreatio \u00e9s newPrice tagok az \u0151sben vannak defini\u00e1lva, \u00edgy egy\u00e9bk\u00e9nt is az \u0151 felel\u0151ss\u00e9ge kellene legyen ezek inicializ\u00e1l\u00e1sa. Vegy\u00fcnk is fel egy megfelel\u0151 konstruktort az EquipmentBase -ben: public abstract class EquipmentBase : IEquipment { \u2026 public EquipmentBase ( int yearOfCreation , int newPrice ) { this . yearOfCreation = yearOfCreation ; this . newPrice = newPrice ; } \u2026 } A HardDisk \u00e9s SoundCard lesz\u00e1rmazottak konstruktor\u00e1nak t\u00f6rzs\u00e9b\u0151l vegy\u00fck ki a k\u00e9t tag inicializ\u00e1l\u00e1s\u00e1t, helyette a base kulcssz\u00f3val hivatkozva h\u00edvjuk meg az \u0151s konstruktor\u00e1t: public class HardDisk : EquipmentBase { \u2026 public HardDisk ( int yearOfCreation , int newPrice , int capacityGB ): base ( yearOfCreation , newPrice ) { this . capacityGB = capacityGB ; } \u2026 } public class SoundCard : EquipmentBase { \u2026 public SoundCard ( int yearOfCreation , int newPrice ): base ( yearOfCreation , newPrice ) { } \u2026 }","title":"3. Feladat - Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja"},{"location":"labor/1-model-es-kod-kapcsolata/#ertekeles","text":"Az interf\u00e9sz \u00e9s absztrakt \u0151s egy\u00fcttes haszn\u00e1lat\u00e1val siker\u00fclt a legkevesebb kompromisszummal j\u00e1r\u00f3 megold\u00e1st kidolgoznunk: IEquipment interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk kezelni az alkatr\u00e9szek valamennyi t\u00edpus\u00e1t, m\u00e9g azokat is, melyekn\u00e9l az \u0151soszt\u00e1ly meg volt k\u00f6tve (puszt\u00e1n absztrakt \u0151s haszn\u00e1lat\u00e1val ezt nem tudtuk volna el\u00e9rni). Az EquipmentBase absztrakt \u0151s bevezet\u00e9s\u00e9vel egy kiv\u00e9telt\u0151l eltekintve a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szt\u00edpusokra k\u00f6z\u00f6s k\u00f3dot fel tudtuk vinni egy k\u00f6z\u00f6s \u0151sbe, \u00edgy el tudtuk ker\u00fclni a k\u00f3dduplik\u00e1ci\u00f3t. Az EquipmentBase absztrakt \u0151s bevezet\u00e9s\u00e9vel alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni az \u00fajonnan bevezetett IEquipment m\u0171veletek eset\u00e9ben (pl. GetDescripton ), \u00edgy nem vagyunk r\u00e1k\u00e9nyszer\u00edtve, hogy minden IEquipment implement\u00e1ci\u00f3s oszt\u00e1lyban meg kelljen azt adni. Z\u00e1r\u00e1sk\u00e9ppen vess\u00fcnk egy pillant\u00e1st megold\u00e1sunk UML (szer\u0171) oszt\u00e1lydiagramj\u00e1ra:","title":"\u00c9rt\u00e9kel\u00e9s"},{"location":"labor/1-model-es-kod-kapcsolata/#megjegyzes-opcionalis-hazi-gyakorlo-feladat","text":"Jelen megold\u00e1sunk nem t\u00e1mogatja az alkatr\u00e9szspecifikus adatok (pl. HardDisk eset\u00e9ben a kapacit\u00e1s) megjelen\u00edt\u00e9s\u00e9t a list\u00e1z\u00e1s sor\u00e1n. Ahhoz, hogy ezt meg tudjuk tenni, az alkatr\u00e9sz adatok form\u00e1zott stringbe \u00edr\u00e1s\u00e1t az EqipmentInventory oszt\u00e1lyb\u00f3l az alkatr\u00e9sz oszt\u00e1lyokba kellene vinni, a k\u00f6vetkez\u0151 elveknek megfelel\u0151en: Bevezethet\u00fcnk ehhez az IEquipment interf\u00e9szbe egy GetFormattedString m\u0171veletet, mely egy string t\u00edpus\u00fa objektummal t\u00e9r vissza. Alternat\u00edv megold\u00e1s lehet, ha a System.Object ToString() m\u0171velet\u00e9t defini\u00e1ljuk fel\u00fcl. .NET-ben ugyanis minden t\u00edpus implicit m\u00f3don a System.Object -b\u0151l sz\u00e1rmazik, aminek van egy virtu\u00e1lis ToString() m\u0171velete. Az EquipmentBase -ben meg\u00edrjuk a k\u00f6z\u00f6s tagok (le\u00edr\u00e1s, \u00e1r, kor) stringbe form\u00e1z\u00e1s\u00e1t. Amennyiben egy alkatr\u00e9sz t\u00edpusspecifikus adattal is rendelkezik, akkor oszt\u00e1ly\u00e1ban override-oljuk a stringbe form\u00e1z\u00f3 f\u00fcggv\u00e9nyt: ennek a f\u00fcggv\u00e9nynek egyr\u00e9szt meg kell h\u00edvnia az \u0151s v\u00e1ltozat\u00e1t (a base kulcssz\u00f3 haszn\u00e1lat\u00e1val), majd ehhez hozz\u00e1 kell f\u0171zni a saj\u00e1t form\u00e1zott adatait, \u00e9s ezzel a stringgel kell visszat\u00e9rnie.","title":"Megjegyz\u00e9s - opcion\u00e1lis h\u00e1zi gyakorl\u00f3 feladat"},{"location":"labor/2-nyelvi-eszkozok/","text":"2. Nyelvi eszk\u00f6z\u00f6k \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: K\u0151v\u00e1ri Bence, Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja az al\u00e1bbi C# nyelvi elemek megismer\u00e9se: Tulajdons\u00e1g (property) Deleg\u00e1t (delegate, met\u00f3dusreferencia) Esem\u00e9ny (event) Attrib\u00fatum (attribute) Lambda kifejez\u00e9s Generikus t\u00edpus (generic type) Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: a 2. el\u0151ad\u00e1s \u00e9s a 3. el\u0151ad\u00e1s eleje \u2013 (Modern) programoz\u00e1si eszk\u00f6z\u00f6k. El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Bevezet\u0151 \u00b6 A gyakorlat sor\u00e1n a hallgat\u00f3k megismerkednek a legfontosabb modern, a .NET k\u00f6rnyezetben is rendelkez\u00e9sre \u00e1ll\u00f3 nyelvi eszk\u00f6z\u00f6kkel. Felt\u00e9telezz\u00fck, hogy a hallgat\u00f3 a kor\u00e1bbi tanulm\u00e1nyai sor\u00e1n elsaj\u00e1t\u00edtotta az objektum-orient\u00e1lt szeml\u00e9letm\u00f3dot, \u00e9s tiszt\u00e1ban van az objektum-orient\u00e1lt alapfogalmakkal. Jelen gyakorlat sor\u00e1n azokra a .NET-es nyelvi elemekre koncentr\u00e1lunk, amelyek t\u00falmutatnak az \u00e1ltal\u00e1nos objektum-orient\u00e1lt szeml\u00e9leten, ugyanakkor nagyban hozz\u00e1j\u00e1rulnak a j\u00f3l \u00e1tl\u00e1that\u00f3 \u00e9s k\u00f6nnyen karbantarthat\u00f3 k\u00f3d elk\u00e9sz\u00edt\u00e9s\u00e9hez. Ezek a k\u00f6vetkez\u0151k: Tulajdons\u00e1gok (properties) Deleg\u00e1tok (delegates) Esem\u00e9nyek (events) Attrib\u00fatumok (attributes) Generikus oszt\u00e1lyok (generics) Lambda kifejez\u00e9sek 1. Feladat \u2013 Tulajdons\u00e1g (property) \u00b6 A tulajdons\u00e1gok seg\u00edts\u00e9g\u00e9vel tipikusan (de nem kiz\u00e1r\u00f3lagosan) oszt\u00e1lyok tagv\u00e1ltoz\u00f3ihoz f\u00e9rhet\u00fcnk hozz\u00e1 szintaktikailag hasonl\u00f3 m\u00f3don, mintha egy hagyom\u00e1nyos tagv\u00e1ltoz\u00f3t \u00e9rn\u00e9nk el. A hozz\u00e1f\u00e9r\u00e9s sor\u00e1n azonban lehet\u0151s\u00e9g\u00fcnk van arra, hogy az egyszer\u0171 \u00e9rt\u00e9k lek\u00e9rdez\u00e9s vagy be\u00e1ll\u00edt\u00e1s helyett met\u00f3dusszer\u0171en implement\u00e1ljuk a v\u00e1ltoz\u00f3 el\u00e9r\u00e9s\u00e9nek a m\u00f3dj\u00e1t. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy Person nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy embert reprezent\u00e1l. K\u00e9t tagv\u00e1ltoz\u00f3ja van, name \u00e9s age . A tagv\u00e1ltoz\u00f3khoz k\u00f6zvetlen\u00fcl nem f\u00e9rhet\u00fcnk hozz\u00e1 (mivel priv\u00e1tok), csak a Name , illetve Age publikus tulajdons\u00e1gokon kereszt\u00fcl kezelhetj\u00fck \u0151ket. A p\u00e9lda j\u00f3l szeml\u00e9lteti, hogy a .NET-es tulajdons\u00e1gok egy\u00e9rtelm\u0171en megfelelnek a C++-b\u00f3l \u00e9s Java-b\u00f3l m\u00e1r j\u00f3l ismert SetX(\u2026) illetve GetX() t\u00edpus\u00fa met\u00f3dusoknak, csak itt ez a megold\u00e1s egys\u00e9gbez\u00e1rtabb m\u00f3don nyelvi szinten t\u00e1mogatott. Hozzunk l\u00e9tre egy \u00faj C# konzolos alkalmaz\u00e1st. .NET Core alap\u00fat, vagyis ne .NET Framework-\u00f6set: Erre az els\u0151 gyakorlat alkalm\u00e1val l\u00e1ttunk p\u00e9ld\u00e1t, le\u00edr\u00e1sa annak \u00fatmutat\u00f3j\u00e1ban szerepel. A \" Do not use top level statements \" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be a projekt l\u00e9trehoz\u00e1s sor\u00e1n. Adjunk hozz\u00e1 egy \u00faj oszt\u00e1lyt az alkalmaz\u00e1sunkhoz Person n\u00e9ven. (\u00daj oszt\u00e1ly hozz\u00e1ad\u00e1s\u00e1hoz a Solution Explorerben kattintsunk jobb eg\u00e9rgombbal a projekt f\u00e1jlra \u00e9s v\u00e1lasszuk az \u201eAdd / class\u201d men\u00fcpontot. Az el\u0151ugr\u00f3 ablakban a l\u00e9trehozand\u00f3 f\u00e1jl nev\u00e9t m\u00f3dos\u00edtsuk Person.cs -re, majd nyomjuk meg az Add gombot.) Tegy\u00fck az oszt\u00e1lyt publikuss\u00e1. Ehhez az oszt\u00e1ly neve el\u00e9 be kell \u00edrni a public kulcssz\u00f3t. Erre a m\u00f3dos\u00edt\u00e1sra itt val\u00f3j\u00e1ban m\u00e9g nem volna sz\u00fcks\u00e9g, ugyanakkor a 4. feladat m\u00e1r egy publikus oszt\u00e1lyt fog ig\u00e9nyelni. Hozzunk l\u00e9tre az oszt\u00e1lyon bel\u00fcl egy int t\u00edpus\u00fa age nev\u0171 mez\u0151t \u00e9s egy ezt el\u00e9rhet\u0151v\u00e9 tev\u0151 Age tulajdons\u00e1got. public class Person { private int age ; public int Age { get { return age ; } set { age = value ; } } } Eg\u00e9sz\u00edts\u00fck ki a Program.cs f\u00e1jl Main f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj oszt\u00e1lyunkat. static void Main ( string [] args ) { Person p = new Person (); p . Age = 17 ; p . Age ++; Console . WriteLine ( p . Age ); } Futtassuk a programunkat (F5) L\u00e1thatjuk, hogy a tulajdons\u00e1g a tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an haszn\u00e1lhat\u00f3. A tulajdons\u00e1g lek\u00e9rdez\u00e9se eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt get r\u00e9sz fog lefutni, \u00e9s a tulajdons\u00e1g \u00e9rt\u00e9ke a return \u00e1ltal visszaadott \u00e9rt\u00e9k lesz. A tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sa eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt set r\u00e9sz fog lefutni, \u00e9s a speci\u00e1lis value v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke ebben a szakaszban megfelel a tulajdons\u00e1gnak \u00e9rt\u00e9k\u00fcl adott kifejez\u00e9ssel. Figyelj\u00fck meg a fenti megold\u00e1sban azt, hogy milyen eleg\u00e1nsan tudjuk egy \u00e9vvel megemelni az ember \u00e9letkor\u00e1t. Java, vagy C++ k\u00f3dban egy hasonl\u00f3 m\u0171veletet a p.setAge(p.getAge()+1) form\u00e1ban \u00edrhattunk volna le, amely jelent\u0151sen k\u00f6r\u00fclm\u00e9nyesebb \u00e9s nehezen olvashat\u00f3bb szintaktika a fentin\u00e9l. A tulajdons\u00e1gok haszn\u00e1lat\u00e1nak legf\u0151bb hozad\u00e9ka, hogy k\u00f3dunk szintaktikailag tiszt\u00e1bb lesz, az \u00e9rt\u00e9kad\u00e1sok illetve lek\u00e9rdez\u00e9sek pedig az esetek t\u00f6bbs\u00e9g\u00e9ben j\u00f3l elv\u00e1lnak a t\u00e9nyleges f\u00fcggv\u00e9nyh\u00edv\u00e1sokt\u00f3l. Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a programunk val\u00f3ban elv\u00e9gzi a get \u00e9s set r\u00e9szek h\u00edv\u00e1s\u00e1t. Ehhez helyezz\u00fcnk t\u00f6r\u00e9spontokat (breakpoint) a getter \u00e9s setter blokkok belsej\u00e9be a k\u00f3dszerkeszt\u0151 bal sz\u00e9l\u00e9n l\u00e1that\u00f3 sz\u00fcrke s\u00e1vra kattintva. Futtassuk a programot l\u00e9p\u00e9sr\u0151l l\u00e9p\u00e9sre. Ehhez a programot F5 helyett az F11 billenty\u0171vel ind\u00edtsuk, majd az F11 tov\u00e1bbi megnyom\u00e1saival engedj\u00fck sorr\u00f3l sorra a v\u00e9grehajt\u00e1st. L\u00e1thatjuk, hogy a programunk val\u00f3ban minden egyes alkalommal megh\u00edvja a gettert, amikor \u00e9rt\u00e9klek\u00e9rdez\u00e9s, illetve a settert, amikor \u00e9rt\u00e9kbe\u00e1ll\u00edt\u00e1s t\u00f6rt\u00e9nik. A setter f\u00fcggv\u00e9nyek egyik fontos funkci\u00f3ja, hogy lehet\u0151s\u00e9get k\u00edn\u00e1lnak az \u00e9rt\u00e9kvalid\u00e1ci\u00f3ra. Eg\u00e9sz\u00edts\u00fck ki ennek szellem\u00e9ben az Age tulajdons\u00e1g setter-\u00e9t. public int Age { get { return age ; } set { if ( value < 0 ) throw new Exception ( \"\u00c9rv\u00e9nytelen \u00e9letkor!\" ); age = value ; } } Figyelj\u00fck meg, hogy m\u00edg az egyszer\u0171 getter \u00e9s setter eset\u00e9ben az \u00e9rt\u00e9klek\u00e9rdez\u00e9st/be\u00e1ll\u00edt\u00e1st egy sorban tartjuk, addig komplexebb t\u00f6rzs eset\u00e9n m\u00e1r t\u00f6bb sorra t\u00f6rdelj\u00fck. Az alkalmaz\u00e1s tesztel\u00e9s\u00e9hez rendelj\u00fcnk hozz\u00e1 negat\u00edv \u00e9rt\u00e9ket az \u00e9letkorhoz a Program oszt\u00e1ly Main f\u00fcggv\u00e9ny\u00e9ben. p . Age = - 2 ; Futtassuk a programot, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy az ellen\u0151rz\u00e9s helyesen m\u0171k\u00f6dik, majd a tov\u00e1bbi munka kedv\u00e9\u00e9rt h\u00e1r\u00edtsuk el a hib\u00e1t azzal, hogy pozit\u00edvra cser\u00e9lj\u00fck a be\u00e1ll\u00edtott \u00e9letkort. p . Age = 2 ; A mindennapi munk\u00e1nk sor\u00e1n tal\u00e1lkozhatunk a tulajdons\u00e1goknak egy sokkal t\u00f6m\u00f6rebb szintaktik\u00e1j\u00e1val is. Ez a szintaktika akkor alkalmazhat\u00f3, ha egy olyan tulajdons\u00e1got szeretn\u00e9nk l\u00e9trehozni, melyben: nincs sz\u00fcks\u00e9g\u00fcnk a priv\u00e1t tagv\u00e1ltoz\u00f3 k\u00f6zvetlen el\u00e9r\u00e9s\u00e9re nem szeretn\u00e9nk semmilyen kieg\u00e9sz\u00edt\u0151 logik\u00e1val ell\u00e1tni a getter \u00e9s setter met\u00f3dusokat Erre n\u00e9zz\u00fcnk a k\u00f6vetkez\u0151kben p\u00e9ld\u00e1t. Eg\u00e9sz\u00edts\u00fck ki a Person oszt\u00e1lyunkat egy ilyen, \u00fan. \u201eautoimplement\u00e1lt\u201d tulajdons\u00e1ggal (auto-implemented property) . Sz\u00farjuk be a k\u00f6vetkez\u0151 sort k\u00f6zvetlen\u00fcl az Age tulajdons\u00e1g z\u00e1r\u00f3 kapcsos z\u00e1r\u00f3jel\u00e9t k\u00f6vet\u0151en: public string Name { get ; set ; } Autoimplemet\u00e1lt tulajdons\u00e1g eset\u00e9n a ford\u00edt\u00f3 egy rejtett, k\u00f3db\u00f3l nem el\u00e9rhet\u0151 v\u00e1ltoz\u00f3t gener\u00e1l az oszt\u00e1lyba, mely a tulajdons\u00e1g aktu\u00e1lis \u00e9rt\u00e9k\u00e9nek t\u00e1rol\u00e1s\u00e1ra szolg\u00e1l. Most ellen\u0151rizz\u00fck a m\u0171k\u00f6d\u00e9s\u00e9t a Main f\u00fcggv\u00e9ny kieg\u00e9sz\u00edt\u00e9s\u00e9vel. static void Main ( string [] args ) { \u2026 p . Name = \"Luke\" ; \u2026 Console . WriteLine ( p . Name ); } Note A tov\u00e1bbi feladatok \u00e9p\u00edteni fognak az el\u0151z\u0151 feladatok v\u00e9geredm\u00e9nyeire. Ha programod nem fordul le, vagy nem megfelel\u0151en m\u0171k\u00f6dik, jelezd ezt a gyakorlatvezet\u0151dnek a feladatok v\u00e9g\u00e9n, \u00e9s seg\u00edt elh\u00e1r\u00edtani a hib\u00e1t. 2. Feladat \u2013 Deleg\u00e1t (delegate, met\u00f3dusreferencia) \u00b6 A deleg\u00e1tok t\u00edpusos met\u00f3dusreferenci\u00e1kat jelentenek .NET-ben, a C/C++ f\u00fcggv\u00e9nypointerek modern megfelel\u0151i. Egy deleg\u00e1t defini\u00e1l\u00e1s\u00e1val egy olyan v\u00e1ltoz\u00f3t defini\u00e1lunk, amellyel r\u00e1mutathatunk egy olyan met\u00f3dusra, amely t\u00edpusa (param\u00e9terlist\u00e1ja \u00e9s visszat\u00e9r\u00e9si \u00e9rt\u00e9ke) megfelel a deleg\u00e1t t\u00edpus\u00e1nak. A deleg\u00e1t megh\u00edv\u00e1s\u00e1val az \u00e9rt\u00e9k\u00fcl adott (beregisztr\u00e1lt) met\u00f3dus automatikusan megh\u00edv\u00f3dik. A deleg\u00e1tok haszn\u00e1lat\u00e1nak egyik el\u0151nye az, hogy fut\u00e1si id\u0151ben d\u00f6nthetj\u00fck el, hogy t\u00f6bb met\u00f3dus k\u00f6z\u00fcl \u00e9ppen melyiket szeretn\u00e9nk megh\u00edvni. N\u00e9h\u00e1ny p\u00e9lda deleg\u00e1tok haszn\u00e1lat\u00e1ra: egy univerz\u00e1lis sorrendez\u0151 f\u00fcggv\u00e9nynek param\u00e9terk\u00e9nt az elemek \u00f6sszehasonl\u00edt\u00e1s\u00e1t v\u00e9gz\u0151 f\u00fcggv\u00e9ny \u00e1tad\u00e1sa, egy \u00e1ltal\u00e1nos gy\u0171jtem\u00e9nyen univerz\u00e1lis sz\u0171r\u00e9si logika megval\u00f3s\u00edt\u00e1sa, melynek param\u00e9terben egy deleg\u00e1t form\u00e1j\u00e1ban adjuk \u00e1t azt a f\u00fcggv\u00e9nyt, amely eld\u00f6nti, hogy egy elemet bele kell-e venni a sz\u0171rt list\u00e1ba, a publish-subscribe minta megval\u00f3s\u00edt\u00e1sa, amikor bizonyos objektumok m\u00e1s objektumokat \u00e9rtes\u00edtenek bizonyos magukkal kapcsolatos esem\u00e9nyek bek\u00f6vetkez\u00e9s\u00e9r\u0151l. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1nkban lehet\u0151v\u00e9 tessz\u00fck, hogy a kor\u00e1bban l\u00e9trehozott Person oszt\u00e1ly objektumai szabadon \u00e9rtes\u00edthess\u00e9k m\u00e1s oszt\u00e1lyok objektumait arr\u00f3l, ha egy szem\u00e9ly \u00e9letkora megv\u00e1ltozott. Ennek \u00e9rdek\u00e9ben bevezet\u00fcnk egy deleg\u00e1t t\u00edpust ( AgeChangingDelegate ), mely param\u00e9terlist\u00e1j\u00e1ban \u00e1t tudja adni az ember\u00fcnk \u00e9letkor\u00e1nak aktu\u00e1lis, illetve \u00faj \u00e9rt\u00e9k\u00e9t. Ezt k\u00f6vet\u0151en l\u00e9trehozunk egy publikus AgeChangingDelegate t\u00edpus\u00fa mez\u0151t a Person oszt\u00e1lyban, mely lehet\u0151v\u00e9 teszi, hogy egy k\u00fcls\u0151 f\u00e9l megadhassa azt a f\u00fcggv\u00e9nyt, amelyen kereszt\u00fcl az adott Person p\u00e9ld\u00e1ny v\u00e1ltoz\u00e1sair\u00f3l \u00e9rtes\u00edt\u00e9st k\u00e9r. Hozzunk l\u00e9tre egy \u00faj deleg\u00e1t t\u00edpust , mely void visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171, \u00e9s k\u00e9t darab int param\u00e9tert elv\u00e1r\u00f3 f\u00fcggv\u00e9nyre tud hivatkozni. Figyelj\u00fcnk r\u00e1, hogy az \u00faj t\u00edpust a Program oszt\u00e1ly el\u0151tt, k\u00f6zvetlen\u00fcl a n\u00e9vt\u00e9r scope-j\u00e1ban defini\u00e1ljuk! namespace PropertyDemo { public delegate void AgeChangingDelegate ( int oldAge , int newAge ); class Program { \u2026 Az AgeChangingDelegate egy t\u00edpus, mely b\u00e1rhol szerepelhet, ahol t\u00edpus \u00e1llhat (pl. lehet l\u00e9trehozni ez alapj\u00e1n tagv\u00e1ltoz\u00f3t, lok\u00e1lis v\u00e1ltoz\u00f3t, f\u00fcggv\u00e9ny param\u00e9tert stb.). Tegy\u00fck lehet\u0151v\u00e9, hogy a Person objektumai r\u00e1mutathassanak tetsz\u0151leges, a fenti szignat\u00far\u00e1nak megfelel\u0151 f\u00fcggv\u00e9nyre. Ehhez hozzunk l\u00e9tre egy AgeChangingDelegate t\u00edpus\u00fa mez\u0151t a Person oszt\u00e1lyban! class Person { public AgeChangingDelegate AgeChanging ; \u2026 Note Megjegyz\u00e9s: a publikus mez\u0151k\u00e9nt l\u00e9trehozott met\u00f3dusreferencia val\u00f3j\u00e1ban (egyel\u0151re) s\u00e9rti az OO elveket. Erre k\u00e9s\u0151bb visszat\u00e9r\u00fcnk m\u00e9g. H\u00edvjuk meg a f\u00fcggv\u00e9nyt minden alkalommal, amikor az ember\u00fcnk kora megv\u00e1ltozik. Ehhez eg\u00e9sz\u00edts\u00fck ki az Age tulajdons\u00e1g setter\u00e9t a k\u00f6vetkez\u0151kkel. public int Age { get { return age ; } set { if ( value < 0 ) throw new Exception ( \"\u00c9rv\u00e9nytelen \u00e9letkor!\" ); if ( AgeChanging != null ) AgeChanging ( age , value ); age = value ; } } A fenti k\u00f3dr\u00e9szlet sz\u00e1mos fontos szab\u00e1lyt demonstr\u00e1l: A valid\u00e1ci\u00f3s logika \u00e1ltal\u00e1ban megel\u0151zi az \u00e9rtes\u00edt\u00e9si logik\u00e1t. Az \u00e9rtes\u00edt\u00e9si logika jelleg\u00e9t\u0151l f\u00fcgg, hogy az \u00e9rt\u00e9kad\u00e1s el\u0151tt, vagy ut\u00e1n futtatjuk le (ebben az esetben, mivel a \u201echanging\u201d sz\u00f3 egy.folyamatban l\u00e9v\u0151 dologra utal, az \u00e9rtes\u00edt\u00e9s megel\u0151zi az \u00e9rt\u00e9kad\u00e1st) Fel kell k\u00e9sz\u00fcln\u00fcnk r\u00e1, hogy a delegate t\u00edpus\u00fa mez\u0151nkh\u00f6z m\u00e9g senki nem rendelt \u00e9rt\u00e9ket (nincs egy subscriber/el\u0151fizet\u0151 sem). Ilyen esetekben a megh\u00edv\u00e1suk kiv\u00e9telt okozna, ez\u00e9rt megh\u00edv\u00e1s el\u0151tt mindig ellen\u0151rizni kell, hogy a mez\u0151 \u00e9rt\u00e9ke null-e. Az esem\u00e9ny els\u00fct\u00e9sekor a null vizsg\u00e1latot \u00e9s az esem\u00e9ny els\u00fct\u00e9st eleg\u00e1nsabb, t\u00f6m\u00f6rebb form\u00e1ban is meg tudjuk tenni a \u201e ?. \u201d null-conditional oper\u00e1torral: if ( AgeChanging != null ) AgeChanging ( age , value ); helyett AgeChanging ?. Invoke ( age , value ); Ez csak akkor s\u00fcti el az esem\u00e9nyt, ha nem null, egy\u00e9bk\u00e9nt semmit nem csin\u00e1l. Ez C# 6-t\u00f3l kezdve haszn\u00e1lhat\u00f3, de ma m\u00e1r ez a javasolt technika. Ha szigor\u00faan n\u00e9zz\u00fck, akkor csak akkor kellene els\u00fctni az esem\u00e9nyt, ha a kor val\u00f3ban v\u00e1ltozik is, vagyis a property set \u00e1g\u00e1ban meg kellene vizsg\u00e1lni, az \u00faj \u00e9rt\u00e9k egyezik-e a r\u00e9givel. Megold\u00e1s lehet, ha a setter els\u0151 sor\u00e1ban azonnal visszat\u00e9r\u00fcnk, ha az \u00faj \u00e9rt\u00e9k egyezik a r\u00e9givel: if ( age == value ) return ; \u2026 K\u00e9sz vagyunk a Person oszt\u00e1ly k\u00f3dj\u00e1val. T\u00e9rj\u00fcnk \u00e1t az el\u0151fizet\u0151re! Ehhez mindenek el\u0151tt a Program oszt\u00e1lyt kell kieg\u00e9sz\u00edten\u00fcnk egy \u00fajabb f\u00fcggv\u00e9nnyel. class Program { \u2026 static void PersonAgeChanging ( int oldAge , int newAge ) { Console . WriteLine ( oldAge + \" => \" + newAge ); } \u2026 } Tipp: Fokozottan \u00fcgyelj\u00fcnk r\u00e1, hogy az \u00faj f\u00fcggv\u00e9ny a megfelel\u0151 scope-ba ker\u00fclj\u00f6n! V\u00e9gezet\u00fcl iratkozzunk fel a v\u00e1ltoz\u00e1sk\u00f6vet\u00e9sre a Main f\u00fcggv\u00e9nyben! static void Main ( string [] args ) { Person p = new Person (); p . AgeChanging = new AgeChangingDelegate ( PersonAgeChanging ); \u2026 Futtassuk a programot! Figyelj\u00fck meg, hogy az esem\u00e9ny minden egyes setter fut\u00e1skor, \u00edgy az els\u0151 \u00e9rt\u00e9kad\u00e1skor \u00e9s az inkrement\u00e1l\u00e1skor egyar\u00e1nt lefut. A megold\u00e1sunk azonban m\u00e9g fejleszthet\u0151. Eg\u00e9sz\u00edts\u00fck ki a Main f\u00fcggv\u00e9nyt t\u00f6bbsz\u00f6ri feliratkoz\u00e1ssal, majd futtassuk a programot. p . AgeChanging = new AgeChangingDelegate ( PersonAgeChanging ); p . AgeChanging += new AgeChangingDelegate ( PersonAgeChanging ); p . AgeChanging += PersonAgeChanging ; // T\u00f6m\u00f6rebb szintaktika L\u00e1that\u00f3an minden egyes \u00e9rt\u00e9kv\u00e1ltoz\u00e1skor mind a h\u00e1rom beregisztr\u00e1lt/\u201efeliratkozott\u201d f\u00fcggv\u00e9ny lefut. Ez az\u00e9rt lehets\u00e9ges, mert a delegate t\u00edpus\u00fa mez\u0151k val\u00f3j\u00e1ban nem csup\u00e1n egy f\u00fcggv\u00e9ny-referenci\u00e1t, hanem egy f\u00fcggv\u00e9ny-referencia list\u00e1t tartalmaznak (\u00e9s tartanak karban). Figyelj\u00fck meg a fenti harmadik sorban, hogy a f\u00fcggv\u00e9nyreferenci\u00e1kat az el\u0151sz\u00f6r l\u00e1tottn\u00e1l t\u00f6m\u00f6rebb szintaxissal is le\u00edrhatjuk: csak a f\u00fcggv\u00e9ny nev\u00e9t adjuk meg a += oper\u00e1tor ut\u00e1n, a new AgeChangingDelegate(...) n\u00e9lk\u00fcl. Ett\u0151l f\u00fcggetlen\u00fcl ekkor is egy AgeChangingDelegate objektum fogja becsomagolni a PersonAgeChanging f\u00fcggv\u00e9nyeket a sz\u00ednfalak m\u00f6g\u00f6tt. Pr\u00f3b\u00e1ljuk ki a leiratkoz\u00e1st is (szabadon v\u00e1lasztott ponton), majd futtassuk a programot. p . AgeChanging -= PersonAgeChanging ; 3. Feladat \u2013 Esem\u00e9ny (event) \u00b6 Ahogyan a tulajdons\u00e1gok a getter \u00e9s setter met\u00f3dusoknak, addig a fent l\u00e1tott delegate mechanizmus a Java-b\u00f3l ismert Event Listener-eknek k\u00edn\u00e1lj\u00e1k egy a szintaktika tekintet\u00e9ben letisztultabb alternat\u00edv\u00e1j\u00e1t. A fenti megold\u00e1sunk azonban egyel\u0151re m\u00e9g s\u00falyosan s\u00e9rt p\u00e1r OO elvet (egys\u00e9gbez\u00e1r\u00e1s, inform\u00e1ci\u00f3rejt\u00e9s). Ezt az al\u00e1bbi k\u00e9t p\u00e9ld\u00e1val tudjuk demonstr\u00e1lni. Az esem\u00e9nyt val\u00f3j\u00e1ban k\u00edv\u00fclr\u0151l (m\u00e1s oszt\u00e1lyok m\u0171veletib\u0151l) is ki tudjuk v\u00e1ltani. Ez szerencs\u00e9tlen, hisz \u00edgy az esem\u00e9nyre feliratkozott f\u00fcggv\u00e9nyeken kereszt\u00fcl az oszt\u00e1ly nev\u00e9ben hamis adatokat k\u00f6z\u00f6lhet\u00fcnk. Ennek demonstr\u00e1l\u00e1s\u00e1ra sz\u00farjuk be a k\u00f6vetkez\u0151 sort a Main f\u00fcggv\u00e9ny v\u00e9g\u00e9re. p . AgeChanging ( 67 , 12 ); Itt a p szem\u00e9ly objektum vonatkoz\u00e1s\u00e1ban egy \"kamu\" \u00e9letkorv\u00e1ltoz\u00e1s esem\u00e9nyt v\u00e1ltottunk ki a Person , becsapva minden el\u0151fizet\u0151t. A j\u00f3 megold\u00e1s az lenne, ha az esem\u00e9nyt csak a Person oszt\u00e1ly m\u0171veletei tudn\u00e1k kiv\u00e1ltani. B\u00e1r a += \u00e9s a -= tekintettel vannak a list\u00e1ba feliratkozott t\u00f6bbi f\u00fcggv\u00e9nyre, val\u00f3j\u00e1ban az = oper\u00e1torral b\u00e1rmikor fel\u00fcl\u00edrhatjuk (kit\u00f6r\u00f6lhetj\u00fck) m\u00e1sok feliratkoz\u00e1sait. Pr\u00f3b\u00e1ljuk ki ezt is, a k\u00f6vetkez\u0151 sor besz\u00far\u00e1s\u00e1val (k\u00f6zvetlen\u00fcl a fel \u00e9s leiratkoz\u00e1sok ut\u00e1n sz\u00farjuk be). p . AgeChanging = null ; L\u00e1ssuk el az event kulcssz\u00f3val az AgeChanging mez\u0151t Person.cs -ben! class Person { public event AgeChangingDelegate AgeChanging ; \u2026 Az event kulcssz\u00f3 feladata val\u00f3j\u00e1ban az, hogy a fenti k\u00e9t jelens\u00e9get megtiltva visszak\u00e9nyszer\u00edtse programunkat az objektumorient\u00e1lt mederbe. Pr\u00f3b\u00e1ljuk meg leford\u00edtani a programot. L\u00e1tni fogjuk, hogy a ford\u00edt\u00f3 a kor\u00e1bbi kih\u00e1g\u00e1sainkat most m\u00e1r ford\u00edt\u00e1si hibak\u00e9nt kezeli. T\u00e1vol\u00edtsuk el a h\u00e1rom hib\u00e1s k\u00f3dsort (figyelj\u00fck meg, hogy m\u00e1r az els\u0151 k\u00f6zvetlen \u00e9rt\u00e9kad\u00e1s is hib\u00e1nak min\u0151s\u00fcl), majd ford\u00edtsuk le \u00e9s futtassuk az alkalmaz\u00e1sunkat! 4. Feladat \u2013 Attrib\u00fatumok \u00b6 A z attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel deklarat\u00edv m\u00f3don metaadatokkal l\u00e1thatjuk el forr\u00e1sk\u00f3dunkat . Az attrib\u00fatum is tulajdonk\u00e9ppen egy oszt\u00e1ly, melyet hozz\u00e1k\u00f6t\u00fcnk a program egy megadott elem\u00e9hez (t\u00edpushoz, oszt\u00e1lyhoz, interf\u00e9szhez, met\u00f3dushoz, \u2026). Ezeket a metainform\u00e1ci\u00f3kat a program fut\u00e1sa k\u00f6zben b\u00e1rki (ak\u00e1r mi magunk is) kiolvashatja az \u00fagynevezett reflection mechanizmus seg\u00edts\u00e9g\u00e9vel. Az attrib\u00fatumok a Java annot\u00e1ci\u00f3k .NET-beli megfelel\u0151inek is tekinthet\u0151k. A NET sz\u00e1mos be\u00e9p\u00edtett attrib\u00fatumot defini\u00e1l, melyek funkci\u00f3ja a legk\u00fcl\u00f6nb\u00f6z\u0151bb f\u00e9le lehet. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban haszn\u00e1lt attrib\u00fatumok p\u00e9ld\u00e1ul az XML soros\u00edt\u00f3val (serializer k\u00f6z\u00f6lnek k\u00fcl\u00f6nb\u00f6z\u0151 metainform\u00e1ci\u00f3kat. Sz\u00farjuk be a Main f\u00fcggv\u00e9ny v\u00e9g\u00e9re a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletet, majd futtassuk a programunkat! XmlSerializer serializer = new XmlSerializer ( typeof ( Person )); FileStream stream = new FileStream ( \"person.txt\" , FileMode . Create ); serializer . Serialize ( stream , p ); stream . Close (); // Process.Start(\"person.txt\"); A fenti p\u00e9ld\u00e1b\u00f3l az utols\u00f3 sor nem a soros\u00edt\u00f3 logika r\u00e9sze, csup\u00e1n egy frapp\u00e1ns megold\u00e1s arra, hogy a Windows alap\u00e9rtelmezett sz\u00f6vegf\u00e1jl n\u00e9zeget\u0151j\u00e9vel megnyissuk a keletkezett adat\u00e1llom\u00e1nyt. Ezt kipr\u00f3b\u00e1lhatjuk, de a haszn\u00e1lt .NET runtime-t\u00f3l \u00e9s az oper\u00e1ci\u00f3s rendszer\u00fcnkt\u0151l f\u00fcgg, t\u00e1mogatott-e. Ha nem, fut\u00e1s k\u00f6zben hib\u00e1t kapunk. Ez esetben hagyjuk kikommentezve, \u00e9s a person.txt f\u00e1jlt a f\u00e1jlrendszerben megkeresve k\u00e9zzel nyissuk meg (a Visual Studio mapp\u00e1nkban a \\bin\\Debug\\ alatt tal\u00e1lhat\u00f3 az .exe alkalmaz\u00e1sunk mellett. N\u00e9zz\u00fck meg a keletkezett f\u00e1jl szerkezet\u00e9t. Figyelj\u00fck meg, hogy minden tulajdons\u00e1g a nev\u00e9nek megfelel\u0151 XML elemre lett lek\u00e9pezve. .NET attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel olyan metaadatokkal l\u00e1thatjuk el a Person oszt\u00e1lyunkat, melyek k\u00f6zvetlen\u00fcl m\u00f3dos\u00edtj\u00e1k a soros\u00edt\u00f3 viselked\u00e9s\u00e9t. Az XmlRoot attrib\u00fatum lehet\u0151s\u00e9get k\u00edn\u00e1l a gy\u00f6k\u00e9relem \u00e1tnevez\u00e9s\u00e9re. Helyezz\u00fck el a Person oszt\u00e1ly f\u00f6l\u00e9! [XmlRoot(\"Szem\u00e9ly\")] public class Person { ... } Az XmlAttribute attrib\u00fatum jelzi a soros\u00edt\u00f3 sz\u00e1m\u00e1ra, hogy a jel\u00f6lt tulajdons\u00e1got ne xml elemre, hanem xml attrib\u00fatumra k\u00e9pezze le. L\u00e1ssuk el ezzel az Age tulajdons\u00e1got! [XmlAttribute(\"Kor\")] public int Age Az XmlIgnore attrib\u00fatum jelzi a soros\u00edt\u00f3nak, hogy a jel\u00f6lt tulajdons\u00e1g teljesen elhagyand\u00f3 az eredm\u00e9nyb\u0151l. Pr\u00f3b\u00e1ljuk ki a Name tulajdons\u00e1g f\u00f6l\u00f6tt. [XmlIgnore] public string Name { get ; set ; } Futtassuk az alkalmaz\u00e1sunkat! Hasonl\u00edtsuk \u00f6ssze az eredm\u00e9nyt a kor\u00e1bbiakkal. 5. Feladat \u2013 Deleg\u00e1t 2. \u00b6 A 2. \u00e9s 3. feladatokban a deleg\u00e1tokkal esem\u00e9ny alap\u00fa \u00fczenetk\u00fcld\u00e9st val\u00f3s\u00edtottunk meg. A deleg\u00e1tok haszn\u00e1lat\u00e1nak m\u00e1sik tipikus eset\u00e9ben a f\u00fcggv\u00e9nyreferenci\u00e1kat arra haszn\u00e1ljuk, hogy egy algoritmus vagy \u00f6sszetettebb m\u0171velet sz\u00e1m\u00e1ra egy el\u0151re nem defini\u00e1lt l\u00e9p\u00e9s implement\u00e1ci\u00f3j\u00e1t \u00e1tadjuk . A generikus lista oszt\u00e1ly ( List<T> ) FindAll f\u00fcggv\u00e9nye p\u00e9ld\u00e1ul k\u00e9pes arra, hogy visszaadjon egy \u00faj list\u00e1ban minden olyan elemet, mely egy adott felt\u00e9telnek eleget tesz. A konkr\u00e9t sz\u0171r\u00e9si felt\u00e9telt egy f\u00fcggv\u00e9ny form\u00e1j\u00e1ban adhatjuk meg param\u00e9terben (melyet a FindAll minden elemre megh\u00edv), mely igazat ad minden olyan elemre, amit az eredm\u00e9nylist\u00e1ban szeretn\u00e9nk l\u00e1tni. A f\u00fcggv\u00e9ny t\u00edpusa a k\u00f6vetkez\u0151 el\u0151re defini\u00e1lt delegate t\u00edpus: public delegate bool Predicate < T >( T obj ) Vagyis bemenetk\u00e9nt egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t v\u00e1r, mint a listaelemek t\u00edpusa, kimenetk\u00e9nt pedig egy logikai \u00e9rt\u00e9ket. A fentiek demonstr\u00e1l\u00e1s\u00e1ra kieg\u00e9sz\u00edtj\u00fck a kor\u00e1bbi programunkat egy sz\u0171r\u00e9ssel, mely a list\u00e1b\u00f3l csak a p\u00e1ratlan elemeket fogja megtartani. Val\u00f3s\u00edtsunk meg egy olyan sz\u0171r\u0151f\u00fcggv\u00e9nyt az alkalmaz\u00e1sunkban, amely a p\u00e1ratlan sz\u00e1mokat adja vissza: static bool MyFilter ( int n ) { return n % 2 == 1 ; } Eg\u00e9sz\u00edts\u00fck ki a kor\u00e1bban \u00edrt k\u00f3dunkat a sz\u0171r\u0151 f\u00fcggv\u00e9ny\u00fcnk haszn\u00e1lat\u00e1val: List < int > list = new List < int >(); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); list = list . FindAll ( MyFilter ); foreach ( int n in list ) { Console . WriteLine ( $\"Value: {n}\" ); } Futtassuk az alkalmaz\u00e1sunkat. Figyelj\u00fck meg, hogy a konzolon val\u00f3ban csak a p\u00e1ratlan sz\u00e1mok jelennek meg. \u00c9rdekess\u00e9gk\u00e9nt elhelyezhet\u00fcnk egy t\u00f6r\u00e9spontot (breakpoint) a MyFilter f\u00fcggv\u00e9ny\u00fcnk belsej\u00e9ben \u00e9s megfigyelhetj\u00fck, hogy a f\u00fcggv\u00e9ny val\u00f3ban minden egyes listaelemre k\u00fcl\u00f6n-k\u00fcl\u00f6n megh\u00edv\u00f3dik. 6. Feladat \u2013 Lambda kifejez\u00e9sek \u00b6 Az \u00e9rintett t\u00e9mak\u00f6r\u00f6k az el\u0151ad\u00e1sanyagban r\u00e9szletesen szerepelnek, itt nem ism\u00e9telj\u00fck meg \u0151ket L\u00e1sd \u201eEl\u0151ad\u00e1s 02 - Modern nyelvi eszk\u00f6z\u00f6k.pdf\u201d dokumentum \u201eLambda expression (lambda kifejez\u00e9s)\u201d fejezete. A kulcselem a => (lambda oper\u00e1tor) seg\u00edts\u00e9g\u00e9vel lambda kifejez\u00e9sek , vagyis n\u00e9vtelen f\u00fcggv\u00e9nyek defini\u00e1l\u00e1sa. Note A .NET be\u00e9p\u00edtett Func \u00e9s Action generikus delegate t\u00edpusokra itt id\u0151 hi\u00e1ny\u00e1\u00e9ban nem t\u00e9r\u00fcnk ki. Az el\u0151z\u0151, 5. feladatot oldjuk meg a k\u00f6vetkez\u0151k\u00e9ppen: ne adjunk meg k\u00fcl\u00f6n sz\u0171r\u0151f\u00fcggv\u00e9nyt, hanem a sz\u0171r\u00e9si logik\u00e1t egy lambda kifejez\u00e9s form\u00e1j\u00e1ban adjuk meg a FindAll m\u0171veletnek. Ehhez mind\u00f6ssze egy sort kell megv\u00e1ltoztatni: list = list . FindAll ( ( int n ) => { return n % 2 == 1 ; } ); Egy n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyt defini\u00e1ltunk \u00e9s adtunk \u00e1t a FindAll m\u0171veletnek: Ez egy lambda kifejez\u00e9s A => bal oldal\u00e1n megadtuk a m\u0171velet param\u00e9tereket (itt csak egy volt) A => jobb oldal\u00e1n a m\u0171velet t\u00f6rzs\u00e9t (ugyanaz, mint a kor\u00e1bbi MyFilter t\u00f6rzse) A fenti sort j\u00f3val egyszer\u0171bb \u00e9s \u00e1ttekinthet\u0151bb form\u00e1ba is \u00edrhatjuk: list = list . FindAll ( n => n % 2 == 1 ); A k\u00f6vetkez\u0151 egyszer\u0171s\u00edt\u00e9seket eszk\u00f6z\u00f6lt\u00fck: A param\u00e9ter t\u00edpus\u00e1t nem \u00edrtuk ki (a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni a FindAll delegate param\u00e9ter t\u00edpus\u00e1b\u00f3l) A param\u00e9ter k\u00f6r\u00fcli z\u00e1r\u00f3jelet elhagyhattuk ( mert csak egy param\u00e9ter van) A => jobb oldal\u00e1n elhagyhattuk a {} z\u00e1r\u00f3jeleket \u00e9s a return -t (mert egyetlen kifejez\u00e9sb\u0151l \u00e1llt a f\u00fcggv\u00e9ny t\u00f6rzse, mellyel a f\u00fcggv\u00e9ny visszat\u00e9r) 7. Feladat \u2013 Generikus oszt\u00e1lyok \u00b6 Megjegyz\u00e9s: erre a feladatra j\u00f3 es\u00e9llyel nem marad id\u0151. Ez esetben c\u00e9lszer\u0171 a feladatot gyakorl\u00e1sk\u00e9ppen otthon elv\u00e9gezni. A .NET generikus oszt\u00e1lyai megfelelnek a C++ nyelv template oszt\u00e1lyainak (noha vannak jelent\u0151sebb k\u00fcl\u00f6nbs\u00e9gek a m\u0171k\u00f6d\u00e9s\u00fckben). A seg\u00edts\u00e9g\u00fckkel \u00e1ltal\u00e1nos (t\u00f6bb t\u00edpusra is m\u0171k\u00f6d\u0151), de ugyanakkor t\u00edpusbiztos oszt\u00e1lyokat hozhatunk l\u00e9tre. Generikus oszt\u00e1lyok n\u00e9lk\u00fcl, ha \u00e1ltal\u00e1nosan szeretn\u00e9nk kezelni egy probl\u00e9m\u00e1t, akkor object t\u00edpus\u00fa adatokat haszn\u00e1lunk (mert .NET-ben minden oszt\u00e1ly az object oszt\u00e1lyb\u00f3l sz\u00e1rmazik). Ez a helyzet p\u00e9ld\u00e1ul az ArrayList -tel is, ami egy \u00e1ltal\u00e1nos c\u00e9l\u00fa gy\u0171jtem\u00e9ny, tetsz\u0151leges, object t\u00edpus\u00fa elemek t\u00e1rol\u00e1s\u00e1ra alkalmas. L\u00e1ssunk egy p\u00e9ld\u00e1t az ArrayList haszn\u00e1lat\u00e1ra: ArrayList list = new ArrayList (); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); for ( int n = 0 ; n < list . Count ; n ++) { // Castolni kell, k\u00fcl\u00f6nben nem fordul int i = ( int ) list [ n ]; Console . WriteLine ( $\"Value: {i}\" ); } A fenti megold\u00e1ssal a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k ad\u00f3dnak: Az ArrayList minden egyes elemet object -k\u00e9nt t\u00e1rol. Amikor hozz\u00e1 szeretn\u00e9nk f\u00e9rni a lista egy elem\u00e9hez, mindig a megfelel\u0151 t\u00edpus\u00fav\u00e1 kell cast-olni. Nem t\u00edpusbiztos. A fenti p\u00e9ld\u00e1ban semmi nem akad\u00e1lyoz meg abban (\u00e9s semmilyen hiba\u00fczenet sem jelzi), hogy az int t\u00edpus\u00fa adatok mell\u00e9 besz\u00farjunk a list\u00e1ba egy m\u00e1sik t\u00edpus\u00fa objektumot. Ilyenkor csak a lista bej\u00e1r\u00e1sa sor\u00e1n kapn\u00e1nk hib\u00e1t, amikor a nem int t\u00edpust int t\u00edpus\u00fara pr\u00f3b\u00e1lunk castolni. Generikus gy\u0171jtem\u00e9nyek haszn\u00e1latakor az ilyen hib\u00e1k m\u00e1r a ford\u00edt\u00e1s sor\u00e1n kider\u00fclnek. \u00c9rt\u00e9k t\u00edpus\u00fa adatok t\u00e1rol\u00e1sakor a lista lassabban m\u0171k\u00f6dik, mert az \u00e9rt\u00e9k t\u00edpust el\u0151sz\u00f6r be kell dobozolni (boxing), hogy az object -k\u00e9nt (azaz referencia t\u00edpusk\u00e9nt) t\u00e1rolhat\u00f3 legyen. A fenti probl\u00e9ma megold\u00e1sa egy generikus lista haszn\u00e1lat\u00e1val a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki (a gyakorlat sor\u00e1n csak a kiemelt sort m\u00f3dos\u00edtsuk a kor\u00e1bban beg\u00e9pelt p\u00e9ld\u00e1ban): List < int > list = new List < int >(); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); for ( int n = 0 ; n < list . Count ; n ++) { int i = list [ n ]; // Nem kell cast-olni Console . WriteLine ( $\"Value: {i}\" ); }","title":"2. Nyelvi eszk\u00f6z\u00f6k"},{"location":"labor/2-nyelvi-eszkozok/#2-nyelvi-eszkozok","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: K\u0151v\u00e1ri Bence, Benedek Zolt\u00e1n","title":"2. Nyelvi eszk\u00f6z\u00f6k"},{"location":"labor/2-nyelvi-eszkozok/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja az al\u00e1bbi C# nyelvi elemek megismer\u00e9se: Tulajdons\u00e1g (property) Deleg\u00e1t (delegate, met\u00f3dusreferencia) Esem\u00e9ny (event) Attrib\u00fatum (attribute) Lambda kifejez\u00e9s Generikus t\u00edpus (generic type) Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: a 2. el\u0151ad\u00e1s \u00e9s a 3. el\u0151ad\u00e1s eleje \u2013 (Modern) programoz\u00e1si eszk\u00f6z\u00f6k.","title":"A gyakorlat c\u00e9lja"},{"location":"labor/2-nyelvi-eszkozok/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022","title":"El\u0151felt\u00e9telek"},{"location":"labor/2-nyelvi-eszkozok/#bevezeto","text":"A gyakorlat sor\u00e1n a hallgat\u00f3k megismerkednek a legfontosabb modern, a .NET k\u00f6rnyezetben is rendelkez\u00e9sre \u00e1ll\u00f3 nyelvi eszk\u00f6z\u00f6kkel. Felt\u00e9telezz\u00fck, hogy a hallgat\u00f3 a kor\u00e1bbi tanulm\u00e1nyai sor\u00e1n elsaj\u00e1t\u00edtotta az objektum-orient\u00e1lt szeml\u00e9letm\u00f3dot, \u00e9s tiszt\u00e1ban van az objektum-orient\u00e1lt alapfogalmakkal. Jelen gyakorlat sor\u00e1n azokra a .NET-es nyelvi elemekre koncentr\u00e1lunk, amelyek t\u00falmutatnak az \u00e1ltal\u00e1nos objektum-orient\u00e1lt szeml\u00e9leten, ugyanakkor nagyban hozz\u00e1j\u00e1rulnak a j\u00f3l \u00e1tl\u00e1that\u00f3 \u00e9s k\u00f6nnyen karbantarthat\u00f3 k\u00f3d elk\u00e9sz\u00edt\u00e9s\u00e9hez. Ezek a k\u00f6vetkez\u0151k: Tulajdons\u00e1gok (properties) Deleg\u00e1tok (delegates) Esem\u00e9nyek (events) Attrib\u00fatumok (attributes) Generikus oszt\u00e1lyok (generics) Lambda kifejez\u00e9sek","title":"Bevezet\u0151"},{"location":"labor/2-nyelvi-eszkozok/#1-feladat-tulajdonsag-property","text":"A tulajdons\u00e1gok seg\u00edts\u00e9g\u00e9vel tipikusan (de nem kiz\u00e1r\u00f3lagosan) oszt\u00e1lyok tagv\u00e1ltoz\u00f3ihoz f\u00e9rhet\u00fcnk hozz\u00e1 szintaktikailag hasonl\u00f3 m\u00f3don, mintha egy hagyom\u00e1nyos tagv\u00e1ltoz\u00f3t \u00e9rn\u00e9nk el. A hozz\u00e1f\u00e9r\u00e9s sor\u00e1n azonban lehet\u0151s\u00e9g\u00fcnk van arra, hogy az egyszer\u0171 \u00e9rt\u00e9k lek\u00e9rdez\u00e9s vagy be\u00e1ll\u00edt\u00e1s helyett met\u00f3dusszer\u0171en implement\u00e1ljuk a v\u00e1ltoz\u00f3 el\u00e9r\u00e9s\u00e9nek a m\u00f3dj\u00e1t. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy Person nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy embert reprezent\u00e1l. K\u00e9t tagv\u00e1ltoz\u00f3ja van, name \u00e9s age . A tagv\u00e1ltoz\u00f3khoz k\u00f6zvetlen\u00fcl nem f\u00e9rhet\u00fcnk hozz\u00e1 (mivel priv\u00e1tok), csak a Name , illetve Age publikus tulajdons\u00e1gokon kereszt\u00fcl kezelhetj\u00fck \u0151ket. A p\u00e9lda j\u00f3l szeml\u00e9lteti, hogy a .NET-es tulajdons\u00e1gok egy\u00e9rtelm\u0171en megfelelnek a C++-b\u00f3l \u00e9s Java-b\u00f3l m\u00e1r j\u00f3l ismert SetX(\u2026) illetve GetX() t\u00edpus\u00fa met\u00f3dusoknak, csak itt ez a megold\u00e1s egys\u00e9gbez\u00e1rtabb m\u00f3don nyelvi szinten t\u00e1mogatott. Hozzunk l\u00e9tre egy \u00faj C# konzolos alkalmaz\u00e1st. .NET Core alap\u00fat, vagyis ne .NET Framework-\u00f6set: Erre az els\u0151 gyakorlat alkalm\u00e1val l\u00e1ttunk p\u00e9ld\u00e1t, le\u00edr\u00e1sa annak \u00fatmutat\u00f3j\u00e1ban szerepel. A \" Do not use top level statements \" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be a projekt l\u00e9trehoz\u00e1s sor\u00e1n. Adjunk hozz\u00e1 egy \u00faj oszt\u00e1lyt az alkalmaz\u00e1sunkhoz Person n\u00e9ven. (\u00daj oszt\u00e1ly hozz\u00e1ad\u00e1s\u00e1hoz a Solution Explorerben kattintsunk jobb eg\u00e9rgombbal a projekt f\u00e1jlra \u00e9s v\u00e1lasszuk az \u201eAdd / class\u201d men\u00fcpontot. Az el\u0151ugr\u00f3 ablakban a l\u00e9trehozand\u00f3 f\u00e1jl nev\u00e9t m\u00f3dos\u00edtsuk Person.cs -re, majd nyomjuk meg az Add gombot.) Tegy\u00fck az oszt\u00e1lyt publikuss\u00e1. Ehhez az oszt\u00e1ly neve el\u00e9 be kell \u00edrni a public kulcssz\u00f3t. Erre a m\u00f3dos\u00edt\u00e1sra itt val\u00f3j\u00e1ban m\u00e9g nem volna sz\u00fcks\u00e9g, ugyanakkor a 4. feladat m\u00e1r egy publikus oszt\u00e1lyt fog ig\u00e9nyelni. Hozzunk l\u00e9tre az oszt\u00e1lyon bel\u00fcl egy int t\u00edpus\u00fa age nev\u0171 mez\u0151t \u00e9s egy ezt el\u00e9rhet\u0151v\u00e9 tev\u0151 Age tulajdons\u00e1got. public class Person { private int age ; public int Age { get { return age ; } set { age = value ; } } } Eg\u00e9sz\u00edts\u00fck ki a Program.cs f\u00e1jl Main f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj oszt\u00e1lyunkat. static void Main ( string [] args ) { Person p = new Person (); p . Age = 17 ; p . Age ++; Console . WriteLine ( p . Age ); } Futtassuk a programunkat (F5) L\u00e1thatjuk, hogy a tulajdons\u00e1g a tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an haszn\u00e1lhat\u00f3. A tulajdons\u00e1g lek\u00e9rdez\u00e9se eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt get r\u00e9sz fog lefutni, \u00e9s a tulajdons\u00e1g \u00e9rt\u00e9ke a return \u00e1ltal visszaadott \u00e9rt\u00e9k lesz. A tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sa eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt set r\u00e9sz fog lefutni, \u00e9s a speci\u00e1lis value v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke ebben a szakaszban megfelel a tulajdons\u00e1gnak \u00e9rt\u00e9k\u00fcl adott kifejez\u00e9ssel. Figyelj\u00fck meg a fenti megold\u00e1sban azt, hogy milyen eleg\u00e1nsan tudjuk egy \u00e9vvel megemelni az ember \u00e9letkor\u00e1t. Java, vagy C++ k\u00f3dban egy hasonl\u00f3 m\u0171veletet a p.setAge(p.getAge()+1) form\u00e1ban \u00edrhattunk volna le, amely jelent\u0151sen k\u00f6r\u00fclm\u00e9nyesebb \u00e9s nehezen olvashat\u00f3bb szintaktika a fentin\u00e9l. A tulajdons\u00e1gok haszn\u00e1lat\u00e1nak legf\u0151bb hozad\u00e9ka, hogy k\u00f3dunk szintaktikailag tiszt\u00e1bb lesz, az \u00e9rt\u00e9kad\u00e1sok illetve lek\u00e9rdez\u00e9sek pedig az esetek t\u00f6bbs\u00e9g\u00e9ben j\u00f3l elv\u00e1lnak a t\u00e9nyleges f\u00fcggv\u00e9nyh\u00edv\u00e1sokt\u00f3l. Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a programunk val\u00f3ban elv\u00e9gzi a get \u00e9s set r\u00e9szek h\u00edv\u00e1s\u00e1t. Ehhez helyezz\u00fcnk t\u00f6r\u00e9spontokat (breakpoint) a getter \u00e9s setter blokkok belsej\u00e9be a k\u00f3dszerkeszt\u0151 bal sz\u00e9l\u00e9n l\u00e1that\u00f3 sz\u00fcrke s\u00e1vra kattintva. Futtassuk a programot l\u00e9p\u00e9sr\u0151l l\u00e9p\u00e9sre. Ehhez a programot F5 helyett az F11 billenty\u0171vel ind\u00edtsuk, majd az F11 tov\u00e1bbi megnyom\u00e1saival engedj\u00fck sorr\u00f3l sorra a v\u00e9grehajt\u00e1st. L\u00e1thatjuk, hogy a programunk val\u00f3ban minden egyes alkalommal megh\u00edvja a gettert, amikor \u00e9rt\u00e9klek\u00e9rdez\u00e9s, illetve a settert, amikor \u00e9rt\u00e9kbe\u00e1ll\u00edt\u00e1s t\u00f6rt\u00e9nik. A setter f\u00fcggv\u00e9nyek egyik fontos funkci\u00f3ja, hogy lehet\u0151s\u00e9get k\u00edn\u00e1lnak az \u00e9rt\u00e9kvalid\u00e1ci\u00f3ra. Eg\u00e9sz\u00edts\u00fck ki ennek szellem\u00e9ben az Age tulajdons\u00e1g setter-\u00e9t. public int Age { get { return age ; } set { if ( value < 0 ) throw new Exception ( \"\u00c9rv\u00e9nytelen \u00e9letkor!\" ); age = value ; } } Figyelj\u00fck meg, hogy m\u00edg az egyszer\u0171 getter \u00e9s setter eset\u00e9ben az \u00e9rt\u00e9klek\u00e9rdez\u00e9st/be\u00e1ll\u00edt\u00e1st egy sorban tartjuk, addig komplexebb t\u00f6rzs eset\u00e9n m\u00e1r t\u00f6bb sorra t\u00f6rdelj\u00fck. Az alkalmaz\u00e1s tesztel\u00e9s\u00e9hez rendelj\u00fcnk hozz\u00e1 negat\u00edv \u00e9rt\u00e9ket az \u00e9letkorhoz a Program oszt\u00e1ly Main f\u00fcggv\u00e9ny\u00e9ben. p . Age = - 2 ; Futtassuk a programot, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy az ellen\u0151rz\u00e9s helyesen m\u0171k\u00f6dik, majd a tov\u00e1bbi munka kedv\u00e9\u00e9rt h\u00e1r\u00edtsuk el a hib\u00e1t azzal, hogy pozit\u00edvra cser\u00e9lj\u00fck a be\u00e1ll\u00edtott \u00e9letkort. p . Age = 2 ; A mindennapi munk\u00e1nk sor\u00e1n tal\u00e1lkozhatunk a tulajdons\u00e1goknak egy sokkal t\u00f6m\u00f6rebb szintaktik\u00e1j\u00e1val is. Ez a szintaktika akkor alkalmazhat\u00f3, ha egy olyan tulajdons\u00e1got szeretn\u00e9nk l\u00e9trehozni, melyben: nincs sz\u00fcks\u00e9g\u00fcnk a priv\u00e1t tagv\u00e1ltoz\u00f3 k\u00f6zvetlen el\u00e9r\u00e9s\u00e9re nem szeretn\u00e9nk semmilyen kieg\u00e9sz\u00edt\u0151 logik\u00e1val ell\u00e1tni a getter \u00e9s setter met\u00f3dusokat Erre n\u00e9zz\u00fcnk a k\u00f6vetkez\u0151kben p\u00e9ld\u00e1t. Eg\u00e9sz\u00edts\u00fck ki a Person oszt\u00e1lyunkat egy ilyen, \u00fan. \u201eautoimplement\u00e1lt\u201d tulajdons\u00e1ggal (auto-implemented property) . Sz\u00farjuk be a k\u00f6vetkez\u0151 sort k\u00f6zvetlen\u00fcl az Age tulajdons\u00e1g z\u00e1r\u00f3 kapcsos z\u00e1r\u00f3jel\u00e9t k\u00f6vet\u0151en: public string Name { get ; set ; } Autoimplemet\u00e1lt tulajdons\u00e1g eset\u00e9n a ford\u00edt\u00f3 egy rejtett, k\u00f3db\u00f3l nem el\u00e9rhet\u0151 v\u00e1ltoz\u00f3t gener\u00e1l az oszt\u00e1lyba, mely a tulajdons\u00e1g aktu\u00e1lis \u00e9rt\u00e9k\u00e9nek t\u00e1rol\u00e1s\u00e1ra szolg\u00e1l. Most ellen\u0151rizz\u00fck a m\u0171k\u00f6d\u00e9s\u00e9t a Main f\u00fcggv\u00e9ny kieg\u00e9sz\u00edt\u00e9s\u00e9vel. static void Main ( string [] args ) { \u2026 p . Name = \"Luke\" ; \u2026 Console . WriteLine ( p . Name ); } Note A tov\u00e1bbi feladatok \u00e9p\u00edteni fognak az el\u0151z\u0151 feladatok v\u00e9geredm\u00e9nyeire. Ha programod nem fordul le, vagy nem megfelel\u0151en m\u0171k\u00f6dik, jelezd ezt a gyakorlatvezet\u0151dnek a feladatok v\u00e9g\u00e9n, \u00e9s seg\u00edt elh\u00e1r\u00edtani a hib\u00e1t.","title":"1. Feladat \u2013 Tulajdons\u00e1g (property)"},{"location":"labor/2-nyelvi-eszkozok/#2-feladat-delegat-delegate-metodusreferencia","text":"A deleg\u00e1tok t\u00edpusos met\u00f3dusreferenci\u00e1kat jelentenek .NET-ben, a C/C++ f\u00fcggv\u00e9nypointerek modern megfelel\u0151i. Egy deleg\u00e1t defini\u00e1l\u00e1s\u00e1val egy olyan v\u00e1ltoz\u00f3t defini\u00e1lunk, amellyel r\u00e1mutathatunk egy olyan met\u00f3dusra, amely t\u00edpusa (param\u00e9terlist\u00e1ja \u00e9s visszat\u00e9r\u00e9si \u00e9rt\u00e9ke) megfelel a deleg\u00e1t t\u00edpus\u00e1nak. A deleg\u00e1t megh\u00edv\u00e1s\u00e1val az \u00e9rt\u00e9k\u00fcl adott (beregisztr\u00e1lt) met\u00f3dus automatikusan megh\u00edv\u00f3dik. A deleg\u00e1tok haszn\u00e1lat\u00e1nak egyik el\u0151nye az, hogy fut\u00e1si id\u0151ben d\u00f6nthetj\u00fck el, hogy t\u00f6bb met\u00f3dus k\u00f6z\u00fcl \u00e9ppen melyiket szeretn\u00e9nk megh\u00edvni. N\u00e9h\u00e1ny p\u00e9lda deleg\u00e1tok haszn\u00e1lat\u00e1ra: egy univerz\u00e1lis sorrendez\u0151 f\u00fcggv\u00e9nynek param\u00e9terk\u00e9nt az elemek \u00f6sszehasonl\u00edt\u00e1s\u00e1t v\u00e9gz\u0151 f\u00fcggv\u00e9ny \u00e1tad\u00e1sa, egy \u00e1ltal\u00e1nos gy\u0171jtem\u00e9nyen univerz\u00e1lis sz\u0171r\u00e9si logika megval\u00f3s\u00edt\u00e1sa, melynek param\u00e9terben egy deleg\u00e1t form\u00e1j\u00e1ban adjuk \u00e1t azt a f\u00fcggv\u00e9nyt, amely eld\u00f6nti, hogy egy elemet bele kell-e venni a sz\u0171rt list\u00e1ba, a publish-subscribe minta megval\u00f3s\u00edt\u00e1sa, amikor bizonyos objektumok m\u00e1s objektumokat \u00e9rtes\u00edtenek bizonyos magukkal kapcsolatos esem\u00e9nyek bek\u00f6vetkez\u00e9s\u00e9r\u0151l. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1nkban lehet\u0151v\u00e9 tessz\u00fck, hogy a kor\u00e1bban l\u00e9trehozott Person oszt\u00e1ly objektumai szabadon \u00e9rtes\u00edthess\u00e9k m\u00e1s oszt\u00e1lyok objektumait arr\u00f3l, ha egy szem\u00e9ly \u00e9letkora megv\u00e1ltozott. Ennek \u00e9rdek\u00e9ben bevezet\u00fcnk egy deleg\u00e1t t\u00edpust ( AgeChangingDelegate ), mely param\u00e9terlist\u00e1j\u00e1ban \u00e1t tudja adni az ember\u00fcnk \u00e9letkor\u00e1nak aktu\u00e1lis, illetve \u00faj \u00e9rt\u00e9k\u00e9t. Ezt k\u00f6vet\u0151en l\u00e9trehozunk egy publikus AgeChangingDelegate t\u00edpus\u00fa mez\u0151t a Person oszt\u00e1lyban, mely lehet\u0151v\u00e9 teszi, hogy egy k\u00fcls\u0151 f\u00e9l megadhassa azt a f\u00fcggv\u00e9nyt, amelyen kereszt\u00fcl az adott Person p\u00e9ld\u00e1ny v\u00e1ltoz\u00e1sair\u00f3l \u00e9rtes\u00edt\u00e9st k\u00e9r. Hozzunk l\u00e9tre egy \u00faj deleg\u00e1t t\u00edpust , mely void visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171, \u00e9s k\u00e9t darab int param\u00e9tert elv\u00e1r\u00f3 f\u00fcggv\u00e9nyre tud hivatkozni. Figyelj\u00fcnk r\u00e1, hogy az \u00faj t\u00edpust a Program oszt\u00e1ly el\u0151tt, k\u00f6zvetlen\u00fcl a n\u00e9vt\u00e9r scope-j\u00e1ban defini\u00e1ljuk! namespace PropertyDemo { public delegate void AgeChangingDelegate ( int oldAge , int newAge ); class Program { \u2026 Az AgeChangingDelegate egy t\u00edpus, mely b\u00e1rhol szerepelhet, ahol t\u00edpus \u00e1llhat (pl. lehet l\u00e9trehozni ez alapj\u00e1n tagv\u00e1ltoz\u00f3t, lok\u00e1lis v\u00e1ltoz\u00f3t, f\u00fcggv\u00e9ny param\u00e9tert stb.). Tegy\u00fck lehet\u0151v\u00e9, hogy a Person objektumai r\u00e1mutathassanak tetsz\u0151leges, a fenti szignat\u00far\u00e1nak megfelel\u0151 f\u00fcggv\u00e9nyre. Ehhez hozzunk l\u00e9tre egy AgeChangingDelegate t\u00edpus\u00fa mez\u0151t a Person oszt\u00e1lyban! class Person { public AgeChangingDelegate AgeChanging ; \u2026 Note Megjegyz\u00e9s: a publikus mez\u0151k\u00e9nt l\u00e9trehozott met\u00f3dusreferencia val\u00f3j\u00e1ban (egyel\u0151re) s\u00e9rti az OO elveket. Erre k\u00e9s\u0151bb visszat\u00e9r\u00fcnk m\u00e9g. H\u00edvjuk meg a f\u00fcggv\u00e9nyt minden alkalommal, amikor az ember\u00fcnk kora megv\u00e1ltozik. Ehhez eg\u00e9sz\u00edts\u00fck ki az Age tulajdons\u00e1g setter\u00e9t a k\u00f6vetkez\u0151kkel. public int Age { get { return age ; } set { if ( value < 0 ) throw new Exception ( \"\u00c9rv\u00e9nytelen \u00e9letkor!\" ); if ( AgeChanging != null ) AgeChanging ( age , value ); age = value ; } } A fenti k\u00f3dr\u00e9szlet sz\u00e1mos fontos szab\u00e1lyt demonstr\u00e1l: A valid\u00e1ci\u00f3s logika \u00e1ltal\u00e1ban megel\u0151zi az \u00e9rtes\u00edt\u00e9si logik\u00e1t. Az \u00e9rtes\u00edt\u00e9si logika jelleg\u00e9t\u0151l f\u00fcgg, hogy az \u00e9rt\u00e9kad\u00e1s el\u0151tt, vagy ut\u00e1n futtatjuk le (ebben az esetben, mivel a \u201echanging\u201d sz\u00f3 egy.folyamatban l\u00e9v\u0151 dologra utal, az \u00e9rtes\u00edt\u00e9s megel\u0151zi az \u00e9rt\u00e9kad\u00e1st) Fel kell k\u00e9sz\u00fcln\u00fcnk r\u00e1, hogy a delegate t\u00edpus\u00fa mez\u0151nkh\u00f6z m\u00e9g senki nem rendelt \u00e9rt\u00e9ket (nincs egy subscriber/el\u0151fizet\u0151 sem). Ilyen esetekben a megh\u00edv\u00e1suk kiv\u00e9telt okozna, ez\u00e9rt megh\u00edv\u00e1s el\u0151tt mindig ellen\u0151rizni kell, hogy a mez\u0151 \u00e9rt\u00e9ke null-e. Az esem\u00e9ny els\u00fct\u00e9sekor a null vizsg\u00e1latot \u00e9s az esem\u00e9ny els\u00fct\u00e9st eleg\u00e1nsabb, t\u00f6m\u00f6rebb form\u00e1ban is meg tudjuk tenni a \u201e ?. \u201d null-conditional oper\u00e1torral: if ( AgeChanging != null ) AgeChanging ( age , value ); helyett AgeChanging ?. Invoke ( age , value ); Ez csak akkor s\u00fcti el az esem\u00e9nyt, ha nem null, egy\u00e9bk\u00e9nt semmit nem csin\u00e1l. Ez C# 6-t\u00f3l kezdve haszn\u00e1lhat\u00f3, de ma m\u00e1r ez a javasolt technika. Ha szigor\u00faan n\u00e9zz\u00fck, akkor csak akkor kellene els\u00fctni az esem\u00e9nyt, ha a kor val\u00f3ban v\u00e1ltozik is, vagyis a property set \u00e1g\u00e1ban meg kellene vizsg\u00e1lni, az \u00faj \u00e9rt\u00e9k egyezik-e a r\u00e9givel. Megold\u00e1s lehet, ha a setter els\u0151 sor\u00e1ban azonnal visszat\u00e9r\u00fcnk, ha az \u00faj \u00e9rt\u00e9k egyezik a r\u00e9givel: if ( age == value ) return ; \u2026 K\u00e9sz vagyunk a Person oszt\u00e1ly k\u00f3dj\u00e1val. T\u00e9rj\u00fcnk \u00e1t az el\u0151fizet\u0151re! Ehhez mindenek el\u0151tt a Program oszt\u00e1lyt kell kieg\u00e9sz\u00edten\u00fcnk egy \u00fajabb f\u00fcggv\u00e9nnyel. class Program { \u2026 static void PersonAgeChanging ( int oldAge , int newAge ) { Console . WriteLine ( oldAge + \" => \" + newAge ); } \u2026 } Tipp: Fokozottan \u00fcgyelj\u00fcnk r\u00e1, hogy az \u00faj f\u00fcggv\u00e9ny a megfelel\u0151 scope-ba ker\u00fclj\u00f6n! V\u00e9gezet\u00fcl iratkozzunk fel a v\u00e1ltoz\u00e1sk\u00f6vet\u00e9sre a Main f\u00fcggv\u00e9nyben! static void Main ( string [] args ) { Person p = new Person (); p . AgeChanging = new AgeChangingDelegate ( PersonAgeChanging ); \u2026 Futtassuk a programot! Figyelj\u00fck meg, hogy az esem\u00e9ny minden egyes setter fut\u00e1skor, \u00edgy az els\u0151 \u00e9rt\u00e9kad\u00e1skor \u00e9s az inkrement\u00e1l\u00e1skor egyar\u00e1nt lefut. A megold\u00e1sunk azonban m\u00e9g fejleszthet\u0151. Eg\u00e9sz\u00edts\u00fck ki a Main f\u00fcggv\u00e9nyt t\u00f6bbsz\u00f6ri feliratkoz\u00e1ssal, majd futtassuk a programot. p . AgeChanging = new AgeChangingDelegate ( PersonAgeChanging ); p . AgeChanging += new AgeChangingDelegate ( PersonAgeChanging ); p . AgeChanging += PersonAgeChanging ; // T\u00f6m\u00f6rebb szintaktika L\u00e1that\u00f3an minden egyes \u00e9rt\u00e9kv\u00e1ltoz\u00e1skor mind a h\u00e1rom beregisztr\u00e1lt/\u201efeliratkozott\u201d f\u00fcggv\u00e9ny lefut. Ez az\u00e9rt lehets\u00e9ges, mert a delegate t\u00edpus\u00fa mez\u0151k val\u00f3j\u00e1ban nem csup\u00e1n egy f\u00fcggv\u00e9ny-referenci\u00e1t, hanem egy f\u00fcggv\u00e9ny-referencia list\u00e1t tartalmaznak (\u00e9s tartanak karban). Figyelj\u00fck meg a fenti harmadik sorban, hogy a f\u00fcggv\u00e9nyreferenci\u00e1kat az el\u0151sz\u00f6r l\u00e1tottn\u00e1l t\u00f6m\u00f6rebb szintaxissal is le\u00edrhatjuk: csak a f\u00fcggv\u00e9ny nev\u00e9t adjuk meg a += oper\u00e1tor ut\u00e1n, a new AgeChangingDelegate(...) n\u00e9lk\u00fcl. Ett\u0151l f\u00fcggetlen\u00fcl ekkor is egy AgeChangingDelegate objektum fogja becsomagolni a PersonAgeChanging f\u00fcggv\u00e9nyeket a sz\u00ednfalak m\u00f6g\u00f6tt. Pr\u00f3b\u00e1ljuk ki a leiratkoz\u00e1st is (szabadon v\u00e1lasztott ponton), majd futtassuk a programot. p . AgeChanging -= PersonAgeChanging ;","title":"2. Feladat \u2013 Deleg\u00e1t (delegate, met\u00f3dusreferencia)"},{"location":"labor/2-nyelvi-eszkozok/#3-feladat-esemeny-event","text":"Ahogyan a tulajdons\u00e1gok a getter \u00e9s setter met\u00f3dusoknak, addig a fent l\u00e1tott delegate mechanizmus a Java-b\u00f3l ismert Event Listener-eknek k\u00edn\u00e1lj\u00e1k egy a szintaktika tekintet\u00e9ben letisztultabb alternat\u00edv\u00e1j\u00e1t. A fenti megold\u00e1sunk azonban egyel\u0151re m\u00e9g s\u00falyosan s\u00e9rt p\u00e1r OO elvet (egys\u00e9gbez\u00e1r\u00e1s, inform\u00e1ci\u00f3rejt\u00e9s). Ezt az al\u00e1bbi k\u00e9t p\u00e9ld\u00e1val tudjuk demonstr\u00e1lni. Az esem\u00e9nyt val\u00f3j\u00e1ban k\u00edv\u00fclr\u0151l (m\u00e1s oszt\u00e1lyok m\u0171veletib\u0151l) is ki tudjuk v\u00e1ltani. Ez szerencs\u00e9tlen, hisz \u00edgy az esem\u00e9nyre feliratkozott f\u00fcggv\u00e9nyeken kereszt\u00fcl az oszt\u00e1ly nev\u00e9ben hamis adatokat k\u00f6z\u00f6lhet\u00fcnk. Ennek demonstr\u00e1l\u00e1s\u00e1ra sz\u00farjuk be a k\u00f6vetkez\u0151 sort a Main f\u00fcggv\u00e9ny v\u00e9g\u00e9re. p . AgeChanging ( 67 , 12 ); Itt a p szem\u00e9ly objektum vonatkoz\u00e1s\u00e1ban egy \"kamu\" \u00e9letkorv\u00e1ltoz\u00e1s esem\u00e9nyt v\u00e1ltottunk ki a Person , becsapva minden el\u0151fizet\u0151t. A j\u00f3 megold\u00e1s az lenne, ha az esem\u00e9nyt csak a Person oszt\u00e1ly m\u0171veletei tudn\u00e1k kiv\u00e1ltani. B\u00e1r a += \u00e9s a -= tekintettel vannak a list\u00e1ba feliratkozott t\u00f6bbi f\u00fcggv\u00e9nyre, val\u00f3j\u00e1ban az = oper\u00e1torral b\u00e1rmikor fel\u00fcl\u00edrhatjuk (kit\u00f6r\u00f6lhetj\u00fck) m\u00e1sok feliratkoz\u00e1sait. Pr\u00f3b\u00e1ljuk ki ezt is, a k\u00f6vetkez\u0151 sor besz\u00far\u00e1s\u00e1val (k\u00f6zvetlen\u00fcl a fel \u00e9s leiratkoz\u00e1sok ut\u00e1n sz\u00farjuk be). p . AgeChanging = null ; L\u00e1ssuk el az event kulcssz\u00f3val az AgeChanging mez\u0151t Person.cs -ben! class Person { public event AgeChangingDelegate AgeChanging ; \u2026 Az event kulcssz\u00f3 feladata val\u00f3j\u00e1ban az, hogy a fenti k\u00e9t jelens\u00e9get megtiltva visszak\u00e9nyszer\u00edtse programunkat az objektumorient\u00e1lt mederbe. Pr\u00f3b\u00e1ljuk meg leford\u00edtani a programot. L\u00e1tni fogjuk, hogy a ford\u00edt\u00f3 a kor\u00e1bbi kih\u00e1g\u00e1sainkat most m\u00e1r ford\u00edt\u00e1si hibak\u00e9nt kezeli. T\u00e1vol\u00edtsuk el a h\u00e1rom hib\u00e1s k\u00f3dsort (figyelj\u00fck meg, hogy m\u00e1r az els\u0151 k\u00f6zvetlen \u00e9rt\u00e9kad\u00e1s is hib\u00e1nak min\u0151s\u00fcl), majd ford\u00edtsuk le \u00e9s futtassuk az alkalmaz\u00e1sunkat!","title":"3. Feladat \u2013 Esem\u00e9ny (event)"},{"location":"labor/2-nyelvi-eszkozok/#4-feladat-attributumok","text":"A z attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel deklarat\u00edv m\u00f3don metaadatokkal l\u00e1thatjuk el forr\u00e1sk\u00f3dunkat . Az attrib\u00fatum is tulajdonk\u00e9ppen egy oszt\u00e1ly, melyet hozz\u00e1k\u00f6t\u00fcnk a program egy megadott elem\u00e9hez (t\u00edpushoz, oszt\u00e1lyhoz, interf\u00e9szhez, met\u00f3dushoz, \u2026). Ezeket a metainform\u00e1ci\u00f3kat a program fut\u00e1sa k\u00f6zben b\u00e1rki (ak\u00e1r mi magunk is) kiolvashatja az \u00fagynevezett reflection mechanizmus seg\u00edts\u00e9g\u00e9vel. Az attrib\u00fatumok a Java annot\u00e1ci\u00f3k .NET-beli megfelel\u0151inek is tekinthet\u0151k. A NET sz\u00e1mos be\u00e9p\u00edtett attrib\u00fatumot defini\u00e1l, melyek funkci\u00f3ja a legk\u00fcl\u00f6nb\u00f6z\u0151bb f\u00e9le lehet. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban haszn\u00e1lt attrib\u00fatumok p\u00e9ld\u00e1ul az XML soros\u00edt\u00f3val (serializer k\u00f6z\u00f6lnek k\u00fcl\u00f6nb\u00f6z\u0151 metainform\u00e1ci\u00f3kat. Sz\u00farjuk be a Main f\u00fcggv\u00e9ny v\u00e9g\u00e9re a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletet, majd futtassuk a programunkat! XmlSerializer serializer = new XmlSerializer ( typeof ( Person )); FileStream stream = new FileStream ( \"person.txt\" , FileMode . Create ); serializer . Serialize ( stream , p ); stream . Close (); // Process.Start(\"person.txt\"); A fenti p\u00e9ld\u00e1b\u00f3l az utols\u00f3 sor nem a soros\u00edt\u00f3 logika r\u00e9sze, csup\u00e1n egy frapp\u00e1ns megold\u00e1s arra, hogy a Windows alap\u00e9rtelmezett sz\u00f6vegf\u00e1jl n\u00e9zeget\u0151j\u00e9vel megnyissuk a keletkezett adat\u00e1llom\u00e1nyt. Ezt kipr\u00f3b\u00e1lhatjuk, de a haszn\u00e1lt .NET runtime-t\u00f3l \u00e9s az oper\u00e1ci\u00f3s rendszer\u00fcnkt\u0151l f\u00fcgg, t\u00e1mogatott-e. Ha nem, fut\u00e1s k\u00f6zben hib\u00e1t kapunk. Ez esetben hagyjuk kikommentezve, \u00e9s a person.txt f\u00e1jlt a f\u00e1jlrendszerben megkeresve k\u00e9zzel nyissuk meg (a Visual Studio mapp\u00e1nkban a \\bin\\Debug\\ alatt tal\u00e1lhat\u00f3 az .exe alkalmaz\u00e1sunk mellett. N\u00e9zz\u00fck meg a keletkezett f\u00e1jl szerkezet\u00e9t. Figyelj\u00fck meg, hogy minden tulajdons\u00e1g a nev\u00e9nek megfelel\u0151 XML elemre lett lek\u00e9pezve. .NET attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel olyan metaadatokkal l\u00e1thatjuk el a Person oszt\u00e1lyunkat, melyek k\u00f6zvetlen\u00fcl m\u00f3dos\u00edtj\u00e1k a soros\u00edt\u00f3 viselked\u00e9s\u00e9t. Az XmlRoot attrib\u00fatum lehet\u0151s\u00e9get k\u00edn\u00e1l a gy\u00f6k\u00e9relem \u00e1tnevez\u00e9s\u00e9re. Helyezz\u00fck el a Person oszt\u00e1ly f\u00f6l\u00e9! [XmlRoot(\"Szem\u00e9ly\")] public class Person { ... } Az XmlAttribute attrib\u00fatum jelzi a soros\u00edt\u00f3 sz\u00e1m\u00e1ra, hogy a jel\u00f6lt tulajdons\u00e1got ne xml elemre, hanem xml attrib\u00fatumra k\u00e9pezze le. L\u00e1ssuk el ezzel az Age tulajdons\u00e1got! [XmlAttribute(\"Kor\")] public int Age Az XmlIgnore attrib\u00fatum jelzi a soros\u00edt\u00f3nak, hogy a jel\u00f6lt tulajdons\u00e1g teljesen elhagyand\u00f3 az eredm\u00e9nyb\u0151l. Pr\u00f3b\u00e1ljuk ki a Name tulajdons\u00e1g f\u00f6l\u00f6tt. [XmlIgnore] public string Name { get ; set ; } Futtassuk az alkalmaz\u00e1sunkat! Hasonl\u00edtsuk \u00f6ssze az eredm\u00e9nyt a kor\u00e1bbiakkal.","title":"4. Feladat \u2013 Attrib\u00fatumok"},{"location":"labor/2-nyelvi-eszkozok/#5-feladat-delegat-2","text":"A 2. \u00e9s 3. feladatokban a deleg\u00e1tokkal esem\u00e9ny alap\u00fa \u00fczenetk\u00fcld\u00e9st val\u00f3s\u00edtottunk meg. A deleg\u00e1tok haszn\u00e1lat\u00e1nak m\u00e1sik tipikus eset\u00e9ben a f\u00fcggv\u00e9nyreferenci\u00e1kat arra haszn\u00e1ljuk, hogy egy algoritmus vagy \u00f6sszetettebb m\u0171velet sz\u00e1m\u00e1ra egy el\u0151re nem defini\u00e1lt l\u00e9p\u00e9s implement\u00e1ci\u00f3j\u00e1t \u00e1tadjuk . A generikus lista oszt\u00e1ly ( List<T> ) FindAll f\u00fcggv\u00e9nye p\u00e9ld\u00e1ul k\u00e9pes arra, hogy visszaadjon egy \u00faj list\u00e1ban minden olyan elemet, mely egy adott felt\u00e9telnek eleget tesz. A konkr\u00e9t sz\u0171r\u00e9si felt\u00e9telt egy f\u00fcggv\u00e9ny form\u00e1j\u00e1ban adhatjuk meg param\u00e9terben (melyet a FindAll minden elemre megh\u00edv), mely igazat ad minden olyan elemre, amit az eredm\u00e9nylist\u00e1ban szeretn\u00e9nk l\u00e1tni. A f\u00fcggv\u00e9ny t\u00edpusa a k\u00f6vetkez\u0151 el\u0151re defini\u00e1lt delegate t\u00edpus: public delegate bool Predicate < T >( T obj ) Vagyis bemenetk\u00e9nt egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t v\u00e1r, mint a listaelemek t\u00edpusa, kimenetk\u00e9nt pedig egy logikai \u00e9rt\u00e9ket. A fentiek demonstr\u00e1l\u00e1s\u00e1ra kieg\u00e9sz\u00edtj\u00fck a kor\u00e1bbi programunkat egy sz\u0171r\u00e9ssel, mely a list\u00e1b\u00f3l csak a p\u00e1ratlan elemeket fogja megtartani. Val\u00f3s\u00edtsunk meg egy olyan sz\u0171r\u0151f\u00fcggv\u00e9nyt az alkalmaz\u00e1sunkban, amely a p\u00e1ratlan sz\u00e1mokat adja vissza: static bool MyFilter ( int n ) { return n % 2 == 1 ; } Eg\u00e9sz\u00edts\u00fck ki a kor\u00e1bban \u00edrt k\u00f3dunkat a sz\u0171r\u0151 f\u00fcggv\u00e9ny\u00fcnk haszn\u00e1lat\u00e1val: List < int > list = new List < int >(); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); list = list . FindAll ( MyFilter ); foreach ( int n in list ) { Console . WriteLine ( $\"Value: {n}\" ); } Futtassuk az alkalmaz\u00e1sunkat. Figyelj\u00fck meg, hogy a konzolon val\u00f3ban csak a p\u00e1ratlan sz\u00e1mok jelennek meg. \u00c9rdekess\u00e9gk\u00e9nt elhelyezhet\u00fcnk egy t\u00f6r\u00e9spontot (breakpoint) a MyFilter f\u00fcggv\u00e9ny\u00fcnk belsej\u00e9ben \u00e9s megfigyelhetj\u00fck, hogy a f\u00fcggv\u00e9ny val\u00f3ban minden egyes listaelemre k\u00fcl\u00f6n-k\u00fcl\u00f6n megh\u00edv\u00f3dik.","title":"5. Feladat \u2013 Deleg\u00e1t 2."},{"location":"labor/2-nyelvi-eszkozok/#6-feladat-lambda-kifejezesek","text":"Az \u00e9rintett t\u00e9mak\u00f6r\u00f6k az el\u0151ad\u00e1sanyagban r\u00e9szletesen szerepelnek, itt nem ism\u00e9telj\u00fck meg \u0151ket L\u00e1sd \u201eEl\u0151ad\u00e1s 02 - Modern nyelvi eszk\u00f6z\u00f6k.pdf\u201d dokumentum \u201eLambda expression (lambda kifejez\u00e9s)\u201d fejezete. A kulcselem a => (lambda oper\u00e1tor) seg\u00edts\u00e9g\u00e9vel lambda kifejez\u00e9sek , vagyis n\u00e9vtelen f\u00fcggv\u00e9nyek defini\u00e1l\u00e1sa. Note A .NET be\u00e9p\u00edtett Func \u00e9s Action generikus delegate t\u00edpusokra itt id\u0151 hi\u00e1ny\u00e1\u00e9ban nem t\u00e9r\u00fcnk ki. Az el\u0151z\u0151, 5. feladatot oldjuk meg a k\u00f6vetkez\u0151k\u00e9ppen: ne adjunk meg k\u00fcl\u00f6n sz\u0171r\u0151f\u00fcggv\u00e9nyt, hanem a sz\u0171r\u00e9si logik\u00e1t egy lambda kifejez\u00e9s form\u00e1j\u00e1ban adjuk meg a FindAll m\u0171veletnek. Ehhez mind\u00f6ssze egy sort kell megv\u00e1ltoztatni: list = list . FindAll ( ( int n ) => { return n % 2 == 1 ; } ); Egy n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyt defini\u00e1ltunk \u00e9s adtunk \u00e1t a FindAll m\u0171veletnek: Ez egy lambda kifejez\u00e9s A => bal oldal\u00e1n megadtuk a m\u0171velet param\u00e9tereket (itt csak egy volt) A => jobb oldal\u00e1n a m\u0171velet t\u00f6rzs\u00e9t (ugyanaz, mint a kor\u00e1bbi MyFilter t\u00f6rzse) A fenti sort j\u00f3val egyszer\u0171bb \u00e9s \u00e1ttekinthet\u0151bb form\u00e1ba is \u00edrhatjuk: list = list . FindAll ( n => n % 2 == 1 ); A k\u00f6vetkez\u0151 egyszer\u0171s\u00edt\u00e9seket eszk\u00f6z\u00f6lt\u00fck: A param\u00e9ter t\u00edpus\u00e1t nem \u00edrtuk ki (a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni a FindAll delegate param\u00e9ter t\u00edpus\u00e1b\u00f3l) A param\u00e9ter k\u00f6r\u00fcli z\u00e1r\u00f3jelet elhagyhattuk ( mert csak egy param\u00e9ter van) A => jobb oldal\u00e1n elhagyhattuk a {} z\u00e1r\u00f3jeleket \u00e9s a return -t (mert egyetlen kifejez\u00e9sb\u0151l \u00e1llt a f\u00fcggv\u00e9ny t\u00f6rzse, mellyel a f\u00fcggv\u00e9ny visszat\u00e9r)","title":"6. Feladat \u2013 Lambda kifejez\u00e9sek"},{"location":"labor/2-nyelvi-eszkozok/#7-feladat-generikus-osztalyok","text":"Megjegyz\u00e9s: erre a feladatra j\u00f3 es\u00e9llyel nem marad id\u0151. Ez esetben c\u00e9lszer\u0171 a feladatot gyakorl\u00e1sk\u00e9ppen otthon elv\u00e9gezni. A .NET generikus oszt\u00e1lyai megfelelnek a C++ nyelv template oszt\u00e1lyainak (noha vannak jelent\u0151sebb k\u00fcl\u00f6nbs\u00e9gek a m\u0171k\u00f6d\u00e9s\u00fckben). A seg\u00edts\u00e9g\u00fckkel \u00e1ltal\u00e1nos (t\u00f6bb t\u00edpusra is m\u0171k\u00f6d\u0151), de ugyanakkor t\u00edpusbiztos oszt\u00e1lyokat hozhatunk l\u00e9tre. Generikus oszt\u00e1lyok n\u00e9lk\u00fcl, ha \u00e1ltal\u00e1nosan szeretn\u00e9nk kezelni egy probl\u00e9m\u00e1t, akkor object t\u00edpus\u00fa adatokat haszn\u00e1lunk (mert .NET-ben minden oszt\u00e1ly az object oszt\u00e1lyb\u00f3l sz\u00e1rmazik). Ez a helyzet p\u00e9ld\u00e1ul az ArrayList -tel is, ami egy \u00e1ltal\u00e1nos c\u00e9l\u00fa gy\u0171jtem\u00e9ny, tetsz\u0151leges, object t\u00edpus\u00fa elemek t\u00e1rol\u00e1s\u00e1ra alkalmas. L\u00e1ssunk egy p\u00e9ld\u00e1t az ArrayList haszn\u00e1lat\u00e1ra: ArrayList list = new ArrayList (); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); for ( int n = 0 ; n < list . Count ; n ++) { // Castolni kell, k\u00fcl\u00f6nben nem fordul int i = ( int ) list [ n ]; Console . WriteLine ( $\"Value: {i}\" ); } A fenti megold\u00e1ssal a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k ad\u00f3dnak: Az ArrayList minden egyes elemet object -k\u00e9nt t\u00e1rol. Amikor hozz\u00e1 szeretn\u00e9nk f\u00e9rni a lista egy elem\u00e9hez, mindig a megfelel\u0151 t\u00edpus\u00fav\u00e1 kell cast-olni. Nem t\u00edpusbiztos. A fenti p\u00e9ld\u00e1ban semmi nem akad\u00e1lyoz meg abban (\u00e9s semmilyen hiba\u00fczenet sem jelzi), hogy az int t\u00edpus\u00fa adatok mell\u00e9 besz\u00farjunk a list\u00e1ba egy m\u00e1sik t\u00edpus\u00fa objektumot. Ilyenkor csak a lista bej\u00e1r\u00e1sa sor\u00e1n kapn\u00e1nk hib\u00e1t, amikor a nem int t\u00edpust int t\u00edpus\u00fara pr\u00f3b\u00e1lunk castolni. Generikus gy\u0171jtem\u00e9nyek haszn\u00e1latakor az ilyen hib\u00e1k m\u00e1r a ford\u00edt\u00e1s sor\u00e1n kider\u00fclnek. \u00c9rt\u00e9k t\u00edpus\u00fa adatok t\u00e1rol\u00e1sakor a lista lassabban m\u0171k\u00f6dik, mert az \u00e9rt\u00e9k t\u00edpust el\u0151sz\u00f6r be kell dobozolni (boxing), hogy az object -k\u00e9nt (azaz referencia t\u00edpusk\u00e9nt) t\u00e1rolhat\u00f3 legyen. A fenti probl\u00e9ma megold\u00e1sa egy generikus lista haszn\u00e1lat\u00e1val a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki (a gyakorlat sor\u00e1n csak a kiemelt sort m\u00f3dos\u00edtsuk a kor\u00e1bban beg\u00e9pelt p\u00e9ld\u00e1ban): List < int > list = new List < int >(); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); for ( int n = 0 ; n < list . Count ; n ++) { int i = list [ n ]; // Nem kell cast-olni Console . WriteLine ( $\"Value: {i}\" ); }","title":"7. Feladat \u2013 Generikus oszt\u00e1lyok"},{"location":"labor/3-felhasznaloi-felulet/","text":"3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: Rajacsics Tam\u00e1s, Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja egy l\u00e1tv\u00e1nyos, gyors alkalmaz\u00e1sfejleszt\u00e9s bemutat\u00e1sa, mely egyben megteremti a lehet\u0151s\u00e9get a Windows Forms fejleszt\u00e9s alapjainak elsaj\u00e1t\u00edt\u00e1s\u00e1ra. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt): Windows Forms alkalmaz\u00e1sfejleszt\u00e9s alapok Men\u00fck Dokkol\u00e1s \u00e9s horgonyz\u00e1s SplitView TreeView ListView Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: 3-4. el\u0151ad\u00e1s \u2013 Vastagkliens alkalmaz\u00e1sok fejleszt\u00e9se. El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) Bevezet\u0151 \u00b6 A Rapid Application Development (RAD) elve a fejleszt\u00e9si id\u0151 ler\u00f6vid\u00edt\u00e9s\u00e9t c\u00e9lozza meg az\u00e1ltal, hogy a fejleszt\u00e9s sor\u00e1n k\u00e9sz komponensekkel dolgozik, integr\u00e1lt fejleszt\u0151 k\u00f6rnyezetet (pl. Visual Studio) \u00e9s sok automatizmust alkalmaz. Fontos ugyanakkor, hogy az automatizmusok ne sz\u0171k\u00edts\u00e9k be t\u00falzottan a fejleszt\u0151 lehet\u0151s\u00e9geit \u00e9s kell\u0151 rugalmass\u00e1got adjanak neki a rendszerek testre szab\u00e1s\u00e1ban. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban l\u00e1tni fogjuk, mik\u00e9nt alkalmas mindezekre a Windows Forms k\u00f6rnyezet. A Window Forms alkalmaz\u00e1sok legfontosabb koncepci\u00f3it a t\u00e1rgy 3.-4. el\u0151ad\u00e1sa ismerteti. Egy Windows Forms alkalmaz\u00e1sban az alkalmaz\u00e1sunk minden ablak\u00e1nak egy saj\u00e1t oszt\u00e1lyt kell l\u00e9trehozni, mely a be\u00e9p\u00edtett Form oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Erre \u2013 tipikusan a Visual Studio designer\u00e9vel - vez\u00e9rl\u0151ket helyez\u00fcnk fel, melyek a Form oszt\u00e1lyunk tagv\u00e1ltoz\u00f3i lesznek. Tipp: a k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban sz\u00e1mos gener\u00e1lt (\u00e9s emiatt hossz\u00fa) elnevez\u00e9ssel fogunk tal\u00e1lkozni. Programjaink megval\u00f3s\u00edt\u00e1sakor haszn\u00e1ljuk ki az automatikus k\u00f3dkieg\u00e9sz\u00edt\u00e9s (intellisense) ny\u00fajtotta lehet\u0151s\u00e9geket \u00e9s ne k\u00e9zzel g\u00e9pelj\u00fck be az egyes elnevez\u00e9seket. ************ COMING SOON *************** \u00b6","title":"3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa"},{"location":"labor/3-felhasznaloi-felulet/#3-a-felhasznaloi-felulet-kialakitasa","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: Rajacsics Tam\u00e1s, Benedek Zolt\u00e1n","title":"3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa"},{"location":"labor/3-felhasznaloi-felulet/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja egy l\u00e1tv\u00e1nyos, gyors alkalmaz\u00e1sfejleszt\u00e9s bemutat\u00e1sa, mely egyben megteremti a lehet\u0151s\u00e9get a Windows Forms fejleszt\u00e9s alapjainak elsaj\u00e1t\u00edt\u00e1s\u00e1ra. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt): Windows Forms alkalmaz\u00e1sfejleszt\u00e9s alapok Men\u00fck Dokkol\u00e1s \u00e9s horgonyz\u00e1s SplitView TreeView ListView Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: 3-4. el\u0151ad\u00e1s \u2013 Vastagkliens alkalmaz\u00e1sok fejleszt\u00e9se.","title":"A gyakorlat c\u00e9lja"},{"location":"labor/3-felhasznaloi-felulet/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)","title":"El\u0151felt\u00e9telek"},{"location":"labor/3-felhasznaloi-felulet/#bevezeto","text":"A Rapid Application Development (RAD) elve a fejleszt\u00e9si id\u0151 ler\u00f6vid\u00edt\u00e9s\u00e9t c\u00e9lozza meg az\u00e1ltal, hogy a fejleszt\u00e9s sor\u00e1n k\u00e9sz komponensekkel dolgozik, integr\u00e1lt fejleszt\u0151 k\u00f6rnyezetet (pl. Visual Studio) \u00e9s sok automatizmust alkalmaz. Fontos ugyanakkor, hogy az automatizmusok ne sz\u0171k\u00edts\u00e9k be t\u00falzottan a fejleszt\u0151 lehet\u0151s\u00e9geit \u00e9s kell\u0151 rugalmass\u00e1got adjanak neki a rendszerek testre szab\u00e1s\u00e1ban. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban l\u00e1tni fogjuk, mik\u00e9nt alkalmas mindezekre a Windows Forms k\u00f6rnyezet. A Window Forms alkalmaz\u00e1sok legfontosabb koncepci\u00f3it a t\u00e1rgy 3.-4. el\u0151ad\u00e1sa ismerteti. Egy Windows Forms alkalmaz\u00e1sban az alkalmaz\u00e1sunk minden ablak\u00e1nak egy saj\u00e1t oszt\u00e1lyt kell l\u00e9trehozni, mely a be\u00e9p\u00edtett Form oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Erre \u2013 tipikusan a Visual Studio designer\u00e9vel - vez\u00e9rl\u0151ket helyez\u00fcnk fel, melyek a Form oszt\u00e1lyunk tagv\u00e1ltoz\u00f3i lesznek. Tipp: a k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban sz\u00e1mos gener\u00e1lt (\u00e9s emiatt hossz\u00fa) elnevez\u00e9ssel fogunk tal\u00e1lkozni. Programjaink megval\u00f3s\u00edt\u00e1sakor haszn\u00e1ljuk ki az automatikus k\u00f3dkieg\u00e9sz\u00edt\u00e9s (intellisense) ny\u00fajtotta lehet\u0151s\u00e9geket \u00e9s ne k\u00e9zzel g\u00e9pelj\u00fck be az egyes elnevez\u00e9seket.","title":"Bevezet\u0151"},{"location":"labor/3-felhasznaloi-felulet/#coming-soon","text":"","title":"************ COMING SOON ***************"},{"location":"labor/4-tobbszalu/","text":"4. T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: Szab\u00f3 Zolt\u00e1n, Benedek Zolt\u00e1n, Simon G\u00e1bor A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja, hogy megismertesse a hallgat\u00f3kat a t\u00f6bbsz\u00e1las programoz\u00e1s sor\u00e1n k\u00f6vetend\u0151 alapelvekkel. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt): Sz\u00e1lak ind\u00edt\u00e1sa Sz\u00e1lak le\u00e1ll\u00edt\u00e1sa Sz\u00e1lbiztos (thread safe) oszt\u00e1lyok k\u00e9sz\u00edt\u00e9se a lock kulcssz\u00f3 alkalmaz\u00e1s\u00e1val ThreadPool haszn\u00e1lata Jelz\u00e9s \u00e9s jelz\u00e9sre v\u00e1rakoz\u00e1s sz\u00e1l szinkroniz\u00e1ci\u00f3 ManualResetEvent seg\u00edts\u00e9g\u00e9vel Windows Forms sz\u00e1lkezel\u00e9si saj\u00e1toss\u00e1gok Term\u00e9szetesen, mivel a t\u00e9mak\u00f6r hatalmas, csak alapszint\u0171 tud\u00e1st fogunk szerezni, de e tud\u00e1s birtok\u00e1ban m\u00e1r k\u00e9pesek lesz\u00fcnk \u00f6n\u00e1ll\u00f3an is elindulni a bonyolultabb feladatok megval\u00f3s\u00edt\u00e1s\u00e1ban. A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Konkurens (t\u00f6bbsz\u00e1l\u00fa) alkalmaz\u00e1sok fejleszt\u00e9se. El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) Bevezet\u0151 \u00b6 A p\u00e1rhuzamosan fut\u00f3 sz\u00e1lak kezel\u00e9se kiemelt fontoss\u00e1g\u00fa ter\u00fclet, melyet miden szoftverfejleszt\u0151nek legal\u00e1bb alapszinten ismernie kell. A gyakorlat sor\u00e1n alapszint\u0171, de kiemelt fontoss\u00e1g\u00fa probl\u00e9m\u00e1kat oldunk meg, ez\u00e9rt t\u00f6rekedn\u00fcnk kell arra, hogy ne csak a v\u00e9geredm\u00e9nyt, hanem az elv\u00e9gzett m\u00f3dos\u00edt\u00e1sok \u00e9rtelm\u00e9t \u00e9s indokait is meg\u00e9rts\u00fck. A feladat sor\u00e1n egyszer\u0171 Windows Forms alkalmaz\u00e1st fogunk felruh\u00e1zni t\u00f6bbsz\u00e1las k\u00e9pess\u00e9gekkel, egyre komplexebb feladatokat megoldva. Az alapprobl\u00e9ma a k\u00f6vetkez\u0151: van egy f\u00fcggv\u00e9ny\u00fcnk, mely hossz\u00fa ideig fut, s mint l\u00e1tni fogjuk, ennek \u201edirektben\u201d t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sa a fel\u00fcletr\u0151l kellemetlen k\u00f6vetkezm\u00e9nyekkel j\u00e1r. A megold\u00e1s sor\u00e1n egy megl\u00e9v\u0151 alkalmaz\u00e1st fogunk kieg\u00e9sz\u00edteni saj\u00e1t k\u00f3dr\u00e9szletekkel. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi. 0. Feladat - Ismerked\u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal, el\u0151k\u00e9sz\u00edt\u00e9s \u00b6 ************ COMING SOON *************** \u00b6","title":"4. T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se"},{"location":"labor/4-tobbszalu/#4-tobbszalu-alkalmazasok-keszitese","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: Szab\u00f3 Zolt\u00e1n, Benedek Zolt\u00e1n, Simon G\u00e1bor","title":"4. T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se"},{"location":"labor/4-tobbszalu/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja, hogy megismertesse a hallgat\u00f3kat a t\u00f6bbsz\u00e1las programoz\u00e1s sor\u00e1n k\u00f6vetend\u0151 alapelvekkel. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt): Sz\u00e1lak ind\u00edt\u00e1sa Sz\u00e1lak le\u00e1ll\u00edt\u00e1sa Sz\u00e1lbiztos (thread safe) oszt\u00e1lyok k\u00e9sz\u00edt\u00e9se a lock kulcssz\u00f3 alkalmaz\u00e1s\u00e1val ThreadPool haszn\u00e1lata Jelz\u00e9s \u00e9s jelz\u00e9sre v\u00e1rakoz\u00e1s sz\u00e1l szinkroniz\u00e1ci\u00f3 ManualResetEvent seg\u00edts\u00e9g\u00e9vel Windows Forms sz\u00e1lkezel\u00e9si saj\u00e1toss\u00e1gok Term\u00e9szetesen, mivel a t\u00e9mak\u00f6r hatalmas, csak alapszint\u0171 tud\u00e1st fogunk szerezni, de e tud\u00e1s birtok\u00e1ban m\u00e1r k\u00e9pesek lesz\u00fcnk \u00f6n\u00e1ll\u00f3an is elindulni a bonyolultabb feladatok megval\u00f3s\u00edt\u00e1s\u00e1ban. A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Konkurens (t\u00f6bbsz\u00e1l\u00fa) alkalmaz\u00e1sok fejleszt\u00e9se.","title":"A gyakorlat c\u00e9lja"},{"location":"labor/4-tobbszalu/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)","title":"El\u0151felt\u00e9telek"},{"location":"labor/4-tobbszalu/#bevezeto","text":"A p\u00e1rhuzamosan fut\u00f3 sz\u00e1lak kezel\u00e9se kiemelt fontoss\u00e1g\u00fa ter\u00fclet, melyet miden szoftverfejleszt\u0151nek legal\u00e1bb alapszinten ismernie kell. A gyakorlat sor\u00e1n alapszint\u0171, de kiemelt fontoss\u00e1g\u00fa probl\u00e9m\u00e1kat oldunk meg, ez\u00e9rt t\u00f6rekedn\u00fcnk kell arra, hogy ne csak a v\u00e9geredm\u00e9nyt, hanem az elv\u00e9gzett m\u00f3dos\u00edt\u00e1sok \u00e9rtelm\u00e9t \u00e9s indokait is meg\u00e9rts\u00fck. A feladat sor\u00e1n egyszer\u0171 Windows Forms alkalmaz\u00e1st fogunk felruh\u00e1zni t\u00f6bbsz\u00e1las k\u00e9pess\u00e9gekkel, egyre komplexebb feladatokat megoldva. Az alapprobl\u00e9ma a k\u00f6vetkez\u0151: van egy f\u00fcggv\u00e9ny\u00fcnk, mely hossz\u00fa ideig fut, s mint l\u00e1tni fogjuk, ennek \u201edirektben\u201d t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sa a fel\u00fcletr\u0151l kellemetlen k\u00f6vetkezm\u00e9nyekkel j\u00e1r. A megold\u00e1s sor\u00e1n egy megl\u00e9v\u0151 alkalmaz\u00e1st fogunk kieg\u00e9sz\u00edteni saj\u00e1t k\u00f3dr\u00e9szletekkel. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi.","title":"Bevezet\u0151"},{"location":"labor/4-tobbszalu/#0-feladat-ismerkedes-a-kiindulo-alkalmazassal-elokeszites","text":"","title":"0. Feladat - Ismerked\u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal, el\u0151k\u00e9sz\u00edt\u00e9s"},{"location":"labor/4-tobbszalu/#coming-soon","text":"","title":"************ COMING SOON ***************"},{"location":"labor/5-adatkezeles/","text":"5. Adatkezel\u00e9s \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: Kasz\u00f3 M\u00e1rk, Simon G\u00e1bor A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja az ADO.NET programoz\u00e1si modellj\u00e9nek megismer\u00e9se \u00e9s a leggyakoribb adatkezel\u00e9si probl\u00e9m\u00e1k, buktat\u00f3k szeml\u00e9ltet\u00e9se alapvet\u0151 CRUD m\u0171veletek meg\u00edr\u00e1s\u00e1n kereszt\u00fcl. Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Adatkezel\u00e9s, ADO.NET alapismeretek. El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) A gyakorlat sor\u00e1n az SQL Server Object Explorer -t fogjuk haszn\u00e1lni az adatb\u00e1zis objektumok k\u00f6z\u00f6tti navig\u00e1l\u00e1s\u00e1ra \u00e9s a lek\u00e9rdez\u00e9sek futtat\u00e1s\u00e1ra. Ehhez sz\u00fcks\u00e9g lehet az SQL Server Data Tools komponensre, melyet legegyszer\u0171bben az Individual Components oldalon tudunk telep\u00edteni a Visual Studio Installer-ben. Bevezet\u0151 \u00b6 Megjegyz\u00e9s gyakorlatvezet\u0151knek Ezt a fejezetet gyakorlaton nem kell a le\u00edrtaknak megfelel\u0151 r\u00e9szletess\u00e9ggel ismertetni, a fontosabb fogalmakat azonban mindenk\u00e9ppen ismertess\u00fck r\u00f6viden. ADO.NET \u00b6 Alacsony szint\u0171 adatb\u00e1ziskezel\u00e9sre a .NET platformon az ADO.NET \u00e1ll rendelkez\u00e9sre, seg\u00edts\u00e9g\u00e9vel rel\u00e1ci\u00f3s adatb\u00e1zisokat tudunk el\u00e9rni. Az ADO.NET haszn\u00e1lata sor\u00e1n k\u00e9t elt\u00e9r\u0151 adathozz\u00e1f\u00e9r\u00e9si modellt alkalmazhatunk: Kapcsolatalap\u00fa modell Kapcsolat n\u00e9lk\u00fcli modell Az al\u00e1bbi k\u00e9t blokkot lenyitva \u00e1ttekint\u00e9st kaphatunk a k\u00e9t modell alapelv\u00e9r\u0151l. A Kapcsolatalap\u00fa modell alapelvei L\u00e9nyege az, hogy az adatb\u00e1ziskapcsolatot v\u00e9gig nyitva tartjuk, am\u00edg az adatokat lek\u00e9rdezz\u00fck, m\u00f3dos\u00edtjuk, majd a v\u00e1ltoztat\u00e1sokat az adatb\u00e1zisba vissza\u00edrjuk. A megold\u00e1sra DataReader objektumokat haszn\u00e1lhatunk (l\u00e1sd k\u00e9s\u0151bb). A megold\u00e1s el\u0151nye az egyszer\u0171s\u00e9g\u00e9ben rejlik (egyszer\u0171bb programoz\u00e1si modell \u00e9s konkurenciakezel\u00e9s). A megold\u00e1s h\u00e1tr\u00e1nya, hogy a folyamatosan fenntartott h\u00e1l\u00f3zati kapcsolat miatt sk\u00e1l\u00e1zhat\u00f3s\u00e1gi probl\u00e9m\u00e1k ad\u00f3dhatnak. Ez azt jelenti, hogy az adatkezel\u0151h\u00f6z t\u00f6rt\u00e9n\u0151 nagysz\u00e1m\u00fa p\u00e1rhuzamos felhaszn\u00e1l\u00f3i hozz\u00e1f\u00e9r\u00e9s eset\u00e9n folyamatosan nagysz\u00e1m\u00fa adatb\u00e1zis kapcsolat \u00e9l, ami adatkezel\u0151 rendszerek eset\u00e9n a teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l k\u00f6lts\u00e9ges er\u0151forr\u00e1snak sz\u00e1m\u00edt. \u00cdgy a fejleszt\u00e9s sor\u00e1n c\u00e9lszer\u0171 arra t\u00f6rekedni, hogy az adatb\u00e1zis kapcsolatokat miel\u0151bb z\u00e1rjuk le. A modell el\u0151nyei: Egyszer\u0171bb a konkurencia kezel\u00e9se Az adatok mindenhol a legfrissebbek Megjegyz\u00e9s: ezek az el\u0151ny\u00f6k akkor jelentkeznek, ha az adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9s az adatkezel\u0151 szigor\u00fa z\u00e1rakat haszn\u00e1l \u2013 ezt mi a hozz\u00e1f\u00e9r\u00e9s sor\u00e1n megfelel\u0151 tranzakci\u00f3 izol\u00e1ci\u00f3s szint megad\u00e1s\u00e1val tudjuk szab\u00e1lyozni. Ennek technik\u00e1i k\u00e9s\u0151bbi tanulm\u00e1nyok sor\u00e1n ker\u00fclnek ismertet\u00e9sre). H\u00e1tr\u00e1nyok: Folyamatos h\u00e1l\u00f3zati kapcsolat Sk\u00e1l\u00e1zhat\u00f3s\u00e1g A Kapcsolatn\u00e9lk\u00fcli modell alapelvei A kapcsolatalap\u00fa modellel ellent\u00e9tben az adatok megjelen\u00edt\u00e9se \u00e9s mem\u00f3ri\u00e1ban t\u00f6rt\u00e9n\u0151 m\u00f3dos\u00edt\u00e1sa sor\u00e1n nem tartunk fent adatb\u00e1zis kapcsolatot. Ennek megfelel\u0151en a f\u0151bb l\u00e9p\u00e9sek a k\u00f6vetkez\u0151k: a kapcsolat felv\u00e9tel\u00e9t \u00e9s az adatok lek\u00e9rdez\u00e9s\u00e9t k\u00f6vet\u0151en azonnal bontjuk a kapcsolatot. Az adatokat ezt k\u00f6vet\u0151en tipikusan megjelen\u00edtj\u00fck \u00e9s lehet\u0151s\u00e9get biztos\u00edtunk a felhaszn\u00e1l\u00f3nak az adatok m\u00f3dos\u00edt\u00e1s\u00e1ra (rekordok felv\u00e9tele, m\u00f3dos\u00edt\u00e1sa, t\u00f6rl\u00e9se ig\u00e9ny szerint). A m\u00f3dos\u00edt\u00e1sok ment\u00e9se sor\u00e1n \u00fajra felvessz\u00fck az adatkapcsolatot, mentj\u00fck az adatb\u00e1zisba a v\u00e1ltoztat\u00e1sokat \u00e9s z\u00e1rjuk a kapcsolatot. Term\u00e9szetesen a modell megk\u00f6veteli, hogy a lek\u00e9rdez\u00e9se \u00e9s a m\u00f3dos\u00edt\u00e1sok vissza\u00edr\u00e1sa k\u00f6z\u00f6tt \u2013 amikor nincs kapcsolatunk az adatb\u00e1zissal \u2013 az adatokat \u00e9s a v\u00e1ltoztat\u00e1sokat a mem\u00f3ri\u00e1ban nyilv\u00e1ntartsuk. Erre az ADO.NET k\u00f6rnyezetben nagyon k\u00e9nyelmes megold\u00e1st ny\u00fajt a DataSet objektumok alkalmaz\u00e1sa. A modell el\u0151nyei: Nem sz\u00fcks\u00e9ges folyamatos h\u00e1l\u00f3zati kapcsolat Sk\u00e1l\u00e1zhat\u00f3s\u00e1g H\u00e1tr\u00e1nyok Az adatok nem mindig a legfrissebbek \u00dctk\u00f6z\u00e9sek lehets\u00e9gesek Megjegyz\u00e9s: Sz\u00e1mos lehet\u0151s\u00e9g\u00fcnk van arra, hogy az objektumokat \u00e9s kapcsol\u00f3d\u00f3 v\u00e1ltoz\u00e1sokat nyilv\u00e1ntartsuk a mem\u00f3ri\u00e1ban. A DataSet csak az egyik lehets\u00e9ges technika. De haszn\u00e1lhatunk erre a c\u00e9lra k\u00f6z\u00f6ns\u00e9ges objektumokat, illetve ezek menedzsel\u00e9s\u00e9t megk\u00f6nny\u00edt\u0151 ADO.NET-n\u00e9l korszer\u0171bb .NET technol\u00f3gi\u00e1kat (pl. Entity Framework). A kapcsolatalap\u00fa modell \u00b6 A m\u00e9r\u00e9s keret\u00e9ben a kapcsolatalap\u00fa modellt ismerj\u00fck meg. Az alapfolyamat a k\u00f6vetkez\u0151: Kapcsolat l\u00e9trehoz\u00e1sa az alkalmaz\u00e1s illetve az adatb\u00e1zis kezel\u0151 rendszer k\u00f6z\u00f6tt ( Connection objektum felhaszn\u00e1l\u00e1s\u00e1val) A futtatand\u00f3 SQL utas\u00edt\u00e1s \u00f6ssze\u00e1ll\u00edt\u00e1s ( Command objektum felhaszn\u00e1l\u00e1s\u00e1val) Utas\u00edt\u00e1s futtat\u00e1sa ( Command objektum felhaszn\u00e1l\u00e1s\u00e1val) Lek\u00e9rdez\u00e9sek eset\u00e9n a visszakapott rekordhalmaz feldolgoz\u00e1sa ( DataReader objektum felhaszn\u00e1l\u00e1s\u00e1val). Erre a m\u00f3dos\u00edt\u00f3 parancsok eset\u00e9n \u00e9rtelemszer\u0171en nincs sz\u00fcks\u00e9g. Kapcsolat lez\u00e1r\u00e1sa Mint a fentiekb\u0151l kider\u00fcl, az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3nak ebben a modellben h\u00e1rom f\u0151 \u00f6sszetev\u0151je van: Connection Command Data Reader Ezek az \u00f6sszetev\u0151k egy-egy oszt\u00e1lyk\u00e9nt jelennek meg, adatb\u00e1ziskezel\u0151f\u00fcggetlen r\u00e9sz\u00fck a System.Data.dll -ben tal\u00e1lhat\u00f3 DbConnection , DbCommand , illetve DbDataReader n\u00e9ven. Ezek absztrakt oszt\u00e1lyok, az adatb\u00e1ziskezel\u0151k gy\u00e1rt\u00f3inak feladata, hogy ezekb\u0151l lesz\u00e1rmazva meg\u00edrj\u00e1k a konkr\u00e9t adatb\u00e1ziskezel\u0151ket t\u00e1mogat\u00f3 v\u00e1ltozatokat. A Microsoftt SQL Servert t\u00e1mogat\u00f3 v\u00e1ltozatok szint\u00e9n a System.Data.dll -ben, \u201eSql\u201d prefix\u0171 oszt\u00e1lyokban tal\u00e1lhat\u00f3k ( SqlConnection , SqlCommand \u00e9s SqlDataReader ). A t\u00f6bbi gy\u00e1rt\u00f3 k\u00fcl\u00f6n dll-(ek)be teszi a saj\u00e1t v\u00e1ltozat\u00e1t, az \u00edgy l\u00e9trej\u00f6tt komponenst data providernek nevezik. Tal\u00e1lhat\u00f3 m\u00e9g a System.Data.dll -ben Oracle adatb\u00e1ziskezel\u0151t t\u00e1mogat\u00f3 provider is, azonban ez m\u00e1r elavult. N\u00e9h\u00e1ny tov\u00e1bbi gy\u00e1rt\u00f3 ADO.NET adatb\u00e1zis providere a teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl: ODP.NET (Oracle), MySqlConnector/Net (MySQL), Npgsql (PostgreSQL), System.Data.SQLite (SQLite) Mindh\u00e1rom ADO.NET \u00f6sszetev\u0151 t\u00e1mogatja a Dispose mint\u00e1t, \u00edgy using blokkban haszn\u00e1lhat\u00f3 \u2013 haszn\u00e1ljuk is \u00edgy, amikor csak tudjuk. Az adatb\u00e1ziskezel\u0151 \u00e1ltal\u00e1ban m\u00e1sik g\u00e9pen tal\u00e1lhat\u00f3, mint ahol a k\u00f3dunk fut (a m\u00e9r\u00e9s sor\u00e1n pont nem :)), \u00edgy tekints\u00fcnk ezekre, mint t\u00e1voli h\u00e1l\u00f3zati er\u0151forr\u00e1sokra. Connection \u00b6 Ez teremti meg a kapcsolatot a programunk, illetve az adatb\u00e1ziskezel\u0151-rendszer k\u00f6z\u00f6tt Inicializ\u00e1l\u00e1s\u00e1hoz sz\u00fcks\u00e9g van egy connection string-re, ami a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9hez sz\u00fcks\u00e9ges adatokat adja meg a driver sz\u00e1m\u00e1ra. Adatb\u00e1zisgy\u00e1rt\u00f3nk\u00e9nt elt\u00e9r\u0151 bels\u0151 form\u00e1tuma van (b\u0151vebben: http://www.connectionstrings.com ). \u00daj Connection p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem biztos, hogy t\u00e9nyleg \u00faj kapcsolat fog l\u00e9trej\u00f6nni az adatb\u00e1zis fel\u00e9, a driverek \u00e1ltal\u00e1ban connection pooling-ot alkalmaznak, hasonl\u00f3an, mint a thread pool eset\u00e9ben, \u00fajrahaszn\u00e1lhatj\u00e1k a kor\u00e1bbi (\u00e9ppen nem haszn\u00e1lt) kapcsolatokat. Command \u00b6 Ennek seg\u00edts\u00e9g\u00e9vel vagyunk k\u00e9pesek \u201eutas\u00edt\u00e1sokat\u201d megfogalmazni az adatb\u00e1zis kezel\u0151 sz\u00e1m\u00e1ra. Ezeket SQL nyelven kell megfogalmaznunk. A Command -nak be kell \u00e1ll\u00edtani egy kapcsolatot \u2013 ezen kereszt\u00fcl fog a parancs v\u00e9grehajt\u00f3dni. A parancsnak k\u00fcl\u00f6nb\u00f6z\u0151 eredm\u00e9nye lehet, ennek megfelel\u0151en k\u00fcl\u00f6nb\u00f6z\u0151 f\u00fcggv\u00e9nyekkel s\u00fctj\u00fck el a parancsot: ExecuteReader : Eredm\u00e9nyhalmaz (result set) lek\u00e9rdez\u00e9se ExecuteScalar : Skal\u00e1r \u00e9rt\u00e9k lek\u00e9rdez\u00e9se ExecuteNonQuery : Nincs visszat\u00e9r\u00e9si \u00e9rt\u00e9k (Pl: INSERT), viszont a m\u0171velet k\u00f6vetkezt\u00e9ben \u00e9rintett rekordok sz\u00e1m\u00e1t visszakapjuk Data Reader \u00b6 Ha a parancs eredm\u00e9nye eredm\u00e9nyhalmaz, akkor ennek a komponensnek a seg\u00edts\u00e9g\u00e9vel tudjuk az adatokat kiolvasni. Az eredm\u00e9nyhalmaz egy t\u00e1bl\u00e1zatnak tekinthet\u0151, a Data Reader ezen tud kurzoros m\u00f3dszerrel soronk\u00e9nt v\u00e9gignavig\u00e1lni (csak el\u0151refel\u00e9!). A kurzor egyszerre egy soron \u00e1ll, ha a sorb\u00f3l a sz\u00fcks\u00e9ges adatokat kiolvastuk, a kurzort egy sorral el\u0151re l\u00e9ptethetj\u00fck. Csak az aktu\u00e1lis sorb\u00f3l tudunk olvasni. Kezdetben a kurzor nem az els\u0151 soron \u00e1ll, azt egyszer l\u00e9ptetn\u00fcnk kell, hogy az els\u0151 sorra \u00e1lljon. Megjegyz\u00e9s: navig\u00e1l\u00e1s kliens oldalon t\u00f6rt\u00e9nik a mem\u00f3ri\u00e1ban, nincs k\u00f6ze az egyes adatkezel\u0151k \u00e1ltal t\u00e1mogatott kiszolg\u00e1l\u00f3 oldali kurzorokhoz. 1. Feladat \u2013 Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se \u00b6 Els\u0151k\u00e9nt sz\u00fcks\u00e9g\u00fcnk van egy adatb\u00e1ziskezel\u0151re. Ezt val\u00f3s k\u00f6rnyezetben dedik\u00e1lt szerveren fut\u00f3, adatb\u00e1zis adminisztr\u00e1torok \u00e1ltal fel\u00fcgyelt, teljes\u00e9rt\u00e9k\u0171 adatb\u00e1ziskezel\u0151k jelentik. Fejleszt\u00e9si id\u0151ben, lok\u00e1lis tesztel\u00e9shez azonban k\u00e9nyelmesebb fejleszt\u0151i adatb\u00e1ziskezel\u0151 haszn\u00e1lata. A Visual Studio telep\u00edt\u00e9s\u00e9nek r\u00e9szek\u00e9nt kapunk is egy ilyen adatb\u00e1zis engine-t, ez a LocalDB, ami a teljes\u00e9rt\u00e9k\u0171 SQL Server egyszer\u0171s\u00edtett v\u00e1ltozata. F\u0151bb tulajdons\u00e1gai: nem csak a Visual Studio-val, hanem k\u00fcl\u00f6n is telep\u00edthet\u0151 az adatb\u00e1zismotor szinte teljes m\u00e9rt\u00e9kben kompatibilis a teljes\u00e9rt\u00e9k\u0171 Microsoft SQL Serverrel alapvet\u0151en arr\u00f3l a g\u00e9pr\u0151l \u00e9rhet\u0151 el, amire telep\u00edtett\u00fck t\u00f6bb p\u00e9ld\u00e1ny is l\u00e9trehozhat\u00f3 ig\u00e9ny szerint, a p\u00e9ld\u00e1nyok alapvet\u0151en a l\u00e9trehoz\u00f3 oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3ja sz\u00e1m\u00e1ra \u00e9rhet\u0151 el (ig\u00e9ny eset\u00e9n megoszthat\u00f3 egy p\u00e9ld\u00e1ny a felhaszn\u00e1l\u00f3k k\u00f6z\u00f6tt) a saj\u00e1t p\u00e9ld\u00e1nyok kezel\u00e9se (l\u00e9trehoz\u00e1s, t\u00f6rl\u00e9s, stb.) nem ig\u00e9nyel adminisztr\u00e1tori jogokat ssqllocaldb parancssori eszk\u00f6z \u00c9rdekess\u00e9g, (ezeket a gyakorlaton nem kell elmondani), csak a lehet\u0151s\u00e9get eml\u00edts\u00fck meg. A p\u00e9ld\u00e1nyok kezel\u00e9s\u00e9re az sqllocaldb parancssori eszk\u00f6z haszn\u00e1lhat\u00f3. N\u00e9h\u00e1ny parancs, melyet az sqllocaldb ut\u00e1n be\u00edrva alkalmazhatunk : Paracs Le\u00edr\u00e1s info az aktu\u00e1lis felhaszn\u00e1\u00e1l\u00f3 sz\u00e1m\u00e1ra l\u00e1that\u00f3 p\u00e9ld\u00e1nyok list\u00e1ja create \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny t\u00f6rl\u00e9se start \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny ind\u00edt\u00e1sa stop \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny le\u00e1ll\u00edt\u00e1sa A Visual Studio is vesz fel, illetve ind\u00edt LocalDB p\u00e9ld\u00e1nyokat, ez\u00e9rt \u00e9rdemes megn\u00e9zni, hogy a Visual Studio alapb\u00f3l milyen p\u00e9ld\u00e1nyokat l\u00e1t. Ind\u00edtsuk el a Visual Studio-t, a View men\u00fcb\u0151l v\u00e1lasszuk az SQL Server Object Explorer-t (SSOE). Nyissuk ki az SQL Server csom\u00f3pontot, ha alatta l\u00e1tunk tov\u00e1bbi csom\u00f3pontokat, akkor nyert \u00fcgy\u00fcnk van, nyissuk ki valamelyiket (ilyenkor indul el a p\u00e9ld\u00e1ny, ha nincs elind\u00edtva, \u00edgy lehet, hogy v\u00e1rni kell kicsit) Ha nem jelent meg semmi, akkor parancssorb\u00f3l az mssqllocaldb info parancs megadja a l\u00e9tez\u0151 p\u00e9ld\u00e1nyokat. V\u00e1lasszuk az SQL Server csom\u00f3ponton jobbklikkelve az Add SQL Server opci\u00f3t, majd adjuk meg valamelyik l\u00e9tez\u0151 p\u00e9ld\u00e1nyt, pl.: (localdb)\\MSSQLLocalDB A megjelen\u0151 Databases csom\u00f3ponton v\u00e1lasszuk a New Database opci\u00f3t, itt adjunk meg egy adatb\u00e1zisnevet. (Laboron, mivel t\u00f6bb hallgat\u00f3 is haszn\u00e1lhatja ugyanazt az oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3t, \u00edgy javasolt a neptunk\u00f3d mint n\u00e9v haszn\u00e1lata.) Az \u00faj adatb\u00e1zis csom\u00f3pontj\u00e1n jobbklikkelve v\u00e1lasszuk a New Query opci\u00f3t, ami egy \u00faj query ablakot nyit A t\u00e1rgyhonlapr\u00f3l nyissuk meg vagy t\u00f6lts\u00fck le a Northwind adatb\u00e1zis inicializ\u00e1l\u00f3 szkriptet (a publikus anyagok k\u00f6z\u00f6tt tal\u00e1lhat\u00f3, \u201eNorthwind p\u00e9ldaadatb\u00e1zis\u201d n\u00e9ven) M\u00e1soljuk be a teljes szkriptet a query ablakba A szkript elej\u00e9n a megadott helyen \u00edrjuk be az adatb\u00e1zisunk nev\u00e9t Futtassuk le a szkriptet a kis z\u00f6ld ny\u00edllal ( Execute ) Ellen\u0151rizz\u00fck, hogy az adatb\u00e1zisunk ban megjelentek-e t\u00e1bl\u00e1k, n\u00e9zetek Fedezz\u00fck fel az SSOE legfontosabb funkci\u00f3it (t\u00e1bl\u00e1k adatainak, s\u00e9m\u00e1j\u00e1nak lek\u00e9rdez\u00e9se stb.) Note A Visual Studio-ban k\u00e9t eszk\u00f6zzel is kezelhet\u00fcnk adatb\u00e1zisokat: a Server Explorer-rel \u00e9s az SQL Server Object Explorer-rel is. El\u0151bbi egy \u00e1ltal\u00e1nosabb eszk\u00f6z, mely nem csak adatb\u00e1zis, hanem egy\u00e9b szerver er\u0151forr\u00e1sok (pl. Azure szerverek) kezel\u00e9s\u00e9re is alkalmas, m\u00edg a m\u00e1sik kifejezetten csak adatb\u00e1ziskezel\u00e9sre van kihegyezve. Mindkett\u0151 el\u00e9rhet\u0151 a View men\u00fcb\u0151l \u00e9s mindkett\u0151 hasonl\u00f3 funkci\u00f3kat ad adatb\u00e1ziskezel\u00e9shez, ez\u00e9rt ebben a m\u00e9r\u00e9sben csak az egyiket (SQL Server Object Explorer) haszn\u00e1ljuk. Amikor nem \u00e1ll rendelkez\u00e9s\u00fcnkre a Visual Studio fejleszt\u0151k\u00f6rnyezet, akkor az adatb\u00e1zisunk menedzsel\u00e9s\u00e9re az (ingyenes) SQL Server Management Studio-t tudjuk haszn\u00e1lni. 2. Feladat \u2013 Lek\u00e9rdez\u00e9s ADO.NET SqlDataReader-rel \u00b6 COMING SOON 3. Feladat \u2013 Besz\u00far\u00e1s SQL utas\u00edt\u00e1ssal \u00b6 COMING SOON 4. Feladat - M\u00f3dos\u00edt\u00e1s t\u00e1rolt elj\u00e1r\u00e1ssal \u00b6 COMING SOON 5. Feladat - SQL Injection \u00b6 COMING SOON 6. Feladat - T\u00f6rl\u00e9s \u00b6 COMING SOON Kitekint\u00e9s \u00b6 COMING SOON F\u00fcggel\u00e9k \u2013 Adatb\u00e1zisok, SQL nyelv alapok \u00b6 Az adatb\u00e1ziskezel\u0151 rendszerek vil\u00e1g\u00e1ba \u00e9s az SQL nyelvbe betekint\u00e9st a kapcsol\u00f3d\u00f3 el\u0151ad\u00e1son, illetve az al\u00e1bbi hivatkoz\u00e1s alatt tal\u00e1lsz: Adatb\u00e1zisok, SQL nyelv alapok","title":"5. Adatkezel\u00e9s"},{"location":"labor/5-adatkezeles/#5-adatkezeles","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: Kasz\u00f3 M\u00e1rk, Simon G\u00e1bor","title":"5. Adatkezel\u00e9s"},{"location":"labor/5-adatkezeles/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja az ADO.NET programoz\u00e1si modellj\u00e9nek megismer\u00e9se \u00e9s a leggyakoribb adatkezel\u00e9si probl\u00e9m\u00e1k, buktat\u00f3k szeml\u00e9ltet\u00e9se alapvet\u0151 CRUD m\u0171veletek meg\u00edr\u00e1s\u00e1n kereszt\u00fcl. Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Adatkezel\u00e9s, ADO.NET alapismeretek.","title":"A gyakorlat c\u00e9lja"},{"location":"labor/5-adatkezeles/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) A gyakorlat sor\u00e1n az SQL Server Object Explorer -t fogjuk haszn\u00e1lni az adatb\u00e1zis objektumok k\u00f6z\u00f6tti navig\u00e1l\u00e1s\u00e1ra \u00e9s a lek\u00e9rdez\u00e9sek futtat\u00e1s\u00e1ra. Ehhez sz\u00fcks\u00e9g lehet az SQL Server Data Tools komponensre, melyet legegyszer\u0171bben az Individual Components oldalon tudunk telep\u00edteni a Visual Studio Installer-ben.","title":"El\u0151felt\u00e9telek"},{"location":"labor/5-adatkezeles/#bevezeto","text":"Megjegyz\u00e9s gyakorlatvezet\u0151knek Ezt a fejezetet gyakorlaton nem kell a le\u00edrtaknak megfelel\u0151 r\u00e9szletess\u00e9ggel ismertetni, a fontosabb fogalmakat azonban mindenk\u00e9ppen ismertess\u00fck r\u00f6viden.","title":"Bevezet\u0151"},{"location":"labor/5-adatkezeles/#adonet","text":"Alacsony szint\u0171 adatb\u00e1ziskezel\u00e9sre a .NET platformon az ADO.NET \u00e1ll rendelkez\u00e9sre, seg\u00edts\u00e9g\u00e9vel rel\u00e1ci\u00f3s adatb\u00e1zisokat tudunk el\u00e9rni. Az ADO.NET haszn\u00e1lata sor\u00e1n k\u00e9t elt\u00e9r\u0151 adathozz\u00e1f\u00e9r\u00e9si modellt alkalmazhatunk: Kapcsolatalap\u00fa modell Kapcsolat n\u00e9lk\u00fcli modell Az al\u00e1bbi k\u00e9t blokkot lenyitva \u00e1ttekint\u00e9st kaphatunk a k\u00e9t modell alapelv\u00e9r\u0151l. A Kapcsolatalap\u00fa modell alapelvei L\u00e9nyege az, hogy az adatb\u00e1ziskapcsolatot v\u00e9gig nyitva tartjuk, am\u00edg az adatokat lek\u00e9rdezz\u00fck, m\u00f3dos\u00edtjuk, majd a v\u00e1ltoztat\u00e1sokat az adatb\u00e1zisba vissza\u00edrjuk. A megold\u00e1sra DataReader objektumokat haszn\u00e1lhatunk (l\u00e1sd k\u00e9s\u0151bb). A megold\u00e1s el\u0151nye az egyszer\u0171s\u00e9g\u00e9ben rejlik (egyszer\u0171bb programoz\u00e1si modell \u00e9s konkurenciakezel\u00e9s). A megold\u00e1s h\u00e1tr\u00e1nya, hogy a folyamatosan fenntartott h\u00e1l\u00f3zati kapcsolat miatt sk\u00e1l\u00e1zhat\u00f3s\u00e1gi probl\u00e9m\u00e1k ad\u00f3dhatnak. Ez azt jelenti, hogy az adatkezel\u0151h\u00f6z t\u00f6rt\u00e9n\u0151 nagysz\u00e1m\u00fa p\u00e1rhuzamos felhaszn\u00e1l\u00f3i hozz\u00e1f\u00e9r\u00e9s eset\u00e9n folyamatosan nagysz\u00e1m\u00fa adatb\u00e1zis kapcsolat \u00e9l, ami adatkezel\u0151 rendszerek eset\u00e9n a teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l k\u00f6lts\u00e9ges er\u0151forr\u00e1snak sz\u00e1m\u00edt. \u00cdgy a fejleszt\u00e9s sor\u00e1n c\u00e9lszer\u0171 arra t\u00f6rekedni, hogy az adatb\u00e1zis kapcsolatokat miel\u0151bb z\u00e1rjuk le. A modell el\u0151nyei: Egyszer\u0171bb a konkurencia kezel\u00e9se Az adatok mindenhol a legfrissebbek Megjegyz\u00e9s: ezek az el\u0151ny\u00f6k akkor jelentkeznek, ha az adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9s az adatkezel\u0151 szigor\u00fa z\u00e1rakat haszn\u00e1l \u2013 ezt mi a hozz\u00e1f\u00e9r\u00e9s sor\u00e1n megfelel\u0151 tranzakci\u00f3 izol\u00e1ci\u00f3s szint megad\u00e1s\u00e1val tudjuk szab\u00e1lyozni. Ennek technik\u00e1i k\u00e9s\u0151bbi tanulm\u00e1nyok sor\u00e1n ker\u00fclnek ismertet\u00e9sre). H\u00e1tr\u00e1nyok: Folyamatos h\u00e1l\u00f3zati kapcsolat Sk\u00e1l\u00e1zhat\u00f3s\u00e1g A Kapcsolatn\u00e9lk\u00fcli modell alapelvei A kapcsolatalap\u00fa modellel ellent\u00e9tben az adatok megjelen\u00edt\u00e9se \u00e9s mem\u00f3ri\u00e1ban t\u00f6rt\u00e9n\u0151 m\u00f3dos\u00edt\u00e1sa sor\u00e1n nem tartunk fent adatb\u00e1zis kapcsolatot. Ennek megfelel\u0151en a f\u0151bb l\u00e9p\u00e9sek a k\u00f6vetkez\u0151k: a kapcsolat felv\u00e9tel\u00e9t \u00e9s az adatok lek\u00e9rdez\u00e9s\u00e9t k\u00f6vet\u0151en azonnal bontjuk a kapcsolatot. Az adatokat ezt k\u00f6vet\u0151en tipikusan megjelen\u00edtj\u00fck \u00e9s lehet\u0151s\u00e9get biztos\u00edtunk a felhaszn\u00e1l\u00f3nak az adatok m\u00f3dos\u00edt\u00e1s\u00e1ra (rekordok felv\u00e9tele, m\u00f3dos\u00edt\u00e1sa, t\u00f6rl\u00e9se ig\u00e9ny szerint). A m\u00f3dos\u00edt\u00e1sok ment\u00e9se sor\u00e1n \u00fajra felvessz\u00fck az adatkapcsolatot, mentj\u00fck az adatb\u00e1zisba a v\u00e1ltoztat\u00e1sokat \u00e9s z\u00e1rjuk a kapcsolatot. Term\u00e9szetesen a modell megk\u00f6veteli, hogy a lek\u00e9rdez\u00e9se \u00e9s a m\u00f3dos\u00edt\u00e1sok vissza\u00edr\u00e1sa k\u00f6z\u00f6tt \u2013 amikor nincs kapcsolatunk az adatb\u00e1zissal \u2013 az adatokat \u00e9s a v\u00e1ltoztat\u00e1sokat a mem\u00f3ri\u00e1ban nyilv\u00e1ntartsuk. Erre az ADO.NET k\u00f6rnyezetben nagyon k\u00e9nyelmes megold\u00e1st ny\u00fajt a DataSet objektumok alkalmaz\u00e1sa. A modell el\u0151nyei: Nem sz\u00fcks\u00e9ges folyamatos h\u00e1l\u00f3zati kapcsolat Sk\u00e1l\u00e1zhat\u00f3s\u00e1g H\u00e1tr\u00e1nyok Az adatok nem mindig a legfrissebbek \u00dctk\u00f6z\u00e9sek lehets\u00e9gesek Megjegyz\u00e9s: Sz\u00e1mos lehet\u0151s\u00e9g\u00fcnk van arra, hogy az objektumokat \u00e9s kapcsol\u00f3d\u00f3 v\u00e1ltoz\u00e1sokat nyilv\u00e1ntartsuk a mem\u00f3ri\u00e1ban. A DataSet csak az egyik lehets\u00e9ges technika. De haszn\u00e1lhatunk erre a c\u00e9lra k\u00f6z\u00f6ns\u00e9ges objektumokat, illetve ezek menedzsel\u00e9s\u00e9t megk\u00f6nny\u00edt\u0151 ADO.NET-n\u00e9l korszer\u0171bb .NET technol\u00f3gi\u00e1kat (pl. Entity Framework).","title":"ADO.NET"},{"location":"labor/5-adatkezeles/#a-kapcsolatalapu-modell","text":"A m\u00e9r\u00e9s keret\u00e9ben a kapcsolatalap\u00fa modellt ismerj\u00fck meg. Az alapfolyamat a k\u00f6vetkez\u0151: Kapcsolat l\u00e9trehoz\u00e1sa az alkalmaz\u00e1s illetve az adatb\u00e1zis kezel\u0151 rendszer k\u00f6z\u00f6tt ( Connection objektum felhaszn\u00e1l\u00e1s\u00e1val) A futtatand\u00f3 SQL utas\u00edt\u00e1s \u00f6ssze\u00e1ll\u00edt\u00e1s ( Command objektum felhaszn\u00e1l\u00e1s\u00e1val) Utas\u00edt\u00e1s futtat\u00e1sa ( Command objektum felhaszn\u00e1l\u00e1s\u00e1val) Lek\u00e9rdez\u00e9sek eset\u00e9n a visszakapott rekordhalmaz feldolgoz\u00e1sa ( DataReader objektum felhaszn\u00e1l\u00e1s\u00e1val). Erre a m\u00f3dos\u00edt\u00f3 parancsok eset\u00e9n \u00e9rtelemszer\u0171en nincs sz\u00fcks\u00e9g. Kapcsolat lez\u00e1r\u00e1sa Mint a fentiekb\u0151l kider\u00fcl, az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3nak ebben a modellben h\u00e1rom f\u0151 \u00f6sszetev\u0151je van: Connection Command Data Reader Ezek az \u00f6sszetev\u0151k egy-egy oszt\u00e1lyk\u00e9nt jelennek meg, adatb\u00e1ziskezel\u0151f\u00fcggetlen r\u00e9sz\u00fck a System.Data.dll -ben tal\u00e1lhat\u00f3 DbConnection , DbCommand , illetve DbDataReader n\u00e9ven. Ezek absztrakt oszt\u00e1lyok, az adatb\u00e1ziskezel\u0151k gy\u00e1rt\u00f3inak feladata, hogy ezekb\u0151l lesz\u00e1rmazva meg\u00edrj\u00e1k a konkr\u00e9t adatb\u00e1ziskezel\u0151ket t\u00e1mogat\u00f3 v\u00e1ltozatokat. A Microsoftt SQL Servert t\u00e1mogat\u00f3 v\u00e1ltozatok szint\u00e9n a System.Data.dll -ben, \u201eSql\u201d prefix\u0171 oszt\u00e1lyokban tal\u00e1lhat\u00f3k ( SqlConnection , SqlCommand \u00e9s SqlDataReader ). A t\u00f6bbi gy\u00e1rt\u00f3 k\u00fcl\u00f6n dll-(ek)be teszi a saj\u00e1t v\u00e1ltozat\u00e1t, az \u00edgy l\u00e9trej\u00f6tt komponenst data providernek nevezik. Tal\u00e1lhat\u00f3 m\u00e9g a System.Data.dll -ben Oracle adatb\u00e1ziskezel\u0151t t\u00e1mogat\u00f3 provider is, azonban ez m\u00e1r elavult. N\u00e9h\u00e1ny tov\u00e1bbi gy\u00e1rt\u00f3 ADO.NET adatb\u00e1zis providere a teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl: ODP.NET (Oracle), MySqlConnector/Net (MySQL), Npgsql (PostgreSQL), System.Data.SQLite (SQLite) Mindh\u00e1rom ADO.NET \u00f6sszetev\u0151 t\u00e1mogatja a Dispose mint\u00e1t, \u00edgy using blokkban haszn\u00e1lhat\u00f3 \u2013 haszn\u00e1ljuk is \u00edgy, amikor csak tudjuk. Az adatb\u00e1ziskezel\u0151 \u00e1ltal\u00e1ban m\u00e1sik g\u00e9pen tal\u00e1lhat\u00f3, mint ahol a k\u00f3dunk fut (a m\u00e9r\u00e9s sor\u00e1n pont nem :)), \u00edgy tekints\u00fcnk ezekre, mint t\u00e1voli h\u00e1l\u00f3zati er\u0151forr\u00e1sokra.","title":"A kapcsolatalap\u00fa modell"},{"location":"labor/5-adatkezeles/#connection","text":"Ez teremti meg a kapcsolatot a programunk, illetve az adatb\u00e1ziskezel\u0151-rendszer k\u00f6z\u00f6tt Inicializ\u00e1l\u00e1s\u00e1hoz sz\u00fcks\u00e9g van egy connection string-re, ami a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9hez sz\u00fcks\u00e9ges adatokat adja meg a driver sz\u00e1m\u00e1ra. Adatb\u00e1zisgy\u00e1rt\u00f3nk\u00e9nt elt\u00e9r\u0151 bels\u0151 form\u00e1tuma van (b\u0151vebben: http://www.connectionstrings.com ). \u00daj Connection p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem biztos, hogy t\u00e9nyleg \u00faj kapcsolat fog l\u00e9trej\u00f6nni az adatb\u00e1zis fel\u00e9, a driverek \u00e1ltal\u00e1ban connection pooling-ot alkalmaznak, hasonl\u00f3an, mint a thread pool eset\u00e9ben, \u00fajrahaszn\u00e1lhatj\u00e1k a kor\u00e1bbi (\u00e9ppen nem haszn\u00e1lt) kapcsolatokat.","title":"Connection"},{"location":"labor/5-adatkezeles/#command","text":"Ennek seg\u00edts\u00e9g\u00e9vel vagyunk k\u00e9pesek \u201eutas\u00edt\u00e1sokat\u201d megfogalmazni az adatb\u00e1zis kezel\u0151 sz\u00e1m\u00e1ra. Ezeket SQL nyelven kell megfogalmaznunk. A Command -nak be kell \u00e1ll\u00edtani egy kapcsolatot \u2013 ezen kereszt\u00fcl fog a parancs v\u00e9grehajt\u00f3dni. A parancsnak k\u00fcl\u00f6nb\u00f6z\u0151 eredm\u00e9nye lehet, ennek megfelel\u0151en k\u00fcl\u00f6nb\u00f6z\u0151 f\u00fcggv\u00e9nyekkel s\u00fctj\u00fck el a parancsot: ExecuteReader : Eredm\u00e9nyhalmaz (result set) lek\u00e9rdez\u00e9se ExecuteScalar : Skal\u00e1r \u00e9rt\u00e9k lek\u00e9rdez\u00e9se ExecuteNonQuery : Nincs visszat\u00e9r\u00e9si \u00e9rt\u00e9k (Pl: INSERT), viszont a m\u0171velet k\u00f6vetkezt\u00e9ben \u00e9rintett rekordok sz\u00e1m\u00e1t visszakapjuk","title":"Command"},{"location":"labor/5-adatkezeles/#data-reader","text":"Ha a parancs eredm\u00e9nye eredm\u00e9nyhalmaz, akkor ennek a komponensnek a seg\u00edts\u00e9g\u00e9vel tudjuk az adatokat kiolvasni. Az eredm\u00e9nyhalmaz egy t\u00e1bl\u00e1zatnak tekinthet\u0151, a Data Reader ezen tud kurzoros m\u00f3dszerrel soronk\u00e9nt v\u00e9gignavig\u00e1lni (csak el\u0151refel\u00e9!). A kurzor egyszerre egy soron \u00e1ll, ha a sorb\u00f3l a sz\u00fcks\u00e9ges adatokat kiolvastuk, a kurzort egy sorral el\u0151re l\u00e9ptethetj\u00fck. Csak az aktu\u00e1lis sorb\u00f3l tudunk olvasni. Kezdetben a kurzor nem az els\u0151 soron \u00e1ll, azt egyszer l\u00e9ptetn\u00fcnk kell, hogy az els\u0151 sorra \u00e1lljon. Megjegyz\u00e9s: navig\u00e1l\u00e1s kliens oldalon t\u00f6rt\u00e9nik a mem\u00f3ri\u00e1ban, nincs k\u00f6ze az egyes adatkezel\u0151k \u00e1ltal t\u00e1mogatott kiszolg\u00e1l\u00f3 oldali kurzorokhoz.","title":"Data Reader"},{"location":"labor/5-adatkezeles/#1-feladat-adatbazis-elokeszitese","text":"Els\u0151k\u00e9nt sz\u00fcks\u00e9g\u00fcnk van egy adatb\u00e1ziskezel\u0151re. Ezt val\u00f3s k\u00f6rnyezetben dedik\u00e1lt szerveren fut\u00f3, adatb\u00e1zis adminisztr\u00e1torok \u00e1ltal fel\u00fcgyelt, teljes\u00e9rt\u00e9k\u0171 adatb\u00e1ziskezel\u0151k jelentik. Fejleszt\u00e9si id\u0151ben, lok\u00e1lis tesztel\u00e9shez azonban k\u00e9nyelmesebb fejleszt\u0151i adatb\u00e1ziskezel\u0151 haszn\u00e1lata. A Visual Studio telep\u00edt\u00e9s\u00e9nek r\u00e9szek\u00e9nt kapunk is egy ilyen adatb\u00e1zis engine-t, ez a LocalDB, ami a teljes\u00e9rt\u00e9k\u0171 SQL Server egyszer\u0171s\u00edtett v\u00e1ltozata. F\u0151bb tulajdons\u00e1gai: nem csak a Visual Studio-val, hanem k\u00fcl\u00f6n is telep\u00edthet\u0151 az adatb\u00e1zismotor szinte teljes m\u00e9rt\u00e9kben kompatibilis a teljes\u00e9rt\u00e9k\u0171 Microsoft SQL Serverrel alapvet\u0151en arr\u00f3l a g\u00e9pr\u0151l \u00e9rhet\u0151 el, amire telep\u00edtett\u00fck t\u00f6bb p\u00e9ld\u00e1ny is l\u00e9trehozhat\u00f3 ig\u00e9ny szerint, a p\u00e9ld\u00e1nyok alapvet\u0151en a l\u00e9trehoz\u00f3 oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3ja sz\u00e1m\u00e1ra \u00e9rhet\u0151 el (ig\u00e9ny eset\u00e9n megoszthat\u00f3 egy p\u00e9ld\u00e1ny a felhaszn\u00e1l\u00f3k k\u00f6z\u00f6tt) a saj\u00e1t p\u00e9ld\u00e1nyok kezel\u00e9se (l\u00e9trehoz\u00e1s, t\u00f6rl\u00e9s, stb.) nem ig\u00e9nyel adminisztr\u00e1tori jogokat ssqllocaldb parancssori eszk\u00f6z \u00c9rdekess\u00e9g, (ezeket a gyakorlaton nem kell elmondani), csak a lehet\u0151s\u00e9get eml\u00edts\u00fck meg. A p\u00e9ld\u00e1nyok kezel\u00e9s\u00e9re az sqllocaldb parancssori eszk\u00f6z haszn\u00e1lhat\u00f3. N\u00e9h\u00e1ny parancs, melyet az sqllocaldb ut\u00e1n be\u00edrva alkalmazhatunk : Paracs Le\u00edr\u00e1s info az aktu\u00e1lis felhaszn\u00e1\u00e1l\u00f3 sz\u00e1m\u00e1ra l\u00e1that\u00f3 p\u00e9ld\u00e1nyok list\u00e1ja create \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny t\u00f6rl\u00e9se start \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny ind\u00edt\u00e1sa stop \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny le\u00e1ll\u00edt\u00e1sa A Visual Studio is vesz fel, illetve ind\u00edt LocalDB p\u00e9ld\u00e1nyokat, ez\u00e9rt \u00e9rdemes megn\u00e9zni, hogy a Visual Studio alapb\u00f3l milyen p\u00e9ld\u00e1nyokat l\u00e1t. Ind\u00edtsuk el a Visual Studio-t, a View men\u00fcb\u0151l v\u00e1lasszuk az SQL Server Object Explorer-t (SSOE). Nyissuk ki az SQL Server csom\u00f3pontot, ha alatta l\u00e1tunk tov\u00e1bbi csom\u00f3pontokat, akkor nyert \u00fcgy\u00fcnk van, nyissuk ki valamelyiket (ilyenkor indul el a p\u00e9ld\u00e1ny, ha nincs elind\u00edtva, \u00edgy lehet, hogy v\u00e1rni kell kicsit) Ha nem jelent meg semmi, akkor parancssorb\u00f3l az mssqllocaldb info parancs megadja a l\u00e9tez\u0151 p\u00e9ld\u00e1nyokat. V\u00e1lasszuk az SQL Server csom\u00f3ponton jobbklikkelve az Add SQL Server opci\u00f3t, majd adjuk meg valamelyik l\u00e9tez\u0151 p\u00e9ld\u00e1nyt, pl.: (localdb)\\MSSQLLocalDB A megjelen\u0151 Databases csom\u00f3ponton v\u00e1lasszuk a New Database opci\u00f3t, itt adjunk meg egy adatb\u00e1zisnevet. (Laboron, mivel t\u00f6bb hallgat\u00f3 is haszn\u00e1lhatja ugyanazt az oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3t, \u00edgy javasolt a neptunk\u00f3d mint n\u00e9v haszn\u00e1lata.) Az \u00faj adatb\u00e1zis csom\u00f3pontj\u00e1n jobbklikkelve v\u00e1lasszuk a New Query opci\u00f3t, ami egy \u00faj query ablakot nyit A t\u00e1rgyhonlapr\u00f3l nyissuk meg vagy t\u00f6lts\u00fck le a Northwind adatb\u00e1zis inicializ\u00e1l\u00f3 szkriptet (a publikus anyagok k\u00f6z\u00f6tt tal\u00e1lhat\u00f3, \u201eNorthwind p\u00e9ldaadatb\u00e1zis\u201d n\u00e9ven) M\u00e1soljuk be a teljes szkriptet a query ablakba A szkript elej\u00e9n a megadott helyen \u00edrjuk be az adatb\u00e1zisunk nev\u00e9t Futtassuk le a szkriptet a kis z\u00f6ld ny\u00edllal ( Execute ) Ellen\u0151rizz\u00fck, hogy az adatb\u00e1zisunk ban megjelentek-e t\u00e1bl\u00e1k, n\u00e9zetek Fedezz\u00fck fel az SSOE legfontosabb funkci\u00f3it (t\u00e1bl\u00e1k adatainak, s\u00e9m\u00e1j\u00e1nak lek\u00e9rdez\u00e9se stb.) Note A Visual Studio-ban k\u00e9t eszk\u00f6zzel is kezelhet\u00fcnk adatb\u00e1zisokat: a Server Explorer-rel \u00e9s az SQL Server Object Explorer-rel is. El\u0151bbi egy \u00e1ltal\u00e1nosabb eszk\u00f6z, mely nem csak adatb\u00e1zis, hanem egy\u00e9b szerver er\u0151forr\u00e1sok (pl. Azure szerverek) kezel\u00e9s\u00e9re is alkalmas, m\u00edg a m\u00e1sik kifejezetten csak adatb\u00e1ziskezel\u00e9sre van kihegyezve. Mindkett\u0151 el\u00e9rhet\u0151 a View men\u00fcb\u0151l \u00e9s mindkett\u0151 hasonl\u00f3 funkci\u00f3kat ad adatb\u00e1ziskezel\u00e9shez, ez\u00e9rt ebben a m\u00e9r\u00e9sben csak az egyiket (SQL Server Object Explorer) haszn\u00e1ljuk. Amikor nem \u00e1ll rendelkez\u00e9s\u00fcnkre a Visual Studio fejleszt\u0151k\u00f6rnyezet, akkor az adatb\u00e1zisunk menedzsel\u00e9s\u00e9re az (ingyenes) SQL Server Management Studio-t tudjuk haszn\u00e1lni.","title":"1. Feladat \u2013 Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se"},{"location":"labor/5-adatkezeles/#2-feladat-lekerdezes-adonet-sqldatareader-rel","text":"COMING SOON","title":"2. Feladat \u2013 Lek\u00e9rdez\u00e9s ADO.NET SqlDataReader-rel"},{"location":"labor/5-adatkezeles/#3-feladat-beszuras-sql-utasitassal","text":"COMING SOON","title":"3. Feladat \u2013 Besz\u00far\u00e1s SQL utas\u00edt\u00e1ssal"},{"location":"labor/5-adatkezeles/#4-feladat-modositas-tarolt-eljarassal","text":"COMING SOON","title":"4. Feladat - M\u00f3dos\u00edt\u00e1s t\u00e1rolt elj\u00e1r\u00e1ssal"},{"location":"labor/5-adatkezeles/#5-feladat-sql-injection","text":"COMING SOON","title":"5. Feladat - SQL Injection"},{"location":"labor/5-adatkezeles/#6-feladat-torles","text":"COMING SOON","title":"6. Feladat - T\u00f6rl\u00e9s"},{"location":"labor/5-adatkezeles/#kitekintes","text":"COMING SOON","title":"Kitekint\u00e9s"},{"location":"labor/5-adatkezeles/#fuggelek-adatbazisok-sql-nyelv-alapok","text":"Az adatb\u00e1ziskezel\u0151 rendszerek vil\u00e1g\u00e1ba \u00e9s az SQL nyelvbe betekint\u00e9st a kapcsol\u00f3d\u00f3 el\u0151ad\u00e1son, illetve az al\u00e1bbi hivatkoz\u00e1s alatt tal\u00e1lsz: Adatb\u00e1zisok, SQL nyelv alapok","title":"F\u00fcggel\u00e9k \u2013 Adatb\u00e1zisok, SQL nyelv alapok"},{"location":"labor/5-adatkezeles/adatbazisok-sql-alapok/","text":"Adatb\u00e1zisok, SQL nyelv alapok \u00b6 Adatb\u00e1zis kezel\u0151 rendszerek defin\u00edci\u00f3ja sokszor nem egyszer\u0171 feladat. Egy lehets\u00e9ges defin\u00edci\u00f3 a k\u00f6vetkez\u0151: COMING SOON","title":"Adatb\u00e1zisok, SQL nyelv alapok"},{"location":"labor/5-adatkezeles/adatbazisok-sql-alapok/#adatbazisok-sql-nyelv-alapok","text":"Adatb\u00e1zis kezel\u0151 rendszerek defin\u00edci\u00f3ja sokszor nem egyszer\u0171 feladat. Egy lehets\u00e9ges defin\u00edci\u00f3 a k\u00f6vetkez\u0151: COMING SOON","title":"Adatb\u00e1zisok, SQL nyelv alapok"},{"location":"labor/6-doc-view/","text":"6. Document-View architekt\u00fara \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.11.31 Kidolgozta: Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9ljai: UML alap\u00fa tervez\u00e9s \u00e9s n\u00e9h\u00e1ny tervez\u00e9si minta alkalmaz\u00e1sa A Document-View architekt\u00fara alkalmaz\u00e1sa a gyakorlatban UserControl szerep\u00e9nek bemutat\u00e1sa Window Forms alkalmaz\u00e1sokban, Document-View architekt\u00fara eset\u00e9n A grafikus megjelen\u00edt\u00e9s elveinek gyakorl\u00e1sa Window Forms alkalmaz\u00e1sokban (Paint esem\u00e9ny, Invalidate, Graphics haszn\u00e1lata) A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok \u00e9s kor\u00e1bbi gyakorlatok anyaga: UML alap\u00fa modellez\u00e9s (1. gyakorlat) Windows Forms alkalmaz\u00e1sfejleszt\u00e9s Szoftverarchitekt\u00far\u00e1k (Document-View architekt\u00fara) El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) A gyakorlat menete \u00b6 Az al\u00e1bbiak szerint fogunk dolgozni: A feladat/c\u00e9lok r\u00f6vid ismertet\u00e9se: egy interakt\u00edv fonteditor (bet\u0171t\u00edpus-szerkeszt\u0151) megtervez\u00e9se. A k\u00e9sz alkalmaz\u00e1st futtatva a feladat (a k\u00e9sz alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9nek) ismertet\u00e9se Az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1nak megtervez\u00e9se (oszt\u00e1lydiagram elk\u00e9sz\u00edt\u00e9se) A k\u00e9sz alkalmaz\u00e1s forr\u00e1sk\u00f3dj\u00e1nak alapj\u00e1n n\u00e9h\u00e1ny fontosabb forgat\u00f3k\u00f6nyv megval\u00f3s\u00edt\u00e1s\u00e1nak \u00e1ttekint\u00e9se Megjegyz\u00e9s gyakorlatvezet\u0151k sz\u00e1m\u00e1ra A gyakorlat elej\u00e9n t\u00f6lts\u00fck le a k\u00e9sz alkalmaz\u00e1st. A hallgat\u00f3k ekkor m\u00e9g ne t\u00f6lts\u00e9k le, ne ezt kattintgass\u00e1k, majd csak a gyakorlat m\u00e1sodik r\u00e9sz\u00e9ben. A gyakorlatvezet\u0151knek viszont sz\u00fcks\u00e9ge lesz r\u00e1, mert ennek seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik az feladat bemutat\u00e1sa. 1. Feladat - A feladat ismertet\u00e9se \u00b6 Interakt\u00edv FontEditor k\u00e9sz\u00edt\u00e9se, amelyben lehet szerkeszteni a karaktereket, \u00e9s a karakterekb\u0151l \u00e1ll\u00f3 fontokb\u00f3l tetsz\u0151leges p\u00e9ldasz\u00f6veg jelen\u00edthet\u0151 meg. Az alkalmaz\u00e1s felhaszn\u00e1l\u00f3i fel\u00fclete fut\u00e1s k\u00f6zben: A k\u00f6vetkez\u0151 funkci\u00f3kat kell t\u00e1mogatnia: T\u00f6bb bet\u0171t\u00edpus egyidej\u0171 szerkeszt\u00e9se. Ez egyes bet\u0171t\u00edpusok k\u00fcl\u00f6n tab oldalakon szerkeszthet\u0151k (MDI \u2013 Multiple Document Interface). \u00daj bet\u0171t\u00edpus a File/New men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1val hozhat\u00f3 l\u00e9tre (meg kell adni a nev\u00e9t). Ez egyes bet\u0171t\u00edpusok elmenthet\u0151k ( File/Save ), bet\u00f6lthet\u0151k ( File/Open ), \u00e9s az aktu\u00e1lis dokumentum bez\u00e1rhat\u00f3 ( File/Close ). Ezek helye megvan az alkalmaz\u00e1sban, de nincsenek r\u00e9szleteiben implement\u00e1lva (a f\u00fcggv\u00e9nyek t\u00f6rzse nincs kit\u00f6ltve \u2013 opcion\u00e1lis HF). A felhaszn\u00e1l\u00f3i fel\u00fclet fel\u00e9p\u00edt\u00e9se Az oldalak tetej\u00e9n egy mintasz\u00f6veg adhat\u00f3 meg, melyet az aktu\u00e1lis bet\u0171t\u00edpussal az alkalmaz\u00e1s megjelen\u00edt. Az oldalak k\u00f6zep\u00e9n egy karakters\u00e1v tal\u00e1lhat\u00f3. Egy adott karakteren dupl\u00e1n kattintva alatta megjelenik egy az adott karakterhez tartoz\u00f3 szerkeszt\u0151n\u00e9zet. Az oldal alj\u00e1n egym\u00e1s mellett az eddig szerkeszt\u00e9sre megnyitott karakterek szerkeszt\u0151n\u00e9zetei l\u00e1that\u00f3k. Egy karakter t\u00f6bbsz\u00f6r is megnyithat\u00f3 szerkeszt\u00e9sre, ez esetben t\u00f6bb szerkeszt\u0151n\u00e9zet j\u00f6n l\u00e9tre hozz\u00e1. Ennek az az \u00e9rtelme, hogy ugyanazt a karaktert k\u00fcl\u00f6nb\u00f6z\u0151 nagy\u00edt\u00e1ssal is l\u00e1thatjuk/szerkeszthetj\u00fck. A szerkeszt\u0151n\u00e9zetek fel\u00e9p\u00edt\u00e9se Nagy r\u00e9sze (eltekintve a fels\u0151 s\u00e1v) a szerkeszt\u0151fel\u00fclet, ahol fekete h\u00e1tt\u00e9ren s\u00e1rg\u00e1val jelennek meg az akt\u00edv pixelek. Egy adott pixelen az eg\u00e9rrel kattintva a pixel invert\u00e1l\u00f3dik. Bal fels\u0151 sarokban a megjelen\u00edtett karakter l\u00e1that\u00f3 \u2019c\u2019 gomb: Clear, minden akt\u00edv pixelt t\u00f6r\u00f6l \u2019+\u2019 gomb: nagy\u00edt\u00e1s \u2019-\u2019 gomb: kicsiny\u00edt\u00e9s Futtassuk az alkalmaz\u00e1st, \u00e9s ismertess\u00fck m\u0171k\u00f6d\u00e9s\u00e9t a fentieknek megfelel\u0151en. Azt mindenk\u00e9ppen mutassuk meg, hogy ha egy karakter szerepel a mintasz\u00f6vegben, valamint t\u00f6bbsz\u00f6r megnyitjuk szerkeszt\u00e9sre, akkor az egyik n\u00e9zetben v\u00e1ltoztatva (egy pixelt invert\u00e1lva) valamennyi n\u00e9zete friss\u00fcl. Az alkalmaz\u00e1s a k\u00f3dmennyis\u00e9g minim\u00e1lis \u00e9rt\u00e9ken tart\u00e1sa \u00e9rdek\u00e9ben minimalisztikus, pl. a hibakezel\u00e9s nincs \u00e1ltal\u00e1noss\u00e1g\u00e1ban kidolgozva, hi\u00e1nyoznak ellen\u0151rz\u00e9sek. Ugyanakkor viszonylag j\u00f3l kommentezett, ami seg\u00edti a k\u00f3d ut\u00f3lagos meg\u00e9rt\u00e9s\u00e9t. 2. Feladat - Az alkalmaz\u00e1s megtervez\u00e9se \u00b6 COMING SOON 3. Feladat - A k\u00e9sz alkalmaz\u00e1s \u00e1ttekint\u00e9se \u00b6 Az al\u00e1bbiakra min. 15 perc kell maradjon, abba sz\u0171ken bele lehet f\u00e9rni. Id\u0151 hi\u00e1ny\u00e1ban nem val\u00f3s\u00edtjuk meg az alkalmaz\u00e1st, hanem a k\u00e9sz megold\u00e1st n\u00e9zz\u00fck \u00e1t, annak is csak n\u00e9h\u00e1ny l\u00e9nyeges haszn\u00e1lati eset\u00e9t (forgat\u00f3k\u00f6nyv). Most m\u00e1r a hallgat\u00f3k is t\u00f6lts\u00e9k le a k\u00e9sz megold\u00e1st, nyiss\u00e1k meg a k\u00e9sz solution-t, futtass\u00e1k/pr\u00f3b\u00e1lj\u00e1k ki az alkalmaz\u00e1st. N\u00e9zetek megval\u00f3s\u00edt\u00e1sa \u00b6 Nyissuk meg a FontEditorView -t, el\u0151sz\u00f6r a k\u00f3dot n\u00e9zz\u00fck. A FontEditorView egyr\u00e9szt implement\u00e1lja az IV i ew interf\u00e9szt, de m\u00e1sr\u00e9szt a UserControl -b\u00f3l sz\u00e1rmazik. M\u00e9gpedig az\u00e9rt, mert \u00edgy a tervez\u0151ben (designer) tudjuk kialak\u00edtani a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t, pont \u00fagy, mint egy \u0171rlapnak. Nyissuk most meg tervez\u0151i n\u00e9zetben, \u00e9s mondjuk el, hogy a c\u00edmk\u00e9t \u00e9s gombokat a Toolboxr\u00f3l tett\u00fck r\u00e1. Rendezz\u00fck is \u00e1t egy kicsit \u0151ket, majd futtassuk az alkalmaz\u00e1st (el\u00e9g, ha mi megtessz\u00fck, a hallgat\u00f3k nem kell k\u00f6vess\u00e9k), hogy \u00e9rezhet\u0151 legyen, mir\u0151l van sz\u00f3. A SampleTextView is \u00edgy van megval\u00f3s\u00edtva, b\u00e1r annak egyszer\u0171 a fel\u00fclete, lehetett volna k\u00f6z\u00f6ns\u00e9ges Control lesz\u00e1rmazott is. Vonjuk le a tanuls\u00e1got: Windows Forms k\u00f6rnyezetben a n\u00e9zeteket tipikusan UserControl -k\u00e9nt (esetleg Control -k\u00e9nt) c\u00e9lszer\u0171 megval\u00f3s\u00edtani. Egy oldal (tab) elrendez\u00e9se \u00b6 Futtassuk az alkalmaz\u00e1st. Valahogy ki kell alak\u00edtsuk egy adott oldal (tabpage) elrendez\u00e9s\u00e9t. Lehet\u0151leg tervez\u0151i n\u00e9zetben, \u00e9s nem fut\u00e1s k\u00f6zben, k\u00f3db\u00f3l poz\u00edcion\u00e1lva az elemeket (legal\u00e1bbis ahol nem musz\u00e1j). A UserControl -ok alkalmaz\u00e1sa jelenti sz\u00e1munkra a megold\u00e1st. Nyissuk meg a FontDocumentControl -t tervez\u0151i n\u00e9zetben. Ez egy olyan control, amely egy taboldalra ker\u00fcl fel, azt t\u00f6lti ki teljesen. Az oldalt a m\u00e1r ismert layout technik\u00e1kkal alak\u00edtottuk ki ( Label , TextBox , Panel -ek Dock-kolva). Ha van id\u0151nk, akkor n\u00e9zz\u00fck meg a Document Outline ablakban. Az igazi \u201epo\u00e9n\u201d pedig az, hogy a SampleTextView -t is a Toolbox-r\u00f3l drag&drop-pal tett\u00fck fel. Annyit n\u00e9zz\u00fcnk meg, hogy val\u00f3ban ott van a Toolbox tetej\u00e9n. Forgat\u00f3k\u00f6nyv 1 \u2013 egy pixel invert\u00e1l\u00e1sa, n\u00e9zetek szinkroniz\u00e1l\u00e1sa \u00b6 \u00d6n\u00e1ll\u00f3 feladat a hallgat\u00f3knak. Keress\u00e9k meg azt a f\u00fcggv\u00e9nyt, ahol az eg\u00e9sz folyamat elindul. A FontEditorView.FontEditorView_MouseClick -be kellene eljutni. Itt egy sor a l\u00e9nyeg: private void FontEditorView_MouseClick ( object sender , MouseEventArgs e ) { int x = e . X / zoom ; int y = ( e . Y - offsetY )/ zoom ; if ( x >= CharDef . FontSize . Width ) return ; document . InvertCharDefPixel ( editedChar , x , y ); } N\u00e9zz\u00fck meg a FontEditorDocument.InvertCharDefPixel -t. Invert\u00e1lja a megfelel\u0151 CharDef pixel\u00e9t, de a l\u00e9nyeg az utols\u00f3 sor: public void InvertCharDefPixel ( char c , int x , int y ) { CharDef fd = GetCharDef ( c ); fd . Pixels [ x , y ] = ! fd . Pixels [ x , y ]; UpdateAllViews (); } A FontEditorDocument -ben vethet\u00fcnk m\u00e9g egy pillant\u00e1st a CharDef -ek sz\u00f3t\u00e1r\u00e1ra: Dictionary < char , CharDef > charDefs = new Dictionary < char , CharDef >(); Az UpdateAllViews a Document \u0151sben van, Update -et h\u00edv minden n\u00e9zetre. Ami \u00e9rdekes, hogy az Update hogy van meg\u00edrva az egyes n\u00e9zetekben. N\u00e9zz\u00fck meg pl. a FontEditView -t: /// <summary> /// Az IView interf\u00e9sz Update m\u0171velet\u00e1nek implement\u00e1ci\u00f3ja. /// </summary> public void Update () { Invalidate (); } Az Update hat\u00e1s\u00e1ra a n\u00e9zetek \u00fajra kell rajzolj\u00e1k magukat az aktu\u00e1lis dokumentum \u00e1llapot alapj\u00e1n. De az Update -ben nem tudunk rajzolni, csak a \u201ePaint\u201d-ben. \u00cdgy itt az Invalidate h\u00edv\u00e1ssal kiv\u00e1ltjuk a Paint esem\u00e9nyt. Ez megint egy tanuls\u00e1g: Windows Forms alkalmaz\u00e1sokban az Update f\u00fcggv\u00e9nyben tipikusan Invalidate h\u00edv\u00e1s szokott lenni. Z\u00e1r\u00e1sk\u00e9ppen n\u00e9zz\u00fck meg a FontEditView.Paint megval\u00f3s\u00edt\u00e1s\u00e1t. Egyetlen l\u00e9nyeges dolog van itt: a megjelen\u00edt\u00e9shez le kell k\u00e9rni a dokumentumt\u00f3l az aktu\u00e1lis CharDef -et (mert a n\u00e9zet a D-V architekt\u00far\u00e1nak megfelel\u0151en nem t\u00e1rolja). /// <summary> /// A UserControl.Paint fel\u00fcldefini\u00e1l\u00e1sa, ebben rajzolunk. /// </summary> protected override void OnPaint ( PaintEventArgs e ) { base . OnPaint ( e ); CharDef editedCharDef = document . GetCharDef ( editedChar ); for ( int y = 0 ; y < CharDef . FontSize . Height ; y ++) { for ( int x = 0 ; x < CharDef . FontSize . Width ; x ++) { e . Graphics . FillRectangle ( editedCharDef . Pixels [ x , y ] ? Brushes . Yellow : Brushes . Black , zoom * x , offsetY + zoom * y , zoom , zoom ); } } } Forgat\u00f3k\u00f6nyv 2 \u2013 \u00daj dokumentum l\u00e9trehoz\u00e1sa \u00b6 Erre a feladatra val\u00f3sz\u00edn\u0171leg nem marad m\u00e1r id\u0151. Azt n\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik egy \u00faj dokumentum l\u00e9trehoz\u00e1sa, vagyis mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor. Nyissuk meg a MainForm-ot tervez\u0151i n\u00e9zetben, v\u00e1laszuk a File/New men\u00fcelemet, hogy ugorjunk el a Click esem\u00e9nykezel\u0151h\u00f6z. Arra l\u00e1tunk p\u00e9ld\u00e1t, hogy az App oszt\u00e1ly, mint Singleton, hogy \u00e9rhet\u0151 el: App . Instance . NewDocument (); Az \u00f6sszes t\u00f6bbi men\u00fcelem esem\u00e9nykezel\u0151je hasonl\u00f3, nincs semmi logika a GUI-ban, csak egyszer\u0171 tov\u00e1bbh\u00edv\u00e1s az App -ba. Tekints\u00fck \u00e1t az az App.NewDocument t\u00f6rzs\u00e9t, \u00e9s egy-egy mondatban tekints\u00fck \u00e1t (a gyakorlat sor\u00e1n sz\u00f3ban ismertess\u00fck) a fontosabb l\u00e9p\u00e9seket. Azt, hogy a TabControl -lal mit \u00fcgyesked\u00fcnk, nem kell elmondani, nem kell tudni. /// <summary> /// L\u00e9trehoz egy \u00faj dokumentumot. /// </summary> public void NewDocument () { // Bek\u00e9rdezz\u00fck az \u00faj font t\u00edpus (dokumentum) nev\u00e9t a // felhaszn\u00e1l\u00f3t\u00f3l egy mod\u00e1lis dial\u00f3gs ablakban. NewDocForm form = new NewDocForm (); if ( form . ShowDialog () != DialogResult . OK ) return ; // \u00daj dokumentum objektum l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a // dokumentum list\u00e1ba. Document doc = new FontEditorDocument ( form . FontName ); documents . Add ( doc ); // Az els\u0151 param\u00e9ter egy kulcs, a m\u00e1sodik a tab felirata // Egy \u00faj tabra felteszi a dokumentumhoz tartoz\u00f3 fel\u00fcletelemeket. // Ezeket egy UserControl, a FontDocumentControl fogja \u00f6ssze. // \u00cdgy csak ebb\u0151l kell egy p\u00e9ld\u00e1nyt az \u00faj tabpage-re feltenni. mainForm . TabControl . TabPages . Add ( form . FontName , form . FontName ); FontDocumentControl documentControl = new FontDocumentControl (); TabPage tp = mainForm . TabControl . TabPages [ form . FontName ]; tp . Controls . Add ( documentControl ); documentControl . Dock = DockStyle . Fill ; // SampleTextView beregisztr\u00e1l\u00e1sa a documentn\u00e1l, hogy // \u00e9rtes\u00fclj\u00f6n majd a dokumentum v\u00e1ltoz\u00e1sair\u00f3l. documentControl . SampleTextView . AttachToDoc ( doc ); // Az \u00faj tab legyen a kiv\u00e1lasztott. mainForm . TabControl . SelectTab ( tp ); // Az \u00faj tab lesz az akt\u00edv, az activeDocument // tagv\u00e1ltoz\u00f3t erre kell \u00e1ll\u00edtani. UpdateActiveDocument (); } Az App.OpenDocument nincs kit\u00f6ltve, de a l\u00e9p\u00e9sek be vannak \u00edrva, remek gyakorl\u00e1si lehet\u0151s\u00e9g a hallgat\u00f3knak otthon meg\u00edrni.","title":"6. Document-View architekt\u00fara"},{"location":"labor/6-doc-view/#6-document-view-architektura","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.11.31 Kidolgozta: Benedek Zolt\u00e1n","title":"6. Document-View architekt\u00fara"},{"location":"labor/6-doc-view/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9ljai: UML alap\u00fa tervez\u00e9s \u00e9s n\u00e9h\u00e1ny tervez\u00e9si minta alkalmaz\u00e1sa A Document-View architekt\u00fara alkalmaz\u00e1sa a gyakorlatban UserControl szerep\u00e9nek bemutat\u00e1sa Window Forms alkalmaz\u00e1sokban, Document-View architekt\u00fara eset\u00e9n A grafikus megjelen\u00edt\u00e9s elveinek gyakorl\u00e1sa Window Forms alkalmaz\u00e1sokban (Paint esem\u00e9ny, Invalidate, Graphics haszn\u00e1lata) A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok \u00e9s kor\u00e1bbi gyakorlatok anyaga: UML alap\u00fa modellez\u00e9s (1. gyakorlat) Windows Forms alkalmaz\u00e1sfejleszt\u00e9s Szoftverarchitekt\u00far\u00e1k (Document-View architekt\u00fara)","title":"A gyakorlat c\u00e9lja"},{"location":"labor/6-doc-view/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)","title":"El\u0151felt\u00e9telek"},{"location":"labor/6-doc-view/#a-gyakorlat-menete","text":"Az al\u00e1bbiak szerint fogunk dolgozni: A feladat/c\u00e9lok r\u00f6vid ismertet\u00e9se: egy interakt\u00edv fonteditor (bet\u0171t\u00edpus-szerkeszt\u0151) megtervez\u00e9se. A k\u00e9sz alkalmaz\u00e1st futtatva a feladat (a k\u00e9sz alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9nek) ismertet\u00e9se Az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1nak megtervez\u00e9se (oszt\u00e1lydiagram elk\u00e9sz\u00edt\u00e9se) A k\u00e9sz alkalmaz\u00e1s forr\u00e1sk\u00f3dj\u00e1nak alapj\u00e1n n\u00e9h\u00e1ny fontosabb forgat\u00f3k\u00f6nyv megval\u00f3s\u00edt\u00e1s\u00e1nak \u00e1ttekint\u00e9se Megjegyz\u00e9s gyakorlatvezet\u0151k sz\u00e1m\u00e1ra A gyakorlat elej\u00e9n t\u00f6lts\u00fck le a k\u00e9sz alkalmaz\u00e1st. A hallgat\u00f3k ekkor m\u00e9g ne t\u00f6lts\u00e9k le, ne ezt kattintgass\u00e1k, majd csak a gyakorlat m\u00e1sodik r\u00e9sz\u00e9ben. A gyakorlatvezet\u0151knek viszont sz\u00fcks\u00e9ge lesz r\u00e1, mert ennek seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik az feladat bemutat\u00e1sa.","title":"A gyakorlat menete"},{"location":"labor/6-doc-view/#1-feladat-a-feladat-ismertetese","text":"Interakt\u00edv FontEditor k\u00e9sz\u00edt\u00e9se, amelyben lehet szerkeszteni a karaktereket, \u00e9s a karakterekb\u0151l \u00e1ll\u00f3 fontokb\u00f3l tetsz\u0151leges p\u00e9ldasz\u00f6veg jelen\u00edthet\u0151 meg. Az alkalmaz\u00e1s felhaszn\u00e1l\u00f3i fel\u00fclete fut\u00e1s k\u00f6zben: A k\u00f6vetkez\u0151 funkci\u00f3kat kell t\u00e1mogatnia: T\u00f6bb bet\u0171t\u00edpus egyidej\u0171 szerkeszt\u00e9se. Ez egyes bet\u0171t\u00edpusok k\u00fcl\u00f6n tab oldalakon szerkeszthet\u0151k (MDI \u2013 Multiple Document Interface). \u00daj bet\u0171t\u00edpus a File/New men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1val hozhat\u00f3 l\u00e9tre (meg kell adni a nev\u00e9t). Ez egyes bet\u0171t\u00edpusok elmenthet\u0151k ( File/Save ), bet\u00f6lthet\u0151k ( File/Open ), \u00e9s az aktu\u00e1lis dokumentum bez\u00e1rhat\u00f3 ( File/Close ). Ezek helye megvan az alkalmaz\u00e1sban, de nincsenek r\u00e9szleteiben implement\u00e1lva (a f\u00fcggv\u00e9nyek t\u00f6rzse nincs kit\u00f6ltve \u2013 opcion\u00e1lis HF). A felhaszn\u00e1l\u00f3i fel\u00fclet fel\u00e9p\u00edt\u00e9se Az oldalak tetej\u00e9n egy mintasz\u00f6veg adhat\u00f3 meg, melyet az aktu\u00e1lis bet\u0171t\u00edpussal az alkalmaz\u00e1s megjelen\u00edt. Az oldalak k\u00f6zep\u00e9n egy karakters\u00e1v tal\u00e1lhat\u00f3. Egy adott karakteren dupl\u00e1n kattintva alatta megjelenik egy az adott karakterhez tartoz\u00f3 szerkeszt\u0151n\u00e9zet. Az oldal alj\u00e1n egym\u00e1s mellett az eddig szerkeszt\u00e9sre megnyitott karakterek szerkeszt\u0151n\u00e9zetei l\u00e1that\u00f3k. Egy karakter t\u00f6bbsz\u00f6r is megnyithat\u00f3 szerkeszt\u00e9sre, ez esetben t\u00f6bb szerkeszt\u0151n\u00e9zet j\u00f6n l\u00e9tre hozz\u00e1. Ennek az az \u00e9rtelme, hogy ugyanazt a karaktert k\u00fcl\u00f6nb\u00f6z\u0151 nagy\u00edt\u00e1ssal is l\u00e1thatjuk/szerkeszthetj\u00fck. A szerkeszt\u0151n\u00e9zetek fel\u00e9p\u00edt\u00e9se Nagy r\u00e9sze (eltekintve a fels\u0151 s\u00e1v) a szerkeszt\u0151fel\u00fclet, ahol fekete h\u00e1tt\u00e9ren s\u00e1rg\u00e1val jelennek meg az akt\u00edv pixelek. Egy adott pixelen az eg\u00e9rrel kattintva a pixel invert\u00e1l\u00f3dik. Bal fels\u0151 sarokban a megjelen\u00edtett karakter l\u00e1that\u00f3 \u2019c\u2019 gomb: Clear, minden akt\u00edv pixelt t\u00f6r\u00f6l \u2019+\u2019 gomb: nagy\u00edt\u00e1s \u2019-\u2019 gomb: kicsiny\u00edt\u00e9s Futtassuk az alkalmaz\u00e1st, \u00e9s ismertess\u00fck m\u0171k\u00f6d\u00e9s\u00e9t a fentieknek megfelel\u0151en. Azt mindenk\u00e9ppen mutassuk meg, hogy ha egy karakter szerepel a mintasz\u00f6vegben, valamint t\u00f6bbsz\u00f6r megnyitjuk szerkeszt\u00e9sre, akkor az egyik n\u00e9zetben v\u00e1ltoztatva (egy pixelt invert\u00e1lva) valamennyi n\u00e9zete friss\u00fcl. Az alkalmaz\u00e1s a k\u00f3dmennyis\u00e9g minim\u00e1lis \u00e9rt\u00e9ken tart\u00e1sa \u00e9rdek\u00e9ben minimalisztikus, pl. a hibakezel\u00e9s nincs \u00e1ltal\u00e1noss\u00e1g\u00e1ban kidolgozva, hi\u00e1nyoznak ellen\u0151rz\u00e9sek. Ugyanakkor viszonylag j\u00f3l kommentezett, ami seg\u00edti a k\u00f3d ut\u00f3lagos meg\u00e9rt\u00e9s\u00e9t.","title":"1. Feladat - A feladat ismertet\u00e9se"},{"location":"labor/6-doc-view/#2-feladat-az-alkalmazas-megtervezese","text":"COMING SOON","title":"2. Feladat - Az alkalmaz\u00e1s megtervez\u00e9se"},{"location":"labor/6-doc-view/#3-feladat-a-kesz-alkalmazas-attekintese","text":"Az al\u00e1bbiakra min. 15 perc kell maradjon, abba sz\u0171ken bele lehet f\u00e9rni. Id\u0151 hi\u00e1ny\u00e1ban nem val\u00f3s\u00edtjuk meg az alkalmaz\u00e1st, hanem a k\u00e9sz megold\u00e1st n\u00e9zz\u00fck \u00e1t, annak is csak n\u00e9h\u00e1ny l\u00e9nyeges haszn\u00e1lati eset\u00e9t (forgat\u00f3k\u00f6nyv). Most m\u00e1r a hallgat\u00f3k is t\u00f6lts\u00e9k le a k\u00e9sz megold\u00e1st, nyiss\u00e1k meg a k\u00e9sz solution-t, futtass\u00e1k/pr\u00f3b\u00e1lj\u00e1k ki az alkalmaz\u00e1st.","title":"3. Feladat - A k\u00e9sz alkalmaz\u00e1s \u00e1ttekint\u00e9se"},{"location":"labor/6-doc-view/#nezetek-megvalositasa","text":"Nyissuk meg a FontEditorView -t, el\u0151sz\u00f6r a k\u00f3dot n\u00e9zz\u00fck. A FontEditorView egyr\u00e9szt implement\u00e1lja az IV i ew interf\u00e9szt, de m\u00e1sr\u00e9szt a UserControl -b\u00f3l sz\u00e1rmazik. M\u00e9gpedig az\u00e9rt, mert \u00edgy a tervez\u0151ben (designer) tudjuk kialak\u00edtani a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t, pont \u00fagy, mint egy \u0171rlapnak. Nyissuk most meg tervez\u0151i n\u00e9zetben, \u00e9s mondjuk el, hogy a c\u00edmk\u00e9t \u00e9s gombokat a Toolboxr\u00f3l tett\u00fck r\u00e1. Rendezz\u00fck is \u00e1t egy kicsit \u0151ket, majd futtassuk az alkalmaz\u00e1st (el\u00e9g, ha mi megtessz\u00fck, a hallgat\u00f3k nem kell k\u00f6vess\u00e9k), hogy \u00e9rezhet\u0151 legyen, mir\u0151l van sz\u00f3. A SampleTextView is \u00edgy van megval\u00f3s\u00edtva, b\u00e1r annak egyszer\u0171 a fel\u00fclete, lehetett volna k\u00f6z\u00f6ns\u00e9ges Control lesz\u00e1rmazott is. Vonjuk le a tanuls\u00e1got: Windows Forms k\u00f6rnyezetben a n\u00e9zeteket tipikusan UserControl -k\u00e9nt (esetleg Control -k\u00e9nt) c\u00e9lszer\u0171 megval\u00f3s\u00edtani.","title":"N\u00e9zetek megval\u00f3s\u00edt\u00e1sa"},{"location":"labor/6-doc-view/#egy-oldal-tab-elrendezese","text":"Futtassuk az alkalmaz\u00e1st. Valahogy ki kell alak\u00edtsuk egy adott oldal (tabpage) elrendez\u00e9s\u00e9t. Lehet\u0151leg tervez\u0151i n\u00e9zetben, \u00e9s nem fut\u00e1s k\u00f6zben, k\u00f3db\u00f3l poz\u00edcion\u00e1lva az elemeket (legal\u00e1bbis ahol nem musz\u00e1j). A UserControl -ok alkalmaz\u00e1sa jelenti sz\u00e1munkra a megold\u00e1st. Nyissuk meg a FontDocumentControl -t tervez\u0151i n\u00e9zetben. Ez egy olyan control, amely egy taboldalra ker\u00fcl fel, azt t\u00f6lti ki teljesen. Az oldalt a m\u00e1r ismert layout technik\u00e1kkal alak\u00edtottuk ki ( Label , TextBox , Panel -ek Dock-kolva). Ha van id\u0151nk, akkor n\u00e9zz\u00fck meg a Document Outline ablakban. Az igazi \u201epo\u00e9n\u201d pedig az, hogy a SampleTextView -t is a Toolbox-r\u00f3l drag&drop-pal tett\u00fck fel. Annyit n\u00e9zz\u00fcnk meg, hogy val\u00f3ban ott van a Toolbox tetej\u00e9n.","title":"Egy oldal (tab) elrendez\u00e9se"},{"location":"labor/6-doc-view/#forgatokonyv-1-egy-pixel-invertalasa-nezetek-szinkronizalasa","text":"\u00d6n\u00e1ll\u00f3 feladat a hallgat\u00f3knak. Keress\u00e9k meg azt a f\u00fcggv\u00e9nyt, ahol az eg\u00e9sz folyamat elindul. A FontEditorView.FontEditorView_MouseClick -be kellene eljutni. Itt egy sor a l\u00e9nyeg: private void FontEditorView_MouseClick ( object sender , MouseEventArgs e ) { int x = e . X / zoom ; int y = ( e . Y - offsetY )/ zoom ; if ( x >= CharDef . FontSize . Width ) return ; document . InvertCharDefPixel ( editedChar , x , y ); } N\u00e9zz\u00fck meg a FontEditorDocument.InvertCharDefPixel -t. Invert\u00e1lja a megfelel\u0151 CharDef pixel\u00e9t, de a l\u00e9nyeg az utols\u00f3 sor: public void InvertCharDefPixel ( char c , int x , int y ) { CharDef fd = GetCharDef ( c ); fd . Pixels [ x , y ] = ! fd . Pixels [ x , y ]; UpdateAllViews (); } A FontEditorDocument -ben vethet\u00fcnk m\u00e9g egy pillant\u00e1st a CharDef -ek sz\u00f3t\u00e1r\u00e1ra: Dictionary < char , CharDef > charDefs = new Dictionary < char , CharDef >(); Az UpdateAllViews a Document \u0151sben van, Update -et h\u00edv minden n\u00e9zetre. Ami \u00e9rdekes, hogy az Update hogy van meg\u00edrva az egyes n\u00e9zetekben. N\u00e9zz\u00fck meg pl. a FontEditView -t: /// <summary> /// Az IView interf\u00e9sz Update m\u0171velet\u00e1nek implement\u00e1ci\u00f3ja. /// </summary> public void Update () { Invalidate (); } Az Update hat\u00e1s\u00e1ra a n\u00e9zetek \u00fajra kell rajzolj\u00e1k magukat az aktu\u00e1lis dokumentum \u00e1llapot alapj\u00e1n. De az Update -ben nem tudunk rajzolni, csak a \u201ePaint\u201d-ben. \u00cdgy itt az Invalidate h\u00edv\u00e1ssal kiv\u00e1ltjuk a Paint esem\u00e9nyt. Ez megint egy tanuls\u00e1g: Windows Forms alkalmaz\u00e1sokban az Update f\u00fcggv\u00e9nyben tipikusan Invalidate h\u00edv\u00e1s szokott lenni. Z\u00e1r\u00e1sk\u00e9ppen n\u00e9zz\u00fck meg a FontEditView.Paint megval\u00f3s\u00edt\u00e1s\u00e1t. Egyetlen l\u00e9nyeges dolog van itt: a megjelen\u00edt\u00e9shez le kell k\u00e9rni a dokumentumt\u00f3l az aktu\u00e1lis CharDef -et (mert a n\u00e9zet a D-V architekt\u00far\u00e1nak megfelel\u0151en nem t\u00e1rolja). /// <summary> /// A UserControl.Paint fel\u00fcldefini\u00e1l\u00e1sa, ebben rajzolunk. /// </summary> protected override void OnPaint ( PaintEventArgs e ) { base . OnPaint ( e ); CharDef editedCharDef = document . GetCharDef ( editedChar ); for ( int y = 0 ; y < CharDef . FontSize . Height ; y ++) { for ( int x = 0 ; x < CharDef . FontSize . Width ; x ++) { e . Graphics . FillRectangle ( editedCharDef . Pixels [ x , y ] ? Brushes . Yellow : Brushes . Black , zoom * x , offsetY + zoom * y , zoom , zoom ); } } }","title":"Forgat\u00f3k\u00f6nyv 1 \u2013 egy pixel invert\u00e1l\u00e1sa, n\u00e9zetek szinkroniz\u00e1l\u00e1sa"},{"location":"labor/6-doc-view/#forgatokonyv-2-uj-dokumentum-letrehozasa","text":"Erre a feladatra val\u00f3sz\u00edn\u0171leg nem marad m\u00e1r id\u0151. Azt n\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik egy \u00faj dokumentum l\u00e9trehoz\u00e1sa, vagyis mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor. Nyissuk meg a MainForm-ot tervez\u0151i n\u00e9zetben, v\u00e1laszuk a File/New men\u00fcelemet, hogy ugorjunk el a Click esem\u00e9nykezel\u0151h\u00f6z. Arra l\u00e1tunk p\u00e9ld\u00e1t, hogy az App oszt\u00e1ly, mint Singleton, hogy \u00e9rhet\u0151 el: App . Instance . NewDocument (); Az \u00f6sszes t\u00f6bbi men\u00fcelem esem\u00e9nykezel\u0151je hasonl\u00f3, nincs semmi logika a GUI-ban, csak egyszer\u0171 tov\u00e1bbh\u00edv\u00e1s az App -ba. Tekints\u00fck \u00e1t az az App.NewDocument t\u00f6rzs\u00e9t, \u00e9s egy-egy mondatban tekints\u00fck \u00e1t (a gyakorlat sor\u00e1n sz\u00f3ban ismertess\u00fck) a fontosabb l\u00e9p\u00e9seket. Azt, hogy a TabControl -lal mit \u00fcgyesked\u00fcnk, nem kell elmondani, nem kell tudni. /// <summary> /// L\u00e9trehoz egy \u00faj dokumentumot. /// </summary> public void NewDocument () { // Bek\u00e9rdezz\u00fck az \u00faj font t\u00edpus (dokumentum) nev\u00e9t a // felhaszn\u00e1l\u00f3t\u00f3l egy mod\u00e1lis dial\u00f3gs ablakban. NewDocForm form = new NewDocForm (); if ( form . ShowDialog () != DialogResult . OK ) return ; // \u00daj dokumentum objektum l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a // dokumentum list\u00e1ba. Document doc = new FontEditorDocument ( form . FontName ); documents . Add ( doc ); // Az els\u0151 param\u00e9ter egy kulcs, a m\u00e1sodik a tab felirata // Egy \u00faj tabra felteszi a dokumentumhoz tartoz\u00f3 fel\u00fcletelemeket. // Ezeket egy UserControl, a FontDocumentControl fogja \u00f6ssze. // \u00cdgy csak ebb\u0151l kell egy p\u00e9ld\u00e1nyt az \u00faj tabpage-re feltenni. mainForm . TabControl . TabPages . Add ( form . FontName , form . FontName ); FontDocumentControl documentControl = new FontDocumentControl (); TabPage tp = mainForm . TabControl . TabPages [ form . FontName ]; tp . Controls . Add ( documentControl ); documentControl . Dock = DockStyle . Fill ; // SampleTextView beregisztr\u00e1l\u00e1sa a documentn\u00e1l, hogy // \u00e9rtes\u00fclj\u00f6n majd a dokumentum v\u00e1ltoz\u00e1sair\u00f3l. documentControl . SampleTextView . AttachToDoc ( doc ); // Az \u00faj tab legyen a kiv\u00e1lasztott. mainForm . TabControl . SelectTab ( tp ); // Az \u00faj tab lesz az akt\u00edv, az activeDocument // tagv\u00e1ltoz\u00f3t erre kell \u00e1ll\u00edtani. UpdateActiveDocument (); } Az App.OpenDocument nincs kit\u00f6ltve, de a l\u00e9p\u00e9sek be vannak \u00edrva, remek gyakorl\u00e1si lehet\u0151s\u00e9g a hallgat\u00f3knak otthon meg\u00edrni.","title":"Forgat\u00f3k\u00f6nyv 2 \u2013 \u00daj dokumentum l\u00e9trehoz\u00e1sa"},{"location":"labor/7-tervezesi-mintak/","text":"7. Tervez\u00e9si mint\u00e1k \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.11.01 Kidolgozta: Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9ljai: Egy \u00f6sszetettebb p\u00e9lda alapj\u00e1n n\u00e9h\u00e1ny tervez\u00e9si minta gyakorlati alkalmaz\u00e1sa (els\u0151dlegesen Singleton, Command Processor \u00e9s Memento). A Document-View minta tov\u00e1bbi gyakorl\u00e1sa, illetve annak demonstr\u00e1l\u00e1sa, hogy a mint\u00e1nak t\u00f6bb vari\u00e1nsa l\u00e9tezik. Alapszint\u0171 betekint\u00e9st nyerni az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got t\u00e1mogat\u00f3 oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek fejleszt\u00e9s\u00e9nek vil\u00e1g\u00e1ba. Jelent\u0151s\u00e9g\u00fcknek megfelel\u0151en tov\u00e1bb gyakoroljuk az objektumorient\u00e1lt paradigma legfontosabb koncepci\u00f3it (pl. felel\u0151ss\u00e9gek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa). Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Tervez\u00e9si mint\u00e1k Szoftver architekt\u00far\u00e1k t\u00e9mak\u00f6rb\u0151l a Document-View architekt\u00fara Windows Forms alkalmaz\u00e1sok fejleszt\u00e9se El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) Bevezet\u0151 \u00b6 Elm\u00e9leti h\u00e1tt\u00e9r \u00b6 A komplexebb alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n sz\u00e1mos tervez\u0151i d\u00f6nt\u00e9st kell meghoznunk, melyek sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk. Amennyiben ezen pontokban olyan d\u00f6nt\u00e9seket hozunk, melyek nem k\u00f6vetik az objektumorient\u00e1lt szeml\u00e9letm\u00f3d alapelveit, nem tartjuk szem el\u0151tt az alkalmaz\u00e1sunk k\u00f6nny\u0171 karbantarthat\u00f3s\u00e1g\u00e1t, illetve egyszer\u0171en megval\u00f3s\u00edthat\u00f3 tov\u00e1bbfejleszt\u00e9si lehet\u0151s\u00e9g\u00e9t, k\u00f6nnyen hamar r\u00e9m\u00e1lomm\u00e1 v\u00e1lhat a fejleszt\u00e9s. Az egyes hib\u00e1k jav\u00edt\u00e1sa folyamatosan \u00faj hib\u00e1kat sz\u00fcl. Ezen fel\u00fcl a megrendel\u0151i v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyek a k\u00f3d nagym\u00e9rt\u00e9k\u0171 folyamatos \u00e1t\u00edr\u00e1s\u00e1t ig\u00e9nylik ahelyett, hogy a k\u00f3d p\u00e1r j\u00f3l meghat\u00e1rozott pontj\u00e1ban t\u00f6rt\u00e9n\u0151 b\u0151v\u00edt\u00e9s\u00e9vel - a megl\u00e9v\u0151 k\u00f3d jelent\u0151s m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl - el tudn\u00e1nk ezt \u00e9rni. A tervez\u00e9si mint\u00e1k j\u00f3l bev\u00e1lt megold\u00e1sokat mutatnak bizonyos gyakran el\u0151fordul\u00f3 tervez\u00e9si probl\u00e9m\u00e1kra: ezen megold\u00e1sok abban seg\u00edtenek, hogy k\u00f3dunk k\u00f6nnyebben b\u0151v\u00edthet\u0151, karbantarthat\u00f3 \u00e9s min\u00e9l nagyobb m\u00e9rt\u00e9kben \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. Ugyanakkor ne ess\u00fcnk \u00e1t a l\u00f3 t\u00faloldal\u00e1ra: csak akkor \u00e9rdemes egy adott tervez\u00e9si mint\u00e1t bevetni, ha adott esetben val\u00f3s el\u0151nyt jelent az alkalmaz\u00e1sa. Ellenkez\u0151 esetben csak a megval\u00f3s\u00edt\u00e1s komplexit\u00e1s\u00e1t n\u00f6veli feleslegesen. A feladat ismertet\u00e9se \u00b6 A feladatunk egy vektorgrafikus rajzol\u00f3program kifejleszt\u00e9se: Az alkalmaz\u00e1sban vektorgrafikus alakzatokat lehet l\u00e9trehozni, \u00fagymint t\u00e9glalap, ellipszis, stb. A m\u00e1r l\u00e9trehozott alakzatokat egy grafikus fel\u00fcleten meg kell jelen\u00edteni (ki kell rajzolni). A m\u00e1r l\u00e9trehozott alakzatok fontosabb param\u00e9tereit, \u00fagymint koordin\u00e1t\u00e1k, befoglal\u00f3 t\u00e9glalap meg kell jelen\u00edteni egy list\u00e1ban egy inform\u00e1ci\u00f3s panelen. Windows Forms technol\u00f3gi\u00e1ra \u00e9p\u00edtve dolgozunk. Document-View architekt\u00far\u00e1t k\u00f6vetj\u00fck, de egyszerre csak egy dokumentum lehet megnyitva (nincsenek dokumentumonk\u00e9nt tabf\u00fclek vagy ablakok). Egy adott pontig el\u0151k\u00e9sz\u00edtett k\u00f6rnyezetet visz\u00fcnk tov\u00e1bb. A munka mennyis\u00e9g\u00e9nek kezelhet\u0151 szinten tart\u00e1sa v\u00e9gett csak bizonyos pontig vissz\u00fck tov\u00e1bb a fejleszt\u00e9st, nem val\u00f3s\u00edtjuk meg a teljes \u00e9rt\u00e9k\u0171 megold\u00e1st. kiemelt h\u00e1tt\u00e9r jelzi. 1. Feladat - A kiindul\u00e1si k\u00f6rnyezet megismer\u00e9se \u00b6 COMING SOON 2. Feladat - Command Processor minta \u00b6 COMING SOON 3- Feladat \u2013 Memento minta \u00b6 COMING SOON","title":"7. Tervez\u00e9si mint\u00e1k"},{"location":"labor/7-tervezesi-mintak/#7-tervezesi-mintak","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.11.01 Kidolgozta: Benedek Zolt\u00e1n","title":"7. Tervez\u00e9si mint\u00e1k"},{"location":"labor/7-tervezesi-mintak/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9ljai: Egy \u00f6sszetettebb p\u00e9lda alapj\u00e1n n\u00e9h\u00e1ny tervez\u00e9si minta gyakorlati alkalmaz\u00e1sa (els\u0151dlegesen Singleton, Command Processor \u00e9s Memento). A Document-View minta tov\u00e1bbi gyakorl\u00e1sa, illetve annak demonstr\u00e1l\u00e1sa, hogy a mint\u00e1nak t\u00f6bb vari\u00e1nsa l\u00e9tezik. Alapszint\u0171 betekint\u00e9st nyerni az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got t\u00e1mogat\u00f3 oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek fejleszt\u00e9s\u00e9nek vil\u00e1g\u00e1ba. Jelent\u0151s\u00e9g\u00fcknek megfelel\u0151en tov\u00e1bb gyakoroljuk az objektumorient\u00e1lt paradigma legfontosabb koncepci\u00f3it (pl. felel\u0151ss\u00e9gek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa). Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Tervez\u00e9si mint\u00e1k Szoftver architekt\u00far\u00e1k t\u00e9mak\u00f6rb\u0151l a Document-View architekt\u00fara Windows Forms alkalmaz\u00e1sok fejleszt\u00e9se","title":"A gyakorlat c\u00e9lja"},{"location":"labor/7-tervezesi-mintak/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)","title":"El\u0151felt\u00e9telek"},{"location":"labor/7-tervezesi-mintak/#bevezeto","text":"","title":"Bevezet\u0151"},{"location":"labor/7-tervezesi-mintak/#elmeleti-hatter","text":"A komplexebb alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n sz\u00e1mos tervez\u0151i d\u00f6nt\u00e9st kell meghoznunk, melyek sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk. Amennyiben ezen pontokban olyan d\u00f6nt\u00e9seket hozunk, melyek nem k\u00f6vetik az objektumorient\u00e1lt szeml\u00e9letm\u00f3d alapelveit, nem tartjuk szem el\u0151tt az alkalmaz\u00e1sunk k\u00f6nny\u0171 karbantarthat\u00f3s\u00e1g\u00e1t, illetve egyszer\u0171en megval\u00f3s\u00edthat\u00f3 tov\u00e1bbfejleszt\u00e9si lehet\u0151s\u00e9g\u00e9t, k\u00f6nnyen hamar r\u00e9m\u00e1lomm\u00e1 v\u00e1lhat a fejleszt\u00e9s. Az egyes hib\u00e1k jav\u00edt\u00e1sa folyamatosan \u00faj hib\u00e1kat sz\u00fcl. Ezen fel\u00fcl a megrendel\u0151i v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyek a k\u00f3d nagym\u00e9rt\u00e9k\u0171 folyamatos \u00e1t\u00edr\u00e1s\u00e1t ig\u00e9nylik ahelyett, hogy a k\u00f3d p\u00e1r j\u00f3l meghat\u00e1rozott pontj\u00e1ban t\u00f6rt\u00e9n\u0151 b\u0151v\u00edt\u00e9s\u00e9vel - a megl\u00e9v\u0151 k\u00f3d jelent\u0151s m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl - el tudn\u00e1nk ezt \u00e9rni. A tervez\u00e9si mint\u00e1k j\u00f3l bev\u00e1lt megold\u00e1sokat mutatnak bizonyos gyakran el\u0151fordul\u00f3 tervez\u00e9si probl\u00e9m\u00e1kra: ezen megold\u00e1sok abban seg\u00edtenek, hogy k\u00f3dunk k\u00f6nnyebben b\u0151v\u00edthet\u0151, karbantarthat\u00f3 \u00e9s min\u00e9l nagyobb m\u00e9rt\u00e9kben \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. Ugyanakkor ne ess\u00fcnk \u00e1t a l\u00f3 t\u00faloldal\u00e1ra: csak akkor \u00e9rdemes egy adott tervez\u00e9si mint\u00e1t bevetni, ha adott esetben val\u00f3s el\u0151nyt jelent az alkalmaz\u00e1sa. Ellenkez\u0151 esetben csak a megval\u00f3s\u00edt\u00e1s komplexit\u00e1s\u00e1t n\u00f6veli feleslegesen.","title":"Elm\u00e9leti h\u00e1tt\u00e9r"},{"location":"labor/7-tervezesi-mintak/#a-feladat-ismertetese","text":"A feladatunk egy vektorgrafikus rajzol\u00f3program kifejleszt\u00e9se: Az alkalmaz\u00e1sban vektorgrafikus alakzatokat lehet l\u00e9trehozni, \u00fagymint t\u00e9glalap, ellipszis, stb. A m\u00e1r l\u00e9trehozott alakzatokat egy grafikus fel\u00fcleten meg kell jelen\u00edteni (ki kell rajzolni). A m\u00e1r l\u00e9trehozott alakzatok fontosabb param\u00e9tereit, \u00fagymint koordin\u00e1t\u00e1k, befoglal\u00f3 t\u00e9glalap meg kell jelen\u00edteni egy list\u00e1ban egy inform\u00e1ci\u00f3s panelen. Windows Forms technol\u00f3gi\u00e1ra \u00e9p\u00edtve dolgozunk. Document-View architekt\u00far\u00e1t k\u00f6vetj\u00fck, de egyszerre csak egy dokumentum lehet megnyitva (nincsenek dokumentumonk\u00e9nt tabf\u00fclek vagy ablakok). Egy adott pontig el\u0151k\u00e9sz\u00edtett k\u00f6rnyezetet visz\u00fcnk tov\u00e1bb. A munka mennyis\u00e9g\u00e9nek kezelhet\u0151 szinten tart\u00e1sa v\u00e9gett csak bizonyos pontig vissz\u00fck tov\u00e1bb a fejleszt\u00e9st, nem val\u00f3s\u00edtjuk meg a teljes \u00e9rt\u00e9k\u0171 megold\u00e1st. kiemelt h\u00e1tt\u00e9r jelzi.","title":"A feladat ismertet\u00e9se"},{"location":"labor/7-tervezesi-mintak/#1-feladat-a-kiindulasi-kornyezet-megismerese","text":"COMING SOON","title":"1. Feladat - A kiindul\u00e1si k\u00f6rnyezet megismer\u00e9se"},{"location":"labor/7-tervezesi-mintak/#2-feladat-command-processor-minta","text":"COMING SOON","title":"2. Feladat - Command Processor minta"},{"location":"labor/7-tervezesi-mintak/#3-feladat-memento-minta","text":"COMING SOON","title":"3- Feladat \u2013 Memento minta"}]}