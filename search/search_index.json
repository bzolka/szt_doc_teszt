{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Szoftvertechnik\u00e1k \u00b6 Gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAB00 Szoftvertechnik\u00e1k c. t\u00e1rgyhoz. Jav\u00edt\u00e1s az anyagban A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request -et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod. Felhaszn\u00e1l\u00e1si felt\u00e9telek Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAB00 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) enged\u00e9ly\u00e9vel \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet. Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.","title":"Szoftvertechnik\u00e1k"},{"location":"#szoftvertechnikak","text":"Gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAB00 Szoftvertechnik\u00e1k c. t\u00e1rgyhoz. Jav\u00edt\u00e1s az anyagban A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request -et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod. Felhaszn\u00e1l\u00e1si felt\u00e9telek Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAB00 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) enged\u00e9ly\u00e9vel \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet. Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.","title":"Szoftvertechnik\u00e1k"},{"location":"egyeb/interfesz-es-absztrakt-os/","text":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet. Absztrakt oszt\u00e1ly \u00b6 A fogalmak kor\u00e1bbi t\u00e1rgyak keret\u00e9ben m\u00e1r ismertet\u00e9sre ker\u00fcltek, \u00edgy most csak a legfontosabbakat foglaljuk \u00f6ssze, illetve a C# vonatkoz\u00e1s\u00e1ra t\u00e9r\u00fcnk ki. Absztrakt oszt\u00e1ly Olyan oszt\u00e1ly, mely nem p\u00e9ld\u00e1nyos\u00edthat\u00f3. C# nyelven az oszt\u00e1lydefin\u00edci\u00f3ban az abstract kulcssz\u00f3t kell ki\u00edrni, pl.: abstract class Shape { \u2026 } Absztrakt oszt\u00e1lyoknak lehetnek absztrakt met\u00f3dusaik, melyeknek nem adjuk meg a t\u00f6rzs\u00e9t, ezekn\u00e9l is az abstract kulcssz\u00f3t kell haszn\u00e1lni: \u2026 abstract void Draw (); \u2026 Absztrakt oszt\u00e1lyok haszn\u00e1lat\u00e1nak k\u00e9t c\u00e9lja lehet: Egy oszt\u00e1lyhierarchi\u00e1ban a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot fel tudjuk vinni egy absztrakt k\u00f6z\u00f6s \u0151sbe, \u00edgy elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t. Egys\u00e9gesen tudjuk absztrakt \u0151sk\u00e9nt hivatkozva a lesz\u00e1rmazottakat kezelni (pl. heterog\u00e9n kollekci\u00f3k). .NET k\u00f6rnyezetben, csak\u00fagy, mint Java nyelven, egy oszt\u00e1lynak csak egy \u0151soszt\u00e1lya lehet. Interf\u00e9sz \u00b6 Az interf\u00e9sz nem m\u00e1s, mint egy m\u0171velethalmaz. Tulajdonk\u00e9ppen egy olyan absztrakt oszt\u00e1lynak felel meg, melynek minden m\u0171velete absztrakt. C# nyelven az interface kulcssz\u00f3val tudunk interf\u00e9szt defini\u00e1lni: public interface ISerializable { void WriteToStream ( Stream s ); void LoadFromStream ( Stream s ); } public interface IComparable { int CompareTo ( Object obj ); } M\u00edg egy oszt\u00e1lynak csak egy \u0151se lehet, ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat: public class Rect : Shape , ISerializable , IComparable { \u2026 } Ebben a p\u00e9ld\u00e1ban Rect oszt\u00e1ly a Shape oszt\u00e1lyb\u00f3l sz\u00e1rmazik, valamint az ISerializable \u00e9s IComparable interf\u00e9szeket implement\u00e1lja (k\u00f6telez\u0151en az \u0151soszt\u00e1lyt kell el\u0151sz\u00f6r megadni). Az interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban annak valamennyi m\u0171velet\u00e9t meg kell val\u00f3s\u00edtani, vagyis meg kell \u00edrni a t\u00f6rzs\u00e9t (kiv\u00e9ve azt a ritka esetet, amikor absztrakt m\u0171velettel val\u00f3s\u00edtjuk meg). Interf\u00e9szek haszn\u00e1lat\u00e1nak egy f\u0151 c\u00e9lja van. Interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk az interf\u00e9szt implement\u00e1l\u00f3 valamennyi oszt\u00e1lyt kezelni (pl. heterog\u00e9n kollekci\u00f3). Ennek egy k\u00f6vetkezm\u00e9nye: az interf\u00e9szek lehet\u0151v\u00e9 teszik sz\u00e9les k\u00f6rben haszn\u00e1lhat\u00f3 oszt\u00e1lyok \u00e9s f\u00fcggv\u00e9nyek meg\u00edr\u00e1s\u00e1t . Pl. tudunk \u00edrni egy univerz\u00e1lis Sort sorrendez\u0151 f\u00fcggv\u00e9nyt, mely b\u00e1rmilyen oszt\u00e1llyal haszn\u00e1lhat\u00f3, mely implement\u00e1lja az IComparable interf\u00e9szt. Az interf\u00e9sz alkalmaz\u00e1s\u00e1nak el\u0151nyei m\u00e9g: A kliensnek el\u00e9g a kiszolg\u00e1l\u00f3 objektum interf\u00e9sz\u00e9t ismernie, \u00edgy egyszer\u0171en tudja a kiszolg\u00e1l\u00f3t haszn\u00e1lni. Ha a kliens csak az interf\u00e9szen kereszt\u00fcl haszn\u00e1lja a kiszolg\u00e1l\u00f3t, \u00edgy a kiszolg\u00e1l\u00f3 bels\u0151 implement\u00e1ci\u00f3ja megv\u00e1ltozhat, a klienst nem kell m\u00f3dos\u00edtani (\u00fajra sem kell ford\u00edtani) . Ennek megfelel\u0151en az interf\u00e9sz egy szerz\u0151d\u00e9s is a kiszolg\u00e1l\u00f3 \u00e9s a kliens k\u00f6z\u00f6tt: am\u00edg a kiszolg\u00e1l\u00f3 garant\u00e1lja az interf\u00e9sz t\u00e1mogat\u00e1s\u00e1t, a klienst nem kell v\u00e1ltoztatni. Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa \u00b6 Az absztrakt \u0151s el\u0151nye az interf\u00e9sszel szemben, hogy adhatunk meg a m\u0171veletekre vonatkoz\u00f3an alap\u00e9rtelmezett implement\u00e1ci\u00f3t, illetve vehet\u00fcnk fel tagv\u00e1ltoz\u00f3kat. Az interf\u00e9szek el\u0151nye az absztrakt \u0151ssel szemben, hogy egy oszt\u00e1ly ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat, m\u00edg \u0151se maximum egy lehet. Az interf\u00e9szek haszn\u00e1lat\u00e1nak van m\u00e9g egy k\u00f6vetkezm\u00e9nye, ami bizonyos esetben kellemetlens\u00e9geket okozhat. Amikor az interf\u00e9szbe \u00faj m\u0171veletet vesz\u00fcnk fel, akkor valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt szint\u00e9n b\u0151v\u00edteni kell, k\u00fcl\u00f6nben a k\u00f3d nem fordul. Absztrakt \u0151s b\u0151v\u00edt\u00e9se eset\u00e9n ez nincs \u00edgy: amennyiben \u00faj m\u0171veletet vesz\u00fcnk fel, lehet\u0151s\u00e9g\u00fcnk van azt virtu\u00e1lis f\u00fcggv\u00e9nyk\u00e9nt felvenni, \u00e9s \u00edgy az \u0151sben alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni r\u00e1 . Ez esetben az lesz\u00e1rmazottak ig\u00e9ny szerint tudj\u00e1k ezt fel\u00fcldefini\u00e1lni, erre nincsenek r\u00e1k\u00e9nyszer\u00edtve. Az interf\u00e9szek ezen tulajdons\u00e1ga k\u00fcl\u00f6n\u00f6sen oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek eset\u00e9n lehet kellemetlen. Tegy\u00fck fel, hogy a .NET \u00faj verzi\u00f3j\u00e1nak kiad\u00e1skor a keretrendszer egyik interf\u00e9sz\u00e9be \u00faj m\u0171veletet vesznek fel. Ekkor valamennyi alkalmaz\u00e1sban valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt m\u00f3dos\u00edtani kell, k\u00fcl\u00f6nben nem fordul a k\u00f3d. Ezt k\u00e9tf\u00e9lek\u00e9ppen lehet elker\u00fclni. Vagy \u0151soszt\u00e1ly haszn\u00e1lat\u00e1val, vagy ha m\u00e9gis interf\u00e9szt kellene b\u0151v\u00edteni, akkor ink\u00e1bb \u00faj interf\u00e9szt bevezet\u00e9s\u00e9vel, amely m\u00e1r az \u00faj m\u0171veletet is tartalmazza. B\u00e1r itt az els\u0151 megk\u00f6zel\u00edt\u00e9s (\u0151soszt\u00e1ly alkalmaz\u00e1sa) t\u0171nik els\u0151 \u00e9rz\u00e9sre vonz\u00f3bbnak, ennek is van h\u00e1tr\u00e1nya: ha az alkalmaz\u00e1s fejleszt\u00e9sekor egy keretrendszerbeli \u0151sb\u0151l sz\u00e1rmaztatunk, akkor oszt\u00e1lyunknak m\u00e1r nem lehet m\u00e1s \u0151se, \u00e9s ez bizony sok esetben f\u00e1jdalmas megk\u00f6t\u00e9st jelent. \u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja . B\u0151vebben inform\u00e1ci\u00f3 itt: default interface methods . Mivel mind az interf\u00e9szek, mind az absztrakt \u0151soszt\u00e1lyok alkalmaz\u00e1sa j\u00e1rhat negat\u00edv k\u00f6vetkezm\u00e9nyekkel is, sz\u00e1mos esetben a kett\u0151 egy\u00fcttes haszn\u00e1lat\u00e1val tudjuk kihozni megold\u00e1sunkb\u00f3l a maximumot (vagyis lesz a k\u00f3dunk k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00fagy, hogy nem, vagy csak minim\u00e1lis m\u00e9rt\u00e9kben tartalmaz k\u00f3dduplik\u00e1ci\u00f3t).","title":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly"},{"location":"egyeb/interfesz-es-absztrakt-os/#interfesz-es-absztrakt-ososztaly","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet.","title":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-osztaly","text":"A fogalmak kor\u00e1bbi t\u00e1rgyak keret\u00e9ben m\u00e1r ismertet\u00e9sre ker\u00fcltek, \u00edgy most csak a legfontosabbakat foglaljuk \u00f6ssze, illetve a C# vonatkoz\u00e1s\u00e1ra t\u00e9r\u00fcnk ki. Absztrakt oszt\u00e1ly Olyan oszt\u00e1ly, mely nem p\u00e9ld\u00e1nyos\u00edthat\u00f3. C# nyelven az oszt\u00e1lydefin\u00edci\u00f3ban az abstract kulcssz\u00f3t kell ki\u00edrni, pl.: abstract class Shape { \u2026 } Absztrakt oszt\u00e1lyoknak lehetnek absztrakt met\u00f3dusaik, melyeknek nem adjuk meg a t\u00f6rzs\u00e9t, ezekn\u00e9l is az abstract kulcssz\u00f3t kell haszn\u00e1lni: \u2026 abstract void Draw (); \u2026 Absztrakt oszt\u00e1lyok haszn\u00e1lat\u00e1nak k\u00e9t c\u00e9lja lehet: Egy oszt\u00e1lyhierarchi\u00e1ban a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot fel tudjuk vinni egy absztrakt k\u00f6z\u00f6s \u0151sbe, \u00edgy elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t. Egys\u00e9gesen tudjuk absztrakt \u0151sk\u00e9nt hivatkozva a lesz\u00e1rmazottakat kezelni (pl. heterog\u00e9n kollekci\u00f3k). .NET k\u00f6rnyezetben, csak\u00fagy, mint Java nyelven, egy oszt\u00e1lynak csak egy \u0151soszt\u00e1lya lehet.","title":"Absztrakt oszt\u00e1ly"},{"location":"egyeb/interfesz-es-absztrakt-os/#interfesz","text":"Az interf\u00e9sz nem m\u00e1s, mint egy m\u0171velethalmaz. Tulajdonk\u00e9ppen egy olyan absztrakt oszt\u00e1lynak felel meg, melynek minden m\u0171velete absztrakt. C# nyelven az interface kulcssz\u00f3val tudunk interf\u00e9szt defini\u00e1lni: public interface ISerializable { void WriteToStream ( Stream s ); void LoadFromStream ( Stream s ); } public interface IComparable { int CompareTo ( Object obj ); } M\u00edg egy oszt\u00e1lynak csak egy \u0151se lehet, ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat: public class Rect : Shape , ISerializable , IComparable { \u2026 } Ebben a p\u00e9ld\u00e1ban Rect oszt\u00e1ly a Shape oszt\u00e1lyb\u00f3l sz\u00e1rmazik, valamint az ISerializable \u00e9s IComparable interf\u00e9szeket implement\u00e1lja (k\u00f6telez\u0151en az \u0151soszt\u00e1lyt kell el\u0151sz\u00f6r megadni). Az interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban annak valamennyi m\u0171velet\u00e9t meg kell val\u00f3s\u00edtani, vagyis meg kell \u00edrni a t\u00f6rzs\u00e9t (kiv\u00e9ve azt a ritka esetet, amikor absztrakt m\u0171velettel val\u00f3s\u00edtjuk meg). Interf\u00e9szek haszn\u00e1lat\u00e1nak egy f\u0151 c\u00e9lja van. Interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk az interf\u00e9szt implement\u00e1l\u00f3 valamennyi oszt\u00e1lyt kezelni (pl. heterog\u00e9n kollekci\u00f3). Ennek egy k\u00f6vetkezm\u00e9nye: az interf\u00e9szek lehet\u0151v\u00e9 teszik sz\u00e9les k\u00f6rben haszn\u00e1lhat\u00f3 oszt\u00e1lyok \u00e9s f\u00fcggv\u00e9nyek meg\u00edr\u00e1s\u00e1t . Pl. tudunk \u00edrni egy univerz\u00e1lis Sort sorrendez\u0151 f\u00fcggv\u00e9nyt, mely b\u00e1rmilyen oszt\u00e1llyal haszn\u00e1lhat\u00f3, mely implement\u00e1lja az IComparable interf\u00e9szt. Az interf\u00e9sz alkalmaz\u00e1s\u00e1nak el\u0151nyei m\u00e9g: A kliensnek el\u00e9g a kiszolg\u00e1l\u00f3 objektum interf\u00e9sz\u00e9t ismernie, \u00edgy egyszer\u0171en tudja a kiszolg\u00e1l\u00f3t haszn\u00e1lni. Ha a kliens csak az interf\u00e9szen kereszt\u00fcl haszn\u00e1lja a kiszolg\u00e1l\u00f3t, \u00edgy a kiszolg\u00e1l\u00f3 bels\u0151 implement\u00e1ci\u00f3ja megv\u00e1ltozhat, a klienst nem kell m\u00f3dos\u00edtani (\u00fajra sem kell ford\u00edtani) . Ennek megfelel\u0151en az interf\u00e9sz egy szerz\u0151d\u00e9s is a kiszolg\u00e1l\u00f3 \u00e9s a kliens k\u00f6z\u00f6tt: am\u00edg a kiszolg\u00e1l\u00f3 garant\u00e1lja az interf\u00e9sz t\u00e1mogat\u00e1s\u00e1t, a klienst nem kell v\u00e1ltoztatni.","title":"Interf\u00e9sz"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-os-es-interfesz-osszehasonlitasa","text":"Az absztrakt \u0151s el\u0151nye az interf\u00e9sszel szemben, hogy adhatunk meg a m\u0171veletekre vonatkoz\u00f3an alap\u00e9rtelmezett implement\u00e1ci\u00f3t, illetve vehet\u00fcnk fel tagv\u00e1ltoz\u00f3kat. Az interf\u00e9szek el\u0151nye az absztrakt \u0151ssel szemben, hogy egy oszt\u00e1ly ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat, m\u00edg \u0151se maximum egy lehet. Az interf\u00e9szek haszn\u00e1lat\u00e1nak van m\u00e9g egy k\u00f6vetkezm\u00e9nye, ami bizonyos esetben kellemetlens\u00e9geket okozhat. Amikor az interf\u00e9szbe \u00faj m\u0171veletet vesz\u00fcnk fel, akkor valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt szint\u00e9n b\u0151v\u00edteni kell, k\u00fcl\u00f6nben a k\u00f3d nem fordul. Absztrakt \u0151s b\u0151v\u00edt\u00e9se eset\u00e9n ez nincs \u00edgy: amennyiben \u00faj m\u0171veletet vesz\u00fcnk fel, lehet\u0151s\u00e9g\u00fcnk van azt virtu\u00e1lis f\u00fcggv\u00e9nyk\u00e9nt felvenni, \u00e9s \u00edgy az \u0151sben alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni r\u00e1 . Ez esetben az lesz\u00e1rmazottak ig\u00e9ny szerint tudj\u00e1k ezt fel\u00fcldefini\u00e1lni, erre nincsenek r\u00e1k\u00e9nyszer\u00edtve. Az interf\u00e9szek ezen tulajdons\u00e1ga k\u00fcl\u00f6n\u00f6sen oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek eset\u00e9n lehet kellemetlen. Tegy\u00fck fel, hogy a .NET \u00faj verzi\u00f3j\u00e1nak kiad\u00e1skor a keretrendszer egyik interf\u00e9sz\u00e9be \u00faj m\u0171veletet vesznek fel. Ekkor valamennyi alkalmaz\u00e1sban valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt m\u00f3dos\u00edtani kell, k\u00fcl\u00f6nben nem fordul a k\u00f3d. Ezt k\u00e9tf\u00e9lek\u00e9ppen lehet elker\u00fclni. Vagy \u0151soszt\u00e1ly haszn\u00e1lat\u00e1val, vagy ha m\u00e9gis interf\u00e9szt kellene b\u0151v\u00edteni, akkor ink\u00e1bb \u00faj interf\u00e9szt bevezet\u00e9s\u00e9vel, amely m\u00e1r az \u00faj m\u0171veletet is tartalmazza. B\u00e1r itt az els\u0151 megk\u00f6zel\u00edt\u00e9s (\u0151soszt\u00e1ly alkalmaz\u00e1sa) t\u0171nik els\u0151 \u00e9rz\u00e9sre vonz\u00f3bbnak, ennek is van h\u00e1tr\u00e1nya: ha az alkalmaz\u00e1s fejleszt\u00e9sekor egy keretrendszerbeli \u0151sb\u0151l sz\u00e1rmaztatunk, akkor oszt\u00e1lyunknak m\u00e1r nem lehet m\u00e1s \u0151se, \u00e9s ez bizony sok esetben f\u00e1jdalmas megk\u00f6t\u00e9st jelent. \u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja . B\u0151vebben inform\u00e1ci\u00f3 itt: default interface methods . Mivel mind az interf\u00e9szek, mind az absztrakt \u0151soszt\u00e1lyok alkalmaz\u00e1sa j\u00e1rhat negat\u00edv k\u00f6vetkezm\u00e9nyekkel is, sz\u00e1mos esetben a kett\u0151 egy\u00fcttes haszn\u00e1lat\u00e1val tudjuk kihozni megold\u00e1sunkb\u00f3l a maximumot (vagyis lesz a k\u00f3dunk k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00fagy, hogy nem, vagy csak minim\u00e1lis m\u00e9rt\u00e9kben tartalmaz k\u00f3dduplik\u00e1ci\u00f3t).","title":"Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa"},{"location":"egyeb/uml-kod-kapcsolata/","text":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet. Bevezet\u0151 \u00b6 A fejezet egy r\u00f6vid, v\u00e1zlatos \u00e1ttekint\u00e9st ad az UML oszt\u00e1lydiagram \u00e9s a forr\u00e1sk\u00f3d k\u00f6z\u00f6tti lek\u00e9pez\u00e9s alapjair\u00f3l, a megel\u0151z\u0151 f\u00e9l\u00e9vben Szoftvertechnol\u00f3gia t\u00e1rgyb\u00f3l m\u00e1r tanultak ism\u00e9tl\u00e9sek\u00e9nt. Napjainkban sz\u00e1mos szoftverfejleszt\u00e9si m\u00f3dszertan l\u00e9tezik. Ezek k\u00fcl\u00f6nb\u00f6z\u0151 m\u00e9rt\u00e9kben \u00e9p\u00edtenek arra, illetve k\u00f6vetelik meg, hogy a szoftver elk\u00e9sz\u00edt\u00e9se sor\u00e1n modellez\u00e9st alkalmazzunk. Az azonban k\u00e9ts\u00e9gtelen, hogy m\u00e9g a legagilisabb, legink\u00e1bb \u201ek\u00f3dcentrikus\u201d szeml\u00e9letm\u00f3dok k\u00f6vet\u0151i is hasznosnak \u00edt\u00e9lik a szoftver fontosabb/komplexebb komponenseinek \u00e9s szerkezeti elemeinek vizu\u00e1lis modellez\u00e9s\u00e9t annak grafikus volt\u00e1b\u00f3l ad\u00f3d\u00f3 nagyobb kifejez\u0151 ereje miatt. Tegy\u00fck fel, hogy feladatunk egy alkalmaz\u00e1s, vagy annak adott modulj\u00e1nak elk\u00e9sz\u00edt\u00e9se. A v\u00e1lasztott m\u00f3dszertanunkat k\u00f6vetve \u2013 j\u00f3 es\u00e9llyel t\u00f6bb iter\u00e1ci\u00f3ban \u2013 a k\u00f6vetelm\u00e9ny elemz\u00e9s, anal\u00edzis, tervez\u00e9s, implement\u00e1ci\u00f3 \u00e9s tesztel\u00e9s l\u00e9p\u00e9seit fogjuk \u00e9rinteni. Koncentr\u00e1ljunk most a tervez\u00e9si f\u00e1zisra. Ennek sor\u00e1n elk\u00e9sz\u00fcl a rendszer (legal\u00e1bbis bizonyos r\u00e9szeinek) r\u00e9szletes terve, mely kimenete a r\u00e9szletes/ implement\u00e1ci\u00f3s terv, illetve modell. Ezen a szinten a modellben szerepl\u0151 bizonyos elemek (pl. oszt\u00e1lyok) egy\u00e9rtelm\u0171en lek\u00e9pezhet\u0151k az adott alrendszer implement\u00e1ci\u00f3j\u00e1ul v\u00e1lasztott programoz\u00e1si nyelv elemeire. Ha j\u00f3 a fejleszt\u0151/modellez\u0151 eszk\u00f6z\u00fcnk, akkor az le tudja gener\u00e1lni az oszt\u00e1lyok v\u00e1z\u00e1t (pl. C++, Java, C# oszt\u00e1lyok). A feladatunk ezt k\u00f6vet\u0151en a gener\u00e1lt k\u00f3dban szerepl\u0151 a met\u00f3dusok t\u00f6rzs\u00e9nek kit\u00f6lt\u00e9se. Fogalmak \u00b6 Forward engineering: modellb\u0151l k\u00f3d gener\u00e1l\u00e1sa. A r\u00e9szletes tervb\u0151l a modellez\u0151 eszk\u00f6z le tudja gener\u00e1lni a programv\u00e1zat. El\u0151nye, hogy kevesebbet kell k\u00f3dolni. Reverse engineering: k\u00f3db\u00f3l modell gener\u00e1l\u00e1sa. A m\u00e1r k\u00e9sz k\u00f3d meg\u00e9rt\u00e9s\u00e9t seg\u00edti. Round-trip engineering: az el\u0151z\u0151 kett\u0151 egy\u00fcttes alkalmaz\u00e1sa. A l\u00e9nyeg: a modell \u00e9s a k\u00f3d v\u00e9gig szinkronban van. Ha a k\u00f3dban v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a modellben, ha a modellben v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a k\u00f3dban. Ahhoz, hogy a k\u00f3dgener\u00e1l\u00e1s el\u0151nyeivel \u00e9lni tudjunk, a k\u00f6vetkez\u0151kkel kell tiszt\u00e1ban legy\u00fcnk: ismern\u00fcnk kell, hogy az adott modellez\u0151 eszk\u00f6z az egyes modell elemeket hogyan k\u00e9pezi le az adott programoz\u00e1si nyelv elemeire. A lek\u00e9pez\u00e9s f\u00fcgg a nyelvt\u0151l \u00e9s a modellez\u0151 eszk\u00f6zt\u0151l is, nincs r\u00e1 univerz\u00e1lis szabv\u00e1ny. A lek\u00e9pez\u00e9sek \u00e1ltal\u00e1ban magukt\u00f3l \u00e9rtet\u0151d\u0151ek, t\u00fal nagy elt\u00e9r\u00e9s nem szokott lenni. A k\u00f6vetkez\u0151kben azt tekintj\u00fck \u00e1t, hogy az UML oszt\u00e1lydiagram egyes modellelemei hogyan k\u00e9pz\u0151dnek le forr\u00e1sk\u00f3dra, \u00e9s viszont. Oszt\u00e1lyok lek\u00e9pez\u00e9se \u00b6 Mondhatni trivi\u00e1lisan egyszer\u0171: UML oszt\u00e1ly -> oszt\u00e1ly UML attrib\u00fatum -> tagv\u00e1ltoz\u00f3 UML m\u0171velet -> m\u0171velet/met\u00f3dus Egy p\u00e9lda: , mely a k\u00f6vetkez\u0151 k\u00f3dnak felel meg C# nyelven: public abstract class Shape { private int x ; private int y ; public Shape ( int x , int y ) { this . x = x ; this . y = y ; } public abstract void Draw ( Graphics gr ); } A l\u00e1that\u00f3s\u00e1g kapcs\u00e1n a lek\u00e9pez\u00e9s: +: public -: private #: protected Enn\u00e9l izgalmasabb k\u00e9rd\u00e9sk\u00f6r, hogy milyen m\u00f3don t\u00f6rt\u00e9nik az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatok lek\u00e9pez\u00e9se, ezt a k\u00f6vetkez\u0151 fejezetek ismertetik. I. \u00c1ltal\u00e1nos\u00edt\u00e1s, specializ\u00e1ci\u00f3 kapcsolat \u00b6 C# lek\u00e9pez\u00e9s: public class Base { }; public class Derived : Base { }; II. Asszoci\u00e1ci\u00f3 \u00b6 Ez a kapcsolatt\u00edpus mindig kommunik\u00e1ci\u00f3t jelent az oszt\u00e1lyok objektumai k\u00f6z\u00f6tt. Egy adott oszt\u00e1ly ig\u00e9nybe veszi egy m\u00e1sik oszt\u00e1ly szolg\u00e1ltat\u00e1sait. A) Lek\u00e9pez\u00e9s 0..1 multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n \u00b6 Ebben az esetben egy pointert vagy referenci\u00e1t tartalmaz a kliens oszt\u00e1ly, melyen kereszt\u00fcl ig\u00e9nybe tudja venni a c\u00e9loszt\u00e1ly szolg\u00e1ltat\u00e1sait (meg tudja h\u00edvni annak m\u0171veleteit). P\u00e9lda: C++ lek\u00e9pez\u00e9s: class Application { WindowManager * windowManager ; }; class WindowManager { }; C# lek\u00e9pez\u00e9s (nincsenek pointerek, csak referenci\u00e1k): class Application { WindowManager windowManager ; }; class WindowManager { }; Mink\u00e9t esetben azt l\u00e1tjuk, hogy a kliens oszt\u00e1lyba felvesz\u00fcnk egy pointer vagy referencia tagv\u00e1ltoz\u00f3t, melynek t\u00edpusa megegyezik az asszoci\u00e1ci\u00f3ban hivatkozott c\u00e9loszt\u00e1ly t\u00edpus\u00e1val, illetve a tagv\u00e1ltoz\u00f3 neve az asszoci\u00e1ci\u00f3s kapcsolatra a c\u00e9loszt\u00e1lyra megadott szereppel (role) , mely a p\u00e9ld\u00e1ban a windowManager . A lek\u00e9pez\u00e9s logikus, hiszen a kliens ezen pointeren/referenci\u00e1n kereszt\u00fcl tudja a c\u00e9lobjektumot b\u00e1rmely m\u0171velet\u00e9b\u0151l el\u00e9rni \u00e9s met\u00f3dusait megh\u00edvni. Megjegyz\u00e9s. El\u0151fordulhat, hogy az asszoci\u00e1ci\u00f3 k\u00e9tir\u00e1ny\u00fa, mindk\u00e9t oszt\u00e1ly ig\u00e9nybe veszi a m\u00e1sik szolg\u00e1ltat\u00e1sait. Ilyenkor sokszor nem tessz\u00fck ki az asszoci\u00e1ci\u00f3 mindk\u00e9t v\u00e9g\u00e9re a nyilat, hanem mindk\u00e9t v\u00e9g\u00e9r\u0151l elhagyjuk azt. Ilyen k\u00e9tir\u00e1ny\u00fa kapcsolat eset\u00e9n a szerepet (role) a kapcsolat mindk\u00e9t v\u00e9g\u00e9n meg kell adni. A lek\u00e9pez\u00e9s sor\u00e1n mindk\u00e9t oszt\u00e1lyba felvesz\u00fcnk egy pointert/referenci\u00e1t a m\u00e1sikra. B) Lek\u00e9pez\u00e9s 0..n multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n \u00b6 Ebben az esetben egy kliensoldali objektum t\u00f6bb c\u00e9loldali objektummal van kapcsolatban. P\u00e9lda: Egy WindowManager objektum t\u00f6bb Window objektumot menedzsel. A lek\u00e9pez\u00e9s sor\u00e1n a kliens oszt\u00e1lyba a c\u00e9loszt\u00e1lybeli objektumok valamilyen gy\u0171jtem\u00e9ny\u00e9t vessz\u00fck fel. Ez lehet t\u00f6mb, lista, stb., ami a c\u00e9lunknak az adott helyzetben legink\u00e1bb megfelel. Egy lek\u00e9pz\u00e9si lehet\u0151s\u00e9g a fenti p\u00e9ld\u00e1ra C++ nyelven: class WindowManager { vector < Window *> windows ; }; Illetve C# nyelven: class WindowManager { List < Window > windows ; }; III. Aggreg\u00e1ci\u00f3 (tartalmaz\u00e1s, r\u00e9sz-eg\u00e9sz viszony) \u00b6 \u00c1ltal\u00e1ban a lek\u00e9pez\u00e9se pontosan \u00fagy t\u00f6rt\u00e9nik, mint az asszoci\u00e1ci\u00f3 eset\u00e9ben. IV. F\u00fcgg\u0151s\u00e9g (dependency) \u00b6 A leglaz\u00e1bb kapcsolatot jelenti oszt\u00e1lyok k\u00f6z\u00f6tt. P\u00e9lda: A jelent\u00e9se: a Window oszt\u00e1ly f\u00fcgg a Graphics oszt\u00e1lyt\u00f3l. Vagyis, ha a Graphics oszt\u00e1ly megv\u00e1ltozik, akkor lehet, hogy a Window oszt\u00e1lyt is meg kell v\u00e1ltoztatni. Ezt a kapcsolatt\u00edpust akkor szoktuk haszn\u00e1lni, ha a f\u00fcgg\u0151s\u00e9gi kapcsolat elej\u00e9n lev\u0151 oszt\u00e1ly met\u00f3dusai param\u00e9terlist\u00e1j\u00e1ban/visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben szerepel a kapcsolat v\u00e9g\u00e9n lev\u0151 oszt\u00e1ly. A p\u00e9ld\u00e1ban a Window oszt\u00e1ly onDraw m\u0171velete param\u00e9terk\u00e9nt megkapja a Graphics oszt\u00e1ly egy objektum\u00e1t, \u00edgy f\u00fcgg t\u0151le, hiszen a met\u00f3dus t\u00f6rzs\u00e9ben \u00edgy meg tudja h\u00edvni a Graphics oszt\u00e1ly met\u00f3dusait. Ha pl. a Graphics oszt\u00e1ly FillRect met\u00f3dus\u00e1nak nev\u00e9t megv\u00e1ltoztatjuk, akkor ezt a v\u00e1ltoz\u00e1st \u00e1t kell vezetni a h\u00edv\u00e1sok hely\u00e9n, vagyis a Window oszt\u00e1ly onDraw met\u00f3dus\u00e1nak t\u00f6rzs\u00e9ben is.","title":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete"},{"location":"egyeb/uml-kod-kapcsolata/#az-uml-osztalydiagram-es-a-kod-kapcsolatanak-elmelete","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3 elm\u00e9letet.","title":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete"},{"location":"egyeb/uml-kod-kapcsolata/#bevezeto","text":"A fejezet egy r\u00f6vid, v\u00e1zlatos \u00e1ttekint\u00e9st ad az UML oszt\u00e1lydiagram \u00e9s a forr\u00e1sk\u00f3d k\u00f6z\u00f6tti lek\u00e9pez\u00e9s alapjair\u00f3l, a megel\u0151z\u0151 f\u00e9l\u00e9vben Szoftvertechnol\u00f3gia t\u00e1rgyb\u00f3l m\u00e1r tanultak ism\u00e9tl\u00e9sek\u00e9nt. Napjainkban sz\u00e1mos szoftverfejleszt\u00e9si m\u00f3dszertan l\u00e9tezik. Ezek k\u00fcl\u00f6nb\u00f6z\u0151 m\u00e9rt\u00e9kben \u00e9p\u00edtenek arra, illetve k\u00f6vetelik meg, hogy a szoftver elk\u00e9sz\u00edt\u00e9se sor\u00e1n modellez\u00e9st alkalmazzunk. Az azonban k\u00e9ts\u00e9gtelen, hogy m\u00e9g a legagilisabb, legink\u00e1bb \u201ek\u00f3dcentrikus\u201d szeml\u00e9letm\u00f3dok k\u00f6vet\u0151i is hasznosnak \u00edt\u00e9lik a szoftver fontosabb/komplexebb komponenseinek \u00e9s szerkezeti elemeinek vizu\u00e1lis modellez\u00e9s\u00e9t annak grafikus volt\u00e1b\u00f3l ad\u00f3d\u00f3 nagyobb kifejez\u0151 ereje miatt. Tegy\u00fck fel, hogy feladatunk egy alkalmaz\u00e1s, vagy annak adott modulj\u00e1nak elk\u00e9sz\u00edt\u00e9se. A v\u00e1lasztott m\u00f3dszertanunkat k\u00f6vetve \u2013 j\u00f3 es\u00e9llyel t\u00f6bb iter\u00e1ci\u00f3ban \u2013 a k\u00f6vetelm\u00e9ny elemz\u00e9s, anal\u00edzis, tervez\u00e9s, implement\u00e1ci\u00f3 \u00e9s tesztel\u00e9s l\u00e9p\u00e9seit fogjuk \u00e9rinteni. Koncentr\u00e1ljunk most a tervez\u00e9si f\u00e1zisra. Ennek sor\u00e1n elk\u00e9sz\u00fcl a rendszer (legal\u00e1bbis bizonyos r\u00e9szeinek) r\u00e9szletes terve, mely kimenete a r\u00e9szletes/ implement\u00e1ci\u00f3s terv, illetve modell. Ezen a szinten a modellben szerepl\u0151 bizonyos elemek (pl. oszt\u00e1lyok) egy\u00e9rtelm\u0171en lek\u00e9pezhet\u0151k az adott alrendszer implement\u00e1ci\u00f3j\u00e1ul v\u00e1lasztott programoz\u00e1si nyelv elemeire. Ha j\u00f3 a fejleszt\u0151/modellez\u0151 eszk\u00f6z\u00fcnk, akkor az le tudja gener\u00e1lni az oszt\u00e1lyok v\u00e1z\u00e1t (pl. C++, Java, C# oszt\u00e1lyok). A feladatunk ezt k\u00f6vet\u0151en a gener\u00e1lt k\u00f3dban szerepl\u0151 a met\u00f3dusok t\u00f6rzs\u00e9nek kit\u00f6lt\u00e9se.","title":"Bevezet\u0151"},{"location":"egyeb/uml-kod-kapcsolata/#fogalmak","text":"Forward engineering: modellb\u0151l k\u00f3d gener\u00e1l\u00e1sa. A r\u00e9szletes tervb\u0151l a modellez\u0151 eszk\u00f6z le tudja gener\u00e1lni a programv\u00e1zat. El\u0151nye, hogy kevesebbet kell k\u00f3dolni. Reverse engineering: k\u00f3db\u00f3l modell gener\u00e1l\u00e1sa. A m\u00e1r k\u00e9sz k\u00f3d meg\u00e9rt\u00e9s\u00e9t seg\u00edti. Round-trip engineering: az el\u0151z\u0151 kett\u0151 egy\u00fcttes alkalmaz\u00e1sa. A l\u00e9nyeg: a modell \u00e9s a k\u00f3d v\u00e9gig szinkronban van. Ha a k\u00f3dban v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a modellben, ha a modellben v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a k\u00f3dban. Ahhoz, hogy a k\u00f3dgener\u00e1l\u00e1s el\u0151nyeivel \u00e9lni tudjunk, a k\u00f6vetkez\u0151kkel kell tiszt\u00e1ban legy\u00fcnk: ismern\u00fcnk kell, hogy az adott modellez\u0151 eszk\u00f6z az egyes modell elemeket hogyan k\u00e9pezi le az adott programoz\u00e1si nyelv elemeire. A lek\u00e9pez\u00e9s f\u00fcgg a nyelvt\u0151l \u00e9s a modellez\u0151 eszk\u00f6zt\u0151l is, nincs r\u00e1 univerz\u00e1lis szabv\u00e1ny. A lek\u00e9pez\u00e9sek \u00e1ltal\u00e1ban magukt\u00f3l \u00e9rtet\u0151d\u0151ek, t\u00fal nagy elt\u00e9r\u00e9s nem szokott lenni. A k\u00f6vetkez\u0151kben azt tekintj\u00fck \u00e1t, hogy az UML oszt\u00e1lydiagram egyes modellelemei hogyan k\u00e9pz\u0151dnek le forr\u00e1sk\u00f3dra, \u00e9s viszont.","title":"Fogalmak"},{"location":"egyeb/uml-kod-kapcsolata/#osztalyok-lekepezese","text":"Mondhatni trivi\u00e1lisan egyszer\u0171: UML oszt\u00e1ly -> oszt\u00e1ly UML attrib\u00fatum -> tagv\u00e1ltoz\u00f3 UML m\u0171velet -> m\u0171velet/met\u00f3dus Egy p\u00e9lda: , mely a k\u00f6vetkez\u0151 k\u00f3dnak felel meg C# nyelven: public abstract class Shape { private int x ; private int y ; public Shape ( int x , int y ) { this . x = x ; this . y = y ; } public abstract void Draw ( Graphics gr ); } A l\u00e1that\u00f3s\u00e1g kapcs\u00e1n a lek\u00e9pez\u00e9s: +: public -: private #: protected Enn\u00e9l izgalmasabb k\u00e9rd\u00e9sk\u00f6r, hogy milyen m\u00f3don t\u00f6rt\u00e9nik az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatok lek\u00e9pez\u00e9se, ezt a k\u00f6vetkez\u0151 fejezetek ismertetik.","title":"Oszt\u00e1lyok lek\u00e9pez\u00e9se"},{"location":"egyeb/uml-kod-kapcsolata/#i-altalanositas-specializacio-kapcsolat","text":"C# lek\u00e9pez\u00e9s: public class Base { }; public class Derived : Base { };","title":"I. \u00c1ltal\u00e1nos\u00edt\u00e1s, specializ\u00e1ci\u00f3 kapcsolat"},{"location":"egyeb/uml-kod-kapcsolata/#ii-asszociacio","text":"Ez a kapcsolatt\u00edpus mindig kommunik\u00e1ci\u00f3t jelent az oszt\u00e1lyok objektumai k\u00f6z\u00f6tt. Egy adott oszt\u00e1ly ig\u00e9nybe veszi egy m\u00e1sik oszt\u00e1ly szolg\u00e1ltat\u00e1sait.","title":"II. Asszoci\u00e1ci\u00f3"},{"location":"egyeb/uml-kod-kapcsolata/#a-lekepezes-01-multiplicitasu-asszociacios-kapcsolat-eseten","text":"Ebben az esetben egy pointert vagy referenci\u00e1t tartalmaz a kliens oszt\u00e1ly, melyen kereszt\u00fcl ig\u00e9nybe tudja venni a c\u00e9loszt\u00e1ly szolg\u00e1ltat\u00e1sait (meg tudja h\u00edvni annak m\u0171veleteit). P\u00e9lda: C++ lek\u00e9pez\u00e9s: class Application { WindowManager * windowManager ; }; class WindowManager { }; C# lek\u00e9pez\u00e9s (nincsenek pointerek, csak referenci\u00e1k): class Application { WindowManager windowManager ; }; class WindowManager { }; Mink\u00e9t esetben azt l\u00e1tjuk, hogy a kliens oszt\u00e1lyba felvesz\u00fcnk egy pointer vagy referencia tagv\u00e1ltoz\u00f3t, melynek t\u00edpusa megegyezik az asszoci\u00e1ci\u00f3ban hivatkozott c\u00e9loszt\u00e1ly t\u00edpus\u00e1val, illetve a tagv\u00e1ltoz\u00f3 neve az asszoci\u00e1ci\u00f3s kapcsolatra a c\u00e9loszt\u00e1lyra megadott szereppel (role) , mely a p\u00e9ld\u00e1ban a windowManager . A lek\u00e9pez\u00e9s logikus, hiszen a kliens ezen pointeren/referenci\u00e1n kereszt\u00fcl tudja a c\u00e9lobjektumot b\u00e1rmely m\u0171velet\u00e9b\u0151l el\u00e9rni \u00e9s met\u00f3dusait megh\u00edvni. Megjegyz\u00e9s. El\u0151fordulhat, hogy az asszoci\u00e1ci\u00f3 k\u00e9tir\u00e1ny\u00fa, mindk\u00e9t oszt\u00e1ly ig\u00e9nybe veszi a m\u00e1sik szolg\u00e1ltat\u00e1sait. Ilyenkor sokszor nem tessz\u00fck ki az asszoci\u00e1ci\u00f3 mindk\u00e9t v\u00e9g\u00e9re a nyilat, hanem mindk\u00e9t v\u00e9g\u00e9r\u0151l elhagyjuk azt. Ilyen k\u00e9tir\u00e1ny\u00fa kapcsolat eset\u00e9n a szerepet (role) a kapcsolat mindk\u00e9t v\u00e9g\u00e9n meg kell adni. A lek\u00e9pez\u00e9s sor\u00e1n mindk\u00e9t oszt\u00e1lyba felvesz\u00fcnk egy pointert/referenci\u00e1t a m\u00e1sikra.","title":"A) Lek\u00e9pez\u00e9s 0..1 multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n"},{"location":"egyeb/uml-kod-kapcsolata/#b-lekepezes-0n-multiplicitasu-asszociacios-kapcsolat-eseten","text":"Ebben az esetben egy kliensoldali objektum t\u00f6bb c\u00e9loldali objektummal van kapcsolatban. P\u00e9lda: Egy WindowManager objektum t\u00f6bb Window objektumot menedzsel. A lek\u00e9pez\u00e9s sor\u00e1n a kliens oszt\u00e1lyba a c\u00e9loszt\u00e1lybeli objektumok valamilyen gy\u0171jtem\u00e9ny\u00e9t vessz\u00fck fel. Ez lehet t\u00f6mb, lista, stb., ami a c\u00e9lunknak az adott helyzetben legink\u00e1bb megfelel. Egy lek\u00e9pz\u00e9si lehet\u0151s\u00e9g a fenti p\u00e9ld\u00e1ra C++ nyelven: class WindowManager { vector < Window *> windows ; }; Illetve C# nyelven: class WindowManager { List < Window > windows ; };","title":"B) Lek\u00e9pez\u00e9s 0..n multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n"},{"location":"egyeb/uml-kod-kapcsolata/#iii-aggregacio-tartalmazas-resz-egesz-viszony","text":"\u00c1ltal\u00e1ban a lek\u00e9pez\u00e9se pontosan \u00fagy t\u00f6rt\u00e9nik, mint az asszoci\u00e1ci\u00f3 eset\u00e9ben.","title":"III. Aggreg\u00e1ci\u00f3 (tartalmaz\u00e1s, r\u00e9sz-eg\u00e9sz viszony)"},{"location":"egyeb/uml-kod-kapcsolata/#iv-fuggoseg-dependency","text":"A leglaz\u00e1bb kapcsolatot jelenti oszt\u00e1lyok k\u00f6z\u00f6tt. P\u00e9lda: A jelent\u00e9se: a Window oszt\u00e1ly f\u00fcgg a Graphics oszt\u00e1lyt\u00f3l. Vagyis, ha a Graphics oszt\u00e1ly megv\u00e1ltozik, akkor lehet, hogy a Window oszt\u00e1lyt is meg kell v\u00e1ltoztatni. Ezt a kapcsolatt\u00edpust akkor szoktuk haszn\u00e1lni, ha a f\u00fcgg\u0151s\u00e9gi kapcsolat elej\u00e9n lev\u0151 oszt\u00e1ly met\u00f3dusai param\u00e9terlist\u00e1j\u00e1ban/visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben szerepel a kapcsolat v\u00e9g\u00e9n lev\u0151 oszt\u00e1ly. A p\u00e9ld\u00e1ban a Window oszt\u00e1ly onDraw m\u0171velete param\u00e9terk\u00e9nt megkapja a Graphics oszt\u00e1ly egy objektum\u00e1t, \u00edgy f\u00fcgg t\u0151le, hiszen a met\u00f3dus t\u00f6rzs\u00e9ben \u00edgy meg tudja h\u00edvni a Graphics oszt\u00e1ly met\u00f3dusait. Ha pl. a Graphics oszt\u00e1ly FillRect met\u00f3dus\u00e1nak nev\u00e9t megv\u00e1ltoztatjuk, akkor ezt a v\u00e1ltoz\u00e1st \u00e1t kell vezetni a h\u00edv\u00e1sok hely\u00e9n, vagyis a Window oszt\u00e1ly onDraw met\u00f3dus\u00e1nak t\u00f6rzs\u00e9ben is.","title":"IV. F\u00fcgg\u0151s\u00e9g (dependency)"},{"location":"gyakorlatvezetoknek/","text":"Gyakorlatvezet\u0151knek \u00b6 COMING SOON","title":"Gyakorlatvezet\u0151knek"},{"location":"gyakorlatvezetoknek/#gyakorlatvezetoknek","text":"COMING SOON","title":"Gyakorlatvezet\u0151knek"},{"location":"hazi/","text":"H\u00e1zi feladatok \u00b6 COMING SOON","title":"H\u00e1zi feladatok"},{"location":"hazi/#hazi-feladatok","text":"COMING SOON","title":"H\u00e1zi feladatok"},{"location":"hazi/VisualStudio/","text":"Visual Studio & .NET SDK telep\u00edt\u00e9se \u00b6 COMING SOON","title":"Visual Studio & .NET SDK telep\u00edt\u00e9se"},{"location":"hazi/VisualStudio/#visual-studio-net-sdk-telepitese","text":"COMING SOON","title":"Visual Studio &amp; .NET SDK telep\u00edt\u00e9se"},{"location":"hazi/1-model-es-kod-kapcsolata/","text":"1. HF - A modell \u00e9s a k\u00f3d kapcsolata \u00b6 Bevezet\u00e9s \u00b6 A feladathoz nem kapcsol\u00f3dik el\u0151ad\u00e1s. A feladatok elm\u00e9leti \u00e9s gyakorlati h\u00e1tter\u00e9\u00fcl az \"1. A modell \u00e9s a k\u00f3d kapcsolata\" vezetett laborgyakorlat szolg\u00e1l: Ezt a laborgyakorlatot a hallgat\u00f3k a gyakorlatvezet\u0151 \u00fatmutat\u00e1s\u00e1val, a gyakorlatvezet\u0151vel k\u00f6z\u00f6sen vezetett m\u00f3don v\u00e9gzik/v\u00e9gezt\u00e9k el. A laborgyakorlathoz \u00fatmutat\u00f3 tartozik, mely r\u00e9szletekbe men\u0151en bemutatja az elm\u00e9leti h\u00e1tteret, valamint l\u00e9p\u00e9senk\u00e9nt ismerteti a megold\u00e1s elk\u00e9sz\u00edt\u00e9s\u00e9t: 1. A modell \u00e9s a k\u00f3d kapcsolata Erre \u00e9p\u00edtve jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel elv\u00e9gezhet\u0151k. Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja: Egy egyszer\u0171 .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok gyakorl\u00e1sa Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1j\u00e1nak gyakorl\u00e1sa A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s. A kiindul\u00e1si keret let\u00f6lt\u00e9se, az elk\u00e9sz\u00fclt megold\u00e1s felt\u00f6lt\u00e9se \u00b6 A h\u00e1zi feladat kiindul\u00e1si k\u00f6rnyezet\u00e9nek publik\u00e1l\u00e1sa, valamint a megold\u00e1s bead\u00e1sa Git, GitHub \u00e9s GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik. F\u0151bb l\u00e9p\u00e9sek: GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t a t\u00e1rgy AUT honlapj\u00e1n tal\u00e1lod. Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod. Ezekhez itt tal\u00e1lhat\u00f3 r\u00e9szletesebb le\u00edr\u00e1s: Git, GitHub, GitHub Classroom A kiindul\u00f3 alkalmaz\u00e1skeret let\u00f6lt\u00e9s\u00e9nek \u00e9s a feladat bead\u00e1s\u00e1nak r\u00e9szletes l\u00e9p\u00e9sei A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00b6 A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se \u00b6 Minden egyes alkalommal, miut\u00e1n a GitHub-ra push-olt\u00e1l k\u00f3dot, a GitHub-on automatikusan lefut a felt\u00f6lt\u00f6tt k\u00f3d (el\u0151)ellen\u0151rz\u00e9se, \u00e9s meg lehet n\u00e9zni a kimenet\u00e9t! Az ellen\u0151rz\u0151t maga a GitHub futtatja. A push-t k\u00f6vet\u0151en a feladat egy v\u00e1rakoz\u00e1si sorba ker\u00fcl, majd adott id\u0151 ut\u00e1n lefutnak az ellen\u0151rz\u0151 tesztek. Azt nem lehet tudni, mennyi ez az id\u0151, a GitHub-on m\u00falik. Amikor csak egy-k\u00e9t feladat van a sorban a szervezetre (ez n\u00e1lunk a t\u00e1rgy), akkor a tapasztalatok alapj\u00e1n az ellen\u0151rz\u00e9s 1-2 percen bel\u00fcl elindul. De ha a t\u00e1rgy alatt egyszerre sokan kezdik majd felt\u00f6lteni a megold\u00e1st, akkor ez j\u00f3 es\u00e9llyel belassul. Nem \u00e9rdemes ez\u00e9rt sem az utols\u00f3 pillanatra hagyni a bead\u00e1st: lehet, hogy ekkor a k\u00e9sleltet\u00e9sek miatt m\u00e1r nem kapsz esetleg id\u0151ben visszajelz\u00e9st. Hivatalosan a feladat azon \u00e1llapota ker\u00fcl \u00e9rt\u00e9kel\u00e9sre, amely a hat\u00e1rid\u0151 lej\u00e1rtakor GitHub-on fent van. A hivatalos ellen\u0151rz\u00e9st szok\u00e1sos m\u00f3don, saj\u00e1t, oktat\u00f3i k\u00f6rnyezetben v\u00e9gezz\u00fck \u00e9s az eredm\u00e9nyt a t\u00e1rgy honlapj\u00e1n publik\u00e1ljuk a sz\u00e1monk\u00e9r\u00e9sn\u00e9l. Vagyis a hivatalos eredm\u00e9ny tekintet\u00e9ben teljesen mindegy, hogy a GitHub-on a hat\u00e1rid\u0151 lej\u00e1rta lefutott-e m\u00e1r b\u00e1rmif\u00e9le (el\u0151)ellen\u0151rz\u00e9s, vagy hogy az ellen\u0151rz\u00e9s estleg csak k\u00e9s\u0151bb tudott elindulni. A GitHub \u00e1ltali ellen\u0151rz\u00e9s csak azt a c\u00e9lt szolg\u00e1lja, hogy m\u00e9g a hat\u00e1rid\u0151 lej\u00e1rta el\u0151tt visszajelz\u00e9st kaphasson mindenki. A hivatalos ellen\u0151rz\u00e9s tartalmaz m\u00e9g plusz l\u00e9p\u00e9seket a GitHub alap\u00fa el\u0151ellen\u0151rz\u00e9shez l\u00e9pest, az el\u0151ellen\u0151rz\u00e9s ilyen \u00e9rtelemben r\u00e9szleges, de az\u00e9rt sok probl\u00e9m\u00e1t seg\u00edthet megfogni! Arra k\u00e9r\u00fcnk, hogy ne apr\u00e1nk\u00e9nt push-olj, csak a k\u00e9sz, \u00e1tn\u00e9zett, fordul\u00f3 megold\u00e1st tedd fel! Ez nem a legszerencs\u00e9sebb, de a GitHub korl\u00e1tozott id\u0151t biztos\u00edt az ellen\u0151rz\u0151k futtat\u00e1s\u00e1ra: ha elfogy a havi keret, akkor m\u00e1r nem fogtok visszajelz\u00e9st kapni, csak a hat\u00e1rid\u0151 ut\u00e1ni hivatalos ellen\u0151rz\u00e9s kimenet\u00e9t kapja meg mindenki. A (f\u00e9l)automata ellen\u0151rz\u0151, most m\u00e9g egy r\u00e9szben k\u00eds\u00e9rleti projekt. Ha valaki az \u00fatmutat\u00f3ban inkonzisztenci\u00e1t tal\u00e1l, vagy az ellen\u0151rz\u0151 adott helyzetet nem kezel \u00e9s indokolatlanul panaszkodik, Benedek Zolt\u00e1n felel\u0151s oktat\u00f3 fel\u00e9 legyen sz\u00edves jelezni! Ugyanakkor ezeket nagy t\u00f6megben nem fogjuk tudni kezelni. Ha j\u00f3 a megold\u00e1sod, \u00e9s az ellen\u0151rz\u0151 indokolatlanul panaszkodik, a hivatalos ellen\u0151rz\u00e9s sor\u00e1n term\u00e9szetesen el fogjuk fogadni. Az el\u0151ellen\u0151rz\u0151 \u2013 k\u00fcl\u00f6n\u00f6sen az els\u0151 h\u00e1zi feladat eset\u00e9ben \u2013 sokszor el\u00e9gg\u00e9 \"g\u00e9pk\u00f6zeli megfogalmaz\u00e1sban\" jelzi az esetleges probl\u00e9m\u00e1kat. Ha semmik\u00e9ppen nem tudod \u00e9rtelmezni, \u00edrj Benedek Zolt\u00e1nnak Teams-ben, a hiba\u00fczenet megad\u00e1s\u00e1val, illetve egy linkkel a repository-dra . A GitHub \u00e1ltal futtatott ellen\u0151rz\u00e9sek megtekint\u00e9se \u00b6 GitHub-on a navig\u00e1l\u00e1s a repository-hoz Actions tabf\u00fclre v\u00e1lt\u00e1s Itt megjelenik egy t\u00e1bl\u00e1zat, minden push \u00e1ltal futtatott ellen\u0151rz\u00e9shez egy k\u00fcl\u00f6n sor, a tetej\u00e9n van legfrissebb. A sor elej\u00e9n lev\u0151 ikon jelzi a st\u00e1tuszt: v\u00e1r, fut, sikeres, sikertelen lehet. A sor sz\u00f6vege a Git commit neve. Egy sorban a commit nev\u00e9n kattintva jelenik meg egy \u00e1tfog\u00f3 oldal az ellen\u0151rz\u0151 fut\u00e1s\u00e1r\u00f3l, ez sok inform\u00e1ci\u00f3t nem tartalmaz. Ezen az oldalon baloldalt kell a \"build\" vagy \"build-and-check\" (vagy hasonl\u00f3 nev\u0171) linken kattintani, ez \u00e1tnavig\u00e1l az ellen\u0151rz\u00e9s r\u00e9szletes n\u00e9zet\u00e9re. Ez egy \u201e\u00e9l\u0151\u201d n\u00e9zet, ha fut a teszt, folyamatosan friss\u00fcl. Ha v\u00e9gzett, a csom\u00f3pontokat lenyitva lehet megn\u00e9zni az adott l\u00e9p\u00e9s kimenet\u00e9t. Ha minden siker\u00fclt, egy ehhez hasonl\u00f3 n\u00e9zet l\u00e1that\u00f3: Itt a legfontosabb tal\u00e1n a \"Run tests\" l\u00e9p\u00e9s. Ha valamelyik l\u00e9p\u00e9s sikertelen, pipa helyett piros x van a csom\u00f3pont elej\u00e9n, \u00e9s a csom\u00f3pontot kibontva a teszt kimenete utal a hiba ok\u00e1ra. A \"Error Message\"-re, ill. az \"Assert\"-re \u00e9rdemes sz\u00f6vegesen keresni a kimentben, ennek a k\u00f6rny\u00e9k\u00e9n szokott lenni hivatkoz\u00e1s a hiba ok\u00e1ra. Feladat 1 \u2013 Egy egyszer\u0171 .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se \u00b6 TODO Tov\u00e1bbiak \u00b6 Ellen\u0151rz\u0151lista, p\u00e1r j\u00f3tan\u00e1cs, ism\u00e9tl\u00e9sk\u00e9ppen: Van p\u00e1r pont, melyet minden h\u00e1zi bead\u00e1s\u00e1nak v\u00e9g\u00e9n \u00e9rdemes ellen\u0151rizni: l\u00e1sd itt A 2. feladat sor\u00e1n ne felejtsd el a \"Megold\u00e1s bemutat\u00e1sa.txt\"-ben a megold\u00e1sod bemutatni.","title":"1. HF - A modell \u00e9s a k\u00f3d kapcsolata"},{"location":"hazi/1-model-es-kod-kapcsolata/#1-hf-a-modell-es-a-kod-kapcsolata","text":"","title":"1. HF - A modell \u00e9s a k\u00f3d kapcsolata"},{"location":"hazi/1-model-es-kod-kapcsolata/#bevezetes","text":"A feladathoz nem kapcsol\u00f3dik el\u0151ad\u00e1s. A feladatok elm\u00e9leti \u00e9s gyakorlati h\u00e1tter\u00e9\u00fcl az \"1. A modell \u00e9s a k\u00f3d kapcsolata\" vezetett laborgyakorlat szolg\u00e1l: Ezt a laborgyakorlatot a hallgat\u00f3k a gyakorlatvezet\u0151 \u00fatmutat\u00e1s\u00e1val, a gyakorlatvezet\u0151vel k\u00f6z\u00f6sen vezetett m\u00f3don v\u00e9gzik/v\u00e9gezt\u00e9k el. A laborgyakorlathoz \u00fatmutat\u00f3 tartozik, mely r\u00e9szletekbe men\u0151en bemutatja az elm\u00e9leti h\u00e1tteret, valamint l\u00e9p\u00e9senk\u00e9nt ismerteti a megold\u00e1s elk\u00e9sz\u00edt\u00e9s\u00e9t: 1. A modell \u00e9s a k\u00f3d kapcsolata Erre \u00e9p\u00edtve jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel elv\u00e9gezhet\u0151k. Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja: Egy egyszer\u0171 .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok gyakorl\u00e1sa Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1j\u00e1nak gyakorl\u00e1sa A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s.","title":"Bevezet\u00e9s"},{"location":"hazi/1-model-es-kod-kapcsolata/#a-kiindulasi-keret-letoltese-az-elkeszult-megoldas-feltoltese","text":"A h\u00e1zi feladat kiindul\u00e1si k\u00f6rnyezet\u00e9nek publik\u00e1l\u00e1sa, valamint a megold\u00e1s bead\u00e1sa Git, GitHub \u00e9s GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik. F\u0151bb l\u00e9p\u00e9sek: GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t a t\u00e1rgy AUT honlapj\u00e1n tal\u00e1lod. Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod. Ezekhez itt tal\u00e1lhat\u00f3 r\u00e9szletesebb le\u00edr\u00e1s: Git, GitHub, GitHub Classroom A kiindul\u00f3 alkalmaz\u00e1skeret let\u00f6lt\u00e9s\u00e9nek \u00e9s a feladat bead\u00e1s\u00e1nak r\u00e9szletes l\u00e9p\u00e9sei","title":"A kiindul\u00e1si keret let\u00f6lt\u00e9se, az elk\u00e9sz\u00fclt megold\u00e1s felt\u00f6lt\u00e9se"},{"location":"hazi/1-model-es-kod-kapcsolata/#a-hazi-feladat-eloellenorzese","text":"","title":"A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se"},{"location":"hazi/1-model-es-kod-kapcsolata/#a-hazi-feladat-eloellenorzese-es-hivatalos-ertekelese","text":"Minden egyes alkalommal, miut\u00e1n a GitHub-ra push-olt\u00e1l k\u00f3dot, a GitHub-on automatikusan lefut a felt\u00f6lt\u00f6tt k\u00f3d (el\u0151)ellen\u0151rz\u00e9se, \u00e9s meg lehet n\u00e9zni a kimenet\u00e9t! Az ellen\u0151rz\u0151t maga a GitHub futtatja. A push-t k\u00f6vet\u0151en a feladat egy v\u00e1rakoz\u00e1si sorba ker\u00fcl, majd adott id\u0151 ut\u00e1n lefutnak az ellen\u0151rz\u0151 tesztek. Azt nem lehet tudni, mennyi ez az id\u0151, a GitHub-on m\u00falik. Amikor csak egy-k\u00e9t feladat van a sorban a szervezetre (ez n\u00e1lunk a t\u00e1rgy), akkor a tapasztalatok alapj\u00e1n az ellen\u0151rz\u00e9s 1-2 percen bel\u00fcl elindul. De ha a t\u00e1rgy alatt egyszerre sokan kezdik majd felt\u00f6lteni a megold\u00e1st, akkor ez j\u00f3 es\u00e9llyel belassul. Nem \u00e9rdemes ez\u00e9rt sem az utols\u00f3 pillanatra hagyni a bead\u00e1st: lehet, hogy ekkor a k\u00e9sleltet\u00e9sek miatt m\u00e1r nem kapsz esetleg id\u0151ben visszajelz\u00e9st. Hivatalosan a feladat azon \u00e1llapota ker\u00fcl \u00e9rt\u00e9kel\u00e9sre, amely a hat\u00e1rid\u0151 lej\u00e1rtakor GitHub-on fent van. A hivatalos ellen\u0151rz\u00e9st szok\u00e1sos m\u00f3don, saj\u00e1t, oktat\u00f3i k\u00f6rnyezetben v\u00e9gezz\u00fck \u00e9s az eredm\u00e9nyt a t\u00e1rgy honlapj\u00e1n publik\u00e1ljuk a sz\u00e1monk\u00e9r\u00e9sn\u00e9l. Vagyis a hivatalos eredm\u00e9ny tekintet\u00e9ben teljesen mindegy, hogy a GitHub-on a hat\u00e1rid\u0151 lej\u00e1rta lefutott-e m\u00e1r b\u00e1rmif\u00e9le (el\u0151)ellen\u0151rz\u00e9s, vagy hogy az ellen\u0151rz\u00e9s estleg csak k\u00e9s\u0151bb tudott elindulni. A GitHub \u00e1ltali ellen\u0151rz\u00e9s csak azt a c\u00e9lt szolg\u00e1lja, hogy m\u00e9g a hat\u00e1rid\u0151 lej\u00e1rta el\u0151tt visszajelz\u00e9st kaphasson mindenki. A hivatalos ellen\u0151rz\u00e9s tartalmaz m\u00e9g plusz l\u00e9p\u00e9seket a GitHub alap\u00fa el\u0151ellen\u0151rz\u00e9shez l\u00e9pest, az el\u0151ellen\u0151rz\u00e9s ilyen \u00e9rtelemben r\u00e9szleges, de az\u00e9rt sok probl\u00e9m\u00e1t seg\u00edthet megfogni! Arra k\u00e9r\u00fcnk, hogy ne apr\u00e1nk\u00e9nt push-olj, csak a k\u00e9sz, \u00e1tn\u00e9zett, fordul\u00f3 megold\u00e1st tedd fel! Ez nem a legszerencs\u00e9sebb, de a GitHub korl\u00e1tozott id\u0151t biztos\u00edt az ellen\u0151rz\u0151k futtat\u00e1s\u00e1ra: ha elfogy a havi keret, akkor m\u00e1r nem fogtok visszajelz\u00e9st kapni, csak a hat\u00e1rid\u0151 ut\u00e1ni hivatalos ellen\u0151rz\u00e9s kimenet\u00e9t kapja meg mindenki. A (f\u00e9l)automata ellen\u0151rz\u0151, most m\u00e9g egy r\u00e9szben k\u00eds\u00e9rleti projekt. Ha valaki az \u00fatmutat\u00f3ban inkonzisztenci\u00e1t tal\u00e1l, vagy az ellen\u0151rz\u0151 adott helyzetet nem kezel \u00e9s indokolatlanul panaszkodik, Benedek Zolt\u00e1n felel\u0151s oktat\u00f3 fel\u00e9 legyen sz\u00edves jelezni! Ugyanakkor ezeket nagy t\u00f6megben nem fogjuk tudni kezelni. Ha j\u00f3 a megold\u00e1sod, \u00e9s az ellen\u0151rz\u0151 indokolatlanul panaszkodik, a hivatalos ellen\u0151rz\u00e9s sor\u00e1n term\u00e9szetesen el fogjuk fogadni. Az el\u0151ellen\u0151rz\u0151 \u2013 k\u00fcl\u00f6n\u00f6sen az els\u0151 h\u00e1zi feladat eset\u00e9ben \u2013 sokszor el\u00e9gg\u00e9 \"g\u00e9pk\u00f6zeli megfogalmaz\u00e1sban\" jelzi az esetleges probl\u00e9m\u00e1kat. Ha semmik\u00e9ppen nem tudod \u00e9rtelmezni, \u00edrj Benedek Zolt\u00e1nnak Teams-ben, a hiba\u00fczenet megad\u00e1s\u00e1val, illetve egy linkkel a repository-dra .","title":"A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se"},{"location":"hazi/1-model-es-kod-kapcsolata/#a-github-altal-futtatott-ellenorzesek-megtekintese","text":"GitHub-on a navig\u00e1l\u00e1s a repository-hoz Actions tabf\u00fclre v\u00e1lt\u00e1s Itt megjelenik egy t\u00e1bl\u00e1zat, minden push \u00e1ltal futtatott ellen\u0151rz\u00e9shez egy k\u00fcl\u00f6n sor, a tetej\u00e9n van legfrissebb. A sor elej\u00e9n lev\u0151 ikon jelzi a st\u00e1tuszt: v\u00e1r, fut, sikeres, sikertelen lehet. A sor sz\u00f6vege a Git commit neve. Egy sorban a commit nev\u00e9n kattintva jelenik meg egy \u00e1tfog\u00f3 oldal az ellen\u0151rz\u0151 fut\u00e1s\u00e1r\u00f3l, ez sok inform\u00e1ci\u00f3t nem tartalmaz. Ezen az oldalon baloldalt kell a \"build\" vagy \"build-and-check\" (vagy hasonl\u00f3 nev\u0171) linken kattintani, ez \u00e1tnavig\u00e1l az ellen\u0151rz\u00e9s r\u00e9szletes n\u00e9zet\u00e9re. Ez egy \u201e\u00e9l\u0151\u201d n\u00e9zet, ha fut a teszt, folyamatosan friss\u00fcl. Ha v\u00e9gzett, a csom\u00f3pontokat lenyitva lehet megn\u00e9zni az adott l\u00e9p\u00e9s kimenet\u00e9t. Ha minden siker\u00fclt, egy ehhez hasonl\u00f3 n\u00e9zet l\u00e1that\u00f3: Itt a legfontosabb tal\u00e1n a \"Run tests\" l\u00e9p\u00e9s. Ha valamelyik l\u00e9p\u00e9s sikertelen, pipa helyett piros x van a csom\u00f3pont elej\u00e9n, \u00e9s a csom\u00f3pontot kibontva a teszt kimenete utal a hiba ok\u00e1ra. A \"Error Message\"-re, ill. az \"Assert\"-re \u00e9rdemes sz\u00f6vegesen keresni a kimentben, ennek a k\u00f6rny\u00e9k\u00e9n szokott lenni hivatkoz\u00e1s a hiba ok\u00e1ra.","title":"A GitHub \u00e1ltal futtatott ellen\u0151rz\u00e9sek megtekint\u00e9se"},{"location":"hazi/1-model-es-kod-kapcsolata/#feladat-1-egy-egyszeru-net-konzol-alkalmazas-elkeszitese","text":"TODO","title":"Feladat 1 \u2013 Egy egyszer\u0171 .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se"},{"location":"hazi/1-model-es-kod-kapcsolata/#tovabbiak","text":"Ellen\u0151rz\u0151lista, p\u00e1r j\u00f3tan\u00e1cs, ism\u00e9tl\u00e9sk\u00e9ppen: Van p\u00e1r pont, melyet minden h\u00e1zi bead\u00e1s\u00e1nak v\u00e9g\u00e9n \u00e9rdemes ellen\u0151rizni: l\u00e1sd itt A 2. feladat sor\u00e1n ne felejtsd el a \"Megold\u00e1s bemutat\u00e1sa.txt\"-ben a megold\u00e1sod bemutatni.","title":"Tov\u00e1bbiak"},{"location":"hazi/2-modern-nyelvi-eszkozok/","text":"2. HF - Modern nyelvi eszk\u00f6z\u00f6k \u00b6 COMING SOON","title":"2. HF - Modern nyelvi eszk\u00f6z\u00f6k"},{"location":"hazi/2-modern-nyelvi-eszkozok/#2-hf-modern-nyelvi-eszkozok","text":"COMING SOON","title":"2. HF - Modern nyelvi eszk\u00f6z\u00f6k"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/","text":"3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa \u00b6 COMING SOON","title":"3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#3-hf-felhasznaloi-felulet-kialakitasa","text":"COMING SOON","title":"3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/","text":"4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se \u00b6 COMING SOON","title":"4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#4-hf-tobbszalu-alkalmazasok-fejlesztese","text":"COMING SOON","title":"4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se"},{"location":"hazi/5-document-view-architectura/","text":"5. HF - Document-View architekt\u00fara \u00b6 COMING SOON","title":"5. HF - Document-View architekt\u00fara"},{"location":"hazi/5-document-view-architectura/#5-hf-document-view-architektura","text":"COMING SOON","title":"5. HF - Document-View architekt\u00fara"},{"location":"hazi/beadas-ellenorzes/","text":"H\u00e1zi feladat bead\u00e1sa sor\u00e1n ellen\u0151rizend\u0151k \u00b6 A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s. A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban. Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e. L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni. Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).","title":"H\u00e1zi feladat bead\u00e1sa sor\u00e1n ellen\u0151rizend\u0151k"},{"location":"hazi/beadas-ellenorzes/#hazi-feladat-beadasa-soran-ellenorizendok","text":"A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s. A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban. Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e. L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni. Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).","title":"H\u00e1zi feladat bead\u00e1sa sor\u00e1n ellen\u0151rizend\u0151k"},{"location":"hazi/fejlesztokornyezet/","text":"1. H\u00e1zi feladatok - fejleszt\u0151k\u00f6rnyezet \u00b6 Bevezet\u00e9s \u00b6 A f\u00e9l\u00e9v sor\u00e1n a h\u00e1zi feladatok megold\u00e1s\u00e1hoz a Visual Studio 2022 fejleszt\u0151k\u00f6rnyezetet kell haszn\u00e1lni (a Visual Studio for Mac nem alkalmas). Ennek futtat\u00e1s\u00e1hoz Windows oper\u00e1ci\u00f3s rendszerre van sz\u00fcks\u00e9g. Ha telep\u00edtve van m\u00e1r a g\u00e9p\u00fcnkre a Visual Studio 2022, akkor a Start men\u00fcb\u0151l ind\u00edtsuk el a \u201eVisual Studio Installer\u201d-t. Ez indul\u00e1skor ellen\u0151rzi, \u00e9rhet\u0151-e el Visual Studio-b\u00f3l \u00fajabb v\u00e1ltozat online, \u00e9s ha igen, az Update gombra kattintva ind\u00edtsuk is el a legfrissebb verzi\u00f3 telep\u00edt\u00e9s\u00e9t. Mi\u00e9rt is van sz\u00fcks\u00e9g Visual Studiora \u00e9s Windowsra? VS Code, illetve a Visual Studio for Mac a k\u00f6vetkez\u0151k miatt nem haszn\u00e1lhat\u00f3k: Nem t\u00e1mogatj\u00e1k az UML (szer\u0171) modellez\u00e9st, melyre az els\u0151 h\u00e1zi feladatn\u00e1l sz\u00fcks\u00e9g van. \u00c9rdemben nem t\u00e1mogatj\u00e1k a Windows Form \u0171rlap alap\u00fa .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9t (erre a 3-5 h\u00e1zi feladat \u00e9p\u00edt). Visual Studio edition-\u00f6k \u00b6 A Visual Studionak t\u00f6bb kiad\u00e1sa l\u00e9tezik: A t\u00e1rgy teljes\u00edt\u00e9s\u00e9hez megfelel a Microsoft honlapj\u00e1r\u00f3l let\u00f6lthet\u0151 \u00e9s ingyenesen haszn\u00e1lhat\u00f3 Community edition. Term\u00e9szetesen a Professional \u00e9s Enterprise v\u00e1ltozatok is haszn\u00e1lhat\u00f3k, a t\u00e1rgy vonatkoz\u00e1s\u00e1ban ugyanakkor ezek \u00e9rdemi pluszt nem adnak. Ezek az egy\u00e9bk\u00e9nt fizet\u0151s v\u00e1ltozatok az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ingyenesen el\u00e9rhet\u0151k (a https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben). Telep\u00edtend\u0151 komponensek \u00b6 A t\u00e1rgy els\u0151 el\u0151ad\u00e1sa r\u00f6viden kit\u00e9r a .NET k\u00fcl\u00f6nb\u00f6z\u0151 v\u00e1ltozataira (.NET Framework, .NET Core, .NET 5-7 \u00e9s stb.). A feladatok megold\u00e1s\u00e1hoz a .NET 7-et haszn\u00e1ljuk a f\u00e9l\u00e9v sor\u00e1n. A Visual Studio ezt telep\u00edti, de sz\u00fcks\u00e9g van a \".NET desktop development\" Visual Studio Workload telep\u00edt\u00e9s\u00e9re: Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel). Modify gombra kattint\u00e1s A megjelen\u0151 ablakban ellen\u0151rizz\u00fck, hogy a \".NET desktop development\" k\u00e1rtya ki van-e pip\u00e1lva. Ha nincs, pip\u00e1ljuk ki, majd a jobb als\u00f3 sarokban a Modify gombra kattintva telep\u00edts\u00fck. Bizonyos h\u00e1zi feladatok eset\u00e9n (m\u00e1r az els\u0151n\u00e9l is) sz\u00fcks\u00e9g van Visual Studio Class Diagram t\u00e1mogat\u00e1sra. Ezt a k\u00f6vetkez\u0151k\u00e9ppen tudjuk ut\u00f3lag telep\u00edteni a Visual Studio al\u00e1: Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel). Modify gombra kattint\u00e1s A megjelen\u0151 ablakban \"Individual components\" f\u00fcl kiv\u00e1laszt\u00e1sa A keres\u0151mez\u0151be \"class designer\" beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \"Class Designer\" elem ki van pip\u00e1lva. Ha nincs, pip\u00e1ljuk ki, majd a jobb als\u00f3 sarokban a Modify gombra kattintva telep\u00edts\u00fck. MacBook \u00e9s Linux haszn\u00e1l\u00f3k sz\u00e1m\u00e1ra inform\u00e1ci\u00f3k \u00b6 A t\u00e1rgy felel\u0151s oktat\u00f3j\u00e1t\u00f3l (Benedek Zolt\u00e1n) BME Cloud hozz\u00e1f\u00e9r\u00e9s ig\u00e9nylelhet\u0151 e-mailben.","title":"1. H\u00e1zi feladatok - fejleszt\u0151k\u00f6rnyezet"},{"location":"hazi/fejlesztokornyezet/#1-hazi-feladatok-fejlesztokornyezet","text":"","title":"1. H\u00e1zi feladatok - fejleszt\u0151k\u00f6rnyezet"},{"location":"hazi/fejlesztokornyezet/#bevezetes","text":"A f\u00e9l\u00e9v sor\u00e1n a h\u00e1zi feladatok megold\u00e1s\u00e1hoz a Visual Studio 2022 fejleszt\u0151k\u00f6rnyezetet kell haszn\u00e1lni (a Visual Studio for Mac nem alkalmas). Ennek futtat\u00e1s\u00e1hoz Windows oper\u00e1ci\u00f3s rendszerre van sz\u00fcks\u00e9g. Ha telep\u00edtve van m\u00e1r a g\u00e9p\u00fcnkre a Visual Studio 2022, akkor a Start men\u00fcb\u0151l ind\u00edtsuk el a \u201eVisual Studio Installer\u201d-t. Ez indul\u00e1skor ellen\u0151rzi, \u00e9rhet\u0151-e el Visual Studio-b\u00f3l \u00fajabb v\u00e1ltozat online, \u00e9s ha igen, az Update gombra kattintva ind\u00edtsuk is el a legfrissebb verzi\u00f3 telep\u00edt\u00e9s\u00e9t. Mi\u00e9rt is van sz\u00fcks\u00e9g Visual Studiora \u00e9s Windowsra? VS Code, illetve a Visual Studio for Mac a k\u00f6vetkez\u0151k miatt nem haszn\u00e1lhat\u00f3k: Nem t\u00e1mogatj\u00e1k az UML (szer\u0171) modellez\u00e9st, melyre az els\u0151 h\u00e1zi feladatn\u00e1l sz\u00fcks\u00e9g van. \u00c9rdemben nem t\u00e1mogatj\u00e1k a Windows Form \u0171rlap alap\u00fa .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9t (erre a 3-5 h\u00e1zi feladat \u00e9p\u00edt).","title":"Bevezet\u00e9s"},{"location":"hazi/fejlesztokornyezet/#visual-studio-edition-ok","text":"A Visual Studionak t\u00f6bb kiad\u00e1sa l\u00e9tezik: A t\u00e1rgy teljes\u00edt\u00e9s\u00e9hez megfelel a Microsoft honlapj\u00e1r\u00f3l let\u00f6lthet\u0151 \u00e9s ingyenesen haszn\u00e1lhat\u00f3 Community edition. Term\u00e9szetesen a Professional \u00e9s Enterprise v\u00e1ltozatok is haszn\u00e1lhat\u00f3k, a t\u00e1rgy vonatkoz\u00e1s\u00e1ban ugyanakkor ezek \u00e9rdemi pluszt nem adnak. Ezek az egy\u00e9bk\u00e9nt fizet\u0151s v\u00e1ltozatok az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ingyenesen el\u00e9rhet\u0151k (a https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben).","title":"Visual Studio edition-\u00f6k"},{"location":"hazi/fejlesztokornyezet/#telepitendo-komponensek","text":"A t\u00e1rgy els\u0151 el\u0151ad\u00e1sa r\u00f6viden kit\u00e9r a .NET k\u00fcl\u00f6nb\u00f6z\u0151 v\u00e1ltozataira (.NET Framework, .NET Core, .NET 5-7 \u00e9s stb.). A feladatok megold\u00e1s\u00e1hoz a .NET 7-et haszn\u00e1ljuk a f\u00e9l\u00e9v sor\u00e1n. A Visual Studio ezt telep\u00edti, de sz\u00fcks\u00e9g van a \".NET desktop development\" Visual Studio Workload telep\u00edt\u00e9s\u00e9re: Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel). Modify gombra kattint\u00e1s A megjelen\u0151 ablakban ellen\u0151rizz\u00fck, hogy a \".NET desktop development\" k\u00e1rtya ki van-e pip\u00e1lva. Ha nincs, pip\u00e1ljuk ki, majd a jobb als\u00f3 sarokban a Modify gombra kattintva telep\u00edts\u00fck. Bizonyos h\u00e1zi feladatok eset\u00e9n (m\u00e1r az els\u0151n\u00e9l is) sz\u00fcks\u00e9g van Visual Studio Class Diagram t\u00e1mogat\u00e1sra. Ezt a k\u00f6vetkez\u0151k\u00e9ppen tudjuk ut\u00f3lag telep\u00edteni a Visual Studio al\u00e1: Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel). Modify gombra kattint\u00e1s A megjelen\u0151 ablakban \"Individual components\" f\u00fcl kiv\u00e1laszt\u00e1sa A keres\u0151mez\u0151be \"class designer\" beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \"Class Designer\" elem ki van pip\u00e1lva. Ha nincs, pip\u00e1ljuk ki, majd a jobb als\u00f3 sarokban a Modify gombra kattintva telep\u00edts\u00fck.","title":"Telep\u00edtend\u0151 komponensek"},{"location":"hazi/fejlesztokornyezet/#macbook-es-linux-hasznalok-szamara-informaciok","text":"A t\u00e1rgy felel\u0151s oktat\u00f3j\u00e1t\u00f3l (Benedek Zolt\u00e1n) BME Cloud hozz\u00e1f\u00e9r\u00e9s ig\u00e9nylelhet\u0151 e-mailben.","title":"MacBook \u00e9s Linux haszn\u00e1l\u00f3k sz\u00e1m\u00e1ra inform\u00e1ci\u00f3k"},{"location":"hazi/git-github-github-classroom/","text":"Git, GitHub, GitHub Classroom \u00b6 A t\u00e1rgy keret\u00e9ben nem c\u00e9lunk a Git \u00e9s GitHub, r\u00e9szletes megismer\u00e9se, csak a legsz\u00fcks\u00e9gesebb l\u00e9p\u00e9sekre szor\u00edtkozunk, valamint a legfontosabb parancsokat haszn\u00e1ljuk ahhoz, hogy a h\u00e1zi feladat(ok) kiindul\u00e1si programv\u00e1z\u00e1t egy dedik\u00e1lt GitHub repository-b\u00f3l le tudjuk t\u00f6lteni, illetve a k\u00e9sz munk\u00e1t GitHubra fel tudjuk t\u00f6lteni. Git \u00b6 A Git egy sok szolg\u00e1ltat\u00e1ssal rendelkez\u0151, rendk\u00edv\u00fcl n\u00e9pszer\u0171 \u00e9s elterjedt, ingyenesen let\u00f6lthet\u0151 \u00e9s telep\u00edthet\u0151, elosztottan is haszn\u00e1lhat\u00f3 verzi\u00f3kezel\u0151 rendszer. A k\u00f6zpontos\u00edtott rendszerekhez k\u00e9pest (TFS, CVS, SNV) a GIT eset\u00e9ben nem egyetlen k\u00f6zponti repository-ba dolgoznak a fejleszt\u0151k, hanem mindenki egy saj\u00e1t lok\u00e1lis repository p\u00e9ld\u00e1nnyal rendelkezik. A folyamat legfontosabb l\u00e9p\u00e9sei - n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel - a k\u00f6vetkez\u0151k (felt\u00e9ve, hogy l\u00e9tezik egy k\u00f6zponti repository, ahol a verzi\u00f3kezelt k\u00f3d adott v\u00e1ltozata m\u00e1r el\u00e9rhet\u0151): A fejleszt\u0151 kl\u00f3nozza ( clone ) az adott k\u00f6zponti repository-t, melynek sor\u00e1n egy azzal megegyez\u0151 helyi repository j\u00f6n l\u00e9tre a saj\u00e1t sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n. Ezt a m\u0171veletet el\u00e9g egyszer elv\u00e9gezni. A fejleszt\u0151 a helyi repository-hoz tartoz\u00f3 munkak\u00f6nyvt\u00e1rban (working directory) v\u00e1ltoztat\u00e1sokat v\u00e9gez a k\u00f3don: \u00faj f\u00e1jlokat vesz fel, megl\u00e9v\u0151ket m\u00f3dos\u00edt \u00e9s t\u00f6r\u00f6l. Ha elk\u00e9sz\u00fcl egy \u00e9rdemi r\u00e9szfeladat, akkor a fejleszt\u0151 a v\u00e1ltoztat\u00e1sokat commit -olja a sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n lev\u0151 helyi repository-ba. Ennek sor\u00e1n a commit-ot c\u00e9lszer\u0171 egy a v\u00e1ltoztat\u00e1sok jelleg\u00e9t j\u00f3l \u00f6sszefoglal\u00f3 megjegyz\u00e9ssel ell\u00e1tni. A helyi repository-b\u00f3l egy push m\u0171velettel a fejleszt\u0151 fel\u00f6lti a v\u00e1ltoz\u00e1sokat a k\u00f6zponti repository-ba, ahol \u00edgy v\u00e1ltoztat\u00e1sai m\u00e1sok sz\u00e1m\u00e1ra is l\u00e1that\u00f3v\u00e1 v\u00e1lnak. Minden egyes commit tulajdonk\u00e9ppen egy id\u0151b\u00e9lyeggel, a fejleszt\u0151 felhaszn\u00e1l\u00f3nev\u00e9vel \u00e9s e-mail c\u00edm\u00e9vel ell\u00e1tott k\u00f3dot \u00e9rint\u0151 v\u00e1ltoz\u00e1shalmaz. Mivel a legt\u00f6bb esetben a fejleszt\u0151k csapatban dolgoznak, id\u0151nk\u00e9nt sz\u00fcks\u00e9g van arra, hogy m\u00e1sok \u00e1ltal a k\u00f6zponti repository-ba push -olt v\u00e1ltoztat\u00e1sokat a fejleszt\u0151k a saj\u00e1t lok\u00e1lis repository-jukba let\u00f6lts\u00e9k \u00e9s belemerge-elj\u00e9k: erre szolg\u00e1l a pull m\u0171velet. Fontos szab\u00e1ly, hogy push -olni csak akkor lehet a k\u00f6zponti repository-ba (a Git csak akkor engedi), ha el\u0151tte m\u00e1sok v\u00e1ltoztat\u00e1sait a saj\u00e1t lok\u00e1lis repository-nkba egy pull m\u0171velettel el\u0151tte belemerge-elt\u00fck. A Szoftvertechnik\u00e1k t\u00e1rgy keret\u00e9ben a pull m\u0171veletet nem kell haszn\u00e1lni, mert mindenki \u00f6n\u00e1ll\u00f3an, saj\u00e1t repository-ba dolgozik. Megjegyz\u00e9s: ha esetleg a GitHub fel\u00fclet\u00e9n k\u00f6zvetlen v\u00e1ltoztatunk f\u00e1jlokon, vagy t\u00f6bb clone-ban is dolgozunk, akkor sz\u00fcks\u00e9g van a pull haszn\u00e1lat\u00e1ra. A fentieken t\u00falmen\u0151en a GIT sz\u00e1mos tov\u00e1bbi szolg\u00e1ltat\u00e1st biztos\u00edt (pl. teljes verzi\u00f3t\u00f6rt\u00e9net megtekint\u00e9se minden f\u00e1jlra, commit t\u00f6rt\u00e9net megtekint\u00e9se, tetsz\u0151leges m\u00faltbeli verzi\u00f3ra vissza\u00e1ll\u00e1s, \u00e1gak kezel\u00e9se stb.). GitHub \u00b6 A GitHub egy online el\u00e9rhet\u0151 website \u00e9s szolg\u00e1ltat\u00e1s ( https://github.com ), mely teljes k\u00f6r\u0171 Git szolg\u00e1ltat\u00e1st biztos\u00edt. Mindezt r\u00e1ad\u00e1sul \u2013 legal\u00e1bbis publikus, vagyis mindenki sz\u00e1m\u00e1ra hozz\u00e1f\u00e9rhet\u0151 repository-k vonatkoz\u00e1s\u00e1ban \u2013 teljesen ingyenesen. Napjainkra a GitHub v\u00e1lt a k\u00f6z\u00f6ss\u00e9gi k\u00f3d (verzi\u00f3kezelt) t\u00e1rol\u00e1s\u00e1nak els\u0151 sz\u00e1m\u00fa platformj\u00e1v\u00e1, a legt\u00f6bb open source projekt \u201eotthon\u00e1v\u00e1\u201d. GitHub Classroom \u00b6 A GitHub Classroom egy ingyenesen el\u00e9rhet\u0151 GitHub-bal integr\u00e1lt szolg\u00e1ltat\u00e1s, mely t\u00f6bbek k\u00f6z\u00f6tt oktat\u00e1si int\u00e9zm\u00e9nyek sz\u00e1m\u00e1ra lehet\u0151v\u00e9 teszi \u00f6n\u00e1ll\u00f3 tanul\u00f3i feladatokhoz tartoz\u00f3 tanul\u00f3nk\u00e9nt egyedi GitHub repository-k l\u00e9trehoz\u00e1s\u00e1t, ez\u00e1ltal a kiindul\u00e1si k\u00f3d tanul\u00f3k sz\u00e1m\u00e1ra t\u00f6rt\u00e9n\u0151 \u201ekioszt\u00e1s\u00e1t\u201d, valamint az elk\u00e9sz\u00fclt feladatok \u201ebeszed\u00e9s\u00e9t\u201d. Git, GitHub \u00e9s GitHub Classroom a t\u00e1rgy kontextus\u00e1ban \u00b6 A t\u00e1rgy keret\u00e9ben a GitHub Classroom seg\u00edts\u00e9g\u00e9vel kap minden hallgat\u00f3 minden h\u00e1zi feladat\u00e1hoz egy dedik\u00e1lt, a GitHub-on hostolt repository-t, mely a megfelel\u0151 kiindul\u00e1si k\u00f6rnyezettel (kiindul\u00f3 Visual Studio solution-\u00f6k) inicializ\u00e1l\u00e1sra ker\u00fcl. Mindenkinek a sz\u00e1m\u00e1ra dedik\u00e1lt repository-t kell a saj\u00e1t g\u00e9p\u00e9re clone -oznia, ebbe a v\u00e1ltoztat\u00e1sait commit -\u00e1lni, \u00e9s a hat\u00e1rid\u0151ig az elk\u00e9sz\u00fclt megold\u00e1s\u00e1t push -olni. A pontos l\u00e9p\u00e9sekre r\u00f6videsen visszat\u00e9r\u00fcnk. Visual Studio \u00e9s a Git \u00b6 A Git egy elosztott verzi\u00f3kezel\u0151 rendszer. Ahhoz, hogy a saj\u00e1t g\u00e9p\u00fcnk\u00f6n dolgozni tudjunk vele, a Git-nek telep\u00edtve kell lennie. A Git \u00f6nmag\u00e1ban is telep\u00edthet\u0151, \u00e9s parancssorb\u00f3l is ki tudjuk adni a sz\u00fcks\u00e9ges clone, commit, push stb. parancsokat. Az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt a t\u00e1rgy keret\u00e9ben a Git telep\u00edt\u00e9s\u00e9re \u00e9s m\u00e9g ink\u00e1bb a parancsok kiad\u00e1s\u00e1ra egy grafikus fel\u00fclettel rendelkez\u0151 eszk\u00f6z javasolt (de a rutinosak nyugodtan dolgozhatnak parancssorb\u00f3l is). A c\u00e9lnak t\u00f6k\u00e9letesen megfelel a Visual Studio, mely integr\u00e1lt grafikus Git szolg\u00e1ltat\u00e1sokat is biztos\u00edt, de ha valaki esetleg otthonosan haszn\u00e1lja m\u00e1r a parancssort, vagy valamilyen m\u00e1s grafikus eszk\u00f6zt (pl. GitExtensions, GitHub Desktop), term\u00e9szetesen ezek is t\u00f6k\u00e9letesen megfelelnek a c\u00e9lnak. Jelen \u00fatmutat\u00f3 mindenesetre a Visual Studio Git szolg\u00e1ltat\u00e1sait ismerteti. Git telep\u00edt\u00e9se \u00b6 Amennyiben a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre nincs m\u00e9g a Git telep\u00edtve, \u00e9s szeretn\u00e9nk azt parancssorb\u00f3l is haszn\u00e1lni, akkor innen telep\u00edthet\u0151 Windows oper\u00e1ci\u00f3s rendszerre: https://git-scm.com/download/win . Egy\u00e9b oper\u00e1ci\u00f3s rendszerekhez pedig innen \u00e9rdemes indulni: https://git-scm.com/downloads .","title":"Git, GitHub, GitHub Classroom"},{"location":"hazi/git-github-github-classroom/#git-github-github-classroom","text":"A t\u00e1rgy keret\u00e9ben nem c\u00e9lunk a Git \u00e9s GitHub, r\u00e9szletes megismer\u00e9se, csak a legsz\u00fcks\u00e9gesebb l\u00e9p\u00e9sekre szor\u00edtkozunk, valamint a legfontosabb parancsokat haszn\u00e1ljuk ahhoz, hogy a h\u00e1zi feladat(ok) kiindul\u00e1si programv\u00e1z\u00e1t egy dedik\u00e1lt GitHub repository-b\u00f3l le tudjuk t\u00f6lteni, illetve a k\u00e9sz munk\u00e1t GitHubra fel tudjuk t\u00f6lteni.","title":"Git, GitHub, GitHub Classroom"},{"location":"hazi/git-github-github-classroom/#git","text":"A Git egy sok szolg\u00e1ltat\u00e1ssal rendelkez\u0151, rendk\u00edv\u00fcl n\u00e9pszer\u0171 \u00e9s elterjedt, ingyenesen let\u00f6lthet\u0151 \u00e9s telep\u00edthet\u0151, elosztottan is haszn\u00e1lhat\u00f3 verzi\u00f3kezel\u0151 rendszer. A k\u00f6zpontos\u00edtott rendszerekhez k\u00e9pest (TFS, CVS, SNV) a GIT eset\u00e9ben nem egyetlen k\u00f6zponti repository-ba dolgoznak a fejleszt\u0151k, hanem mindenki egy saj\u00e1t lok\u00e1lis repository p\u00e9ld\u00e1nnyal rendelkezik. A folyamat legfontosabb l\u00e9p\u00e9sei - n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel - a k\u00f6vetkez\u0151k (felt\u00e9ve, hogy l\u00e9tezik egy k\u00f6zponti repository, ahol a verzi\u00f3kezelt k\u00f3d adott v\u00e1ltozata m\u00e1r el\u00e9rhet\u0151): A fejleszt\u0151 kl\u00f3nozza ( clone ) az adott k\u00f6zponti repository-t, melynek sor\u00e1n egy azzal megegyez\u0151 helyi repository j\u00f6n l\u00e9tre a saj\u00e1t sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n. Ezt a m\u0171veletet el\u00e9g egyszer elv\u00e9gezni. A fejleszt\u0151 a helyi repository-hoz tartoz\u00f3 munkak\u00f6nyvt\u00e1rban (working directory) v\u00e1ltoztat\u00e1sokat v\u00e9gez a k\u00f3don: \u00faj f\u00e1jlokat vesz fel, megl\u00e9v\u0151ket m\u00f3dos\u00edt \u00e9s t\u00f6r\u00f6l. Ha elk\u00e9sz\u00fcl egy \u00e9rdemi r\u00e9szfeladat, akkor a fejleszt\u0151 a v\u00e1ltoztat\u00e1sokat commit -olja a sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n lev\u0151 helyi repository-ba. Ennek sor\u00e1n a commit-ot c\u00e9lszer\u0171 egy a v\u00e1ltoztat\u00e1sok jelleg\u00e9t j\u00f3l \u00f6sszefoglal\u00f3 megjegyz\u00e9ssel ell\u00e1tni. A helyi repository-b\u00f3l egy push m\u0171velettel a fejleszt\u0151 fel\u00f6lti a v\u00e1ltoz\u00e1sokat a k\u00f6zponti repository-ba, ahol \u00edgy v\u00e1ltoztat\u00e1sai m\u00e1sok sz\u00e1m\u00e1ra is l\u00e1that\u00f3v\u00e1 v\u00e1lnak. Minden egyes commit tulajdonk\u00e9ppen egy id\u0151b\u00e9lyeggel, a fejleszt\u0151 felhaszn\u00e1l\u00f3nev\u00e9vel \u00e9s e-mail c\u00edm\u00e9vel ell\u00e1tott k\u00f3dot \u00e9rint\u0151 v\u00e1ltoz\u00e1shalmaz. Mivel a legt\u00f6bb esetben a fejleszt\u0151k csapatban dolgoznak, id\u0151nk\u00e9nt sz\u00fcks\u00e9g van arra, hogy m\u00e1sok \u00e1ltal a k\u00f6zponti repository-ba push -olt v\u00e1ltoztat\u00e1sokat a fejleszt\u0151k a saj\u00e1t lok\u00e1lis repository-jukba let\u00f6lts\u00e9k \u00e9s belemerge-elj\u00e9k: erre szolg\u00e1l a pull m\u0171velet. Fontos szab\u00e1ly, hogy push -olni csak akkor lehet a k\u00f6zponti repository-ba (a Git csak akkor engedi), ha el\u0151tte m\u00e1sok v\u00e1ltoztat\u00e1sait a saj\u00e1t lok\u00e1lis repository-nkba egy pull m\u0171velettel el\u0151tte belemerge-elt\u00fck. A Szoftvertechnik\u00e1k t\u00e1rgy keret\u00e9ben a pull m\u0171veletet nem kell haszn\u00e1lni, mert mindenki \u00f6n\u00e1ll\u00f3an, saj\u00e1t repository-ba dolgozik. Megjegyz\u00e9s: ha esetleg a GitHub fel\u00fclet\u00e9n k\u00f6zvetlen v\u00e1ltoztatunk f\u00e1jlokon, vagy t\u00f6bb clone-ban is dolgozunk, akkor sz\u00fcks\u00e9g van a pull haszn\u00e1lat\u00e1ra. A fentieken t\u00falmen\u0151en a GIT sz\u00e1mos tov\u00e1bbi szolg\u00e1ltat\u00e1st biztos\u00edt (pl. teljes verzi\u00f3t\u00f6rt\u00e9net megtekint\u00e9se minden f\u00e1jlra, commit t\u00f6rt\u00e9net megtekint\u00e9se, tetsz\u0151leges m\u00faltbeli verzi\u00f3ra vissza\u00e1ll\u00e1s, \u00e1gak kezel\u00e9se stb.).","title":"Git"},{"location":"hazi/git-github-github-classroom/#github","text":"A GitHub egy online el\u00e9rhet\u0151 website \u00e9s szolg\u00e1ltat\u00e1s ( https://github.com ), mely teljes k\u00f6r\u0171 Git szolg\u00e1ltat\u00e1st biztos\u00edt. Mindezt r\u00e1ad\u00e1sul \u2013 legal\u00e1bbis publikus, vagyis mindenki sz\u00e1m\u00e1ra hozz\u00e1f\u00e9rhet\u0151 repository-k vonatkoz\u00e1s\u00e1ban \u2013 teljesen ingyenesen. Napjainkra a GitHub v\u00e1lt a k\u00f6z\u00f6ss\u00e9gi k\u00f3d (verzi\u00f3kezelt) t\u00e1rol\u00e1s\u00e1nak els\u0151 sz\u00e1m\u00fa platformj\u00e1v\u00e1, a legt\u00f6bb open source projekt \u201eotthon\u00e1v\u00e1\u201d.","title":"GitHub"},{"location":"hazi/git-github-github-classroom/#github-classroom","text":"A GitHub Classroom egy ingyenesen el\u00e9rhet\u0151 GitHub-bal integr\u00e1lt szolg\u00e1ltat\u00e1s, mely t\u00f6bbek k\u00f6z\u00f6tt oktat\u00e1si int\u00e9zm\u00e9nyek sz\u00e1m\u00e1ra lehet\u0151v\u00e9 teszi \u00f6n\u00e1ll\u00f3 tanul\u00f3i feladatokhoz tartoz\u00f3 tanul\u00f3nk\u00e9nt egyedi GitHub repository-k l\u00e9trehoz\u00e1s\u00e1t, ez\u00e1ltal a kiindul\u00e1si k\u00f3d tanul\u00f3k sz\u00e1m\u00e1ra t\u00f6rt\u00e9n\u0151 \u201ekioszt\u00e1s\u00e1t\u201d, valamint az elk\u00e9sz\u00fclt feladatok \u201ebeszed\u00e9s\u00e9t\u201d.","title":"GitHub Classroom"},{"location":"hazi/git-github-github-classroom/#git-github-es-github-classroom-a-targy-kontextusaban","text":"A t\u00e1rgy keret\u00e9ben a GitHub Classroom seg\u00edts\u00e9g\u00e9vel kap minden hallgat\u00f3 minden h\u00e1zi feladat\u00e1hoz egy dedik\u00e1lt, a GitHub-on hostolt repository-t, mely a megfelel\u0151 kiindul\u00e1si k\u00f6rnyezettel (kiindul\u00f3 Visual Studio solution-\u00f6k) inicializ\u00e1l\u00e1sra ker\u00fcl. Mindenkinek a sz\u00e1m\u00e1ra dedik\u00e1lt repository-t kell a saj\u00e1t g\u00e9p\u00e9re clone -oznia, ebbe a v\u00e1ltoztat\u00e1sait commit -\u00e1lni, \u00e9s a hat\u00e1rid\u0151ig az elk\u00e9sz\u00fclt megold\u00e1s\u00e1t push -olni. A pontos l\u00e9p\u00e9sekre r\u00f6videsen visszat\u00e9r\u00fcnk.","title":"Git, GitHub \u00e9s GitHub Classroom a t\u00e1rgy kontextus\u00e1ban"},{"location":"hazi/git-github-github-classroom/#visual-studio-es-a-git","text":"A Git egy elosztott verzi\u00f3kezel\u0151 rendszer. Ahhoz, hogy a saj\u00e1t g\u00e9p\u00fcnk\u00f6n dolgozni tudjunk vele, a Git-nek telep\u00edtve kell lennie. A Git \u00f6nmag\u00e1ban is telep\u00edthet\u0151, \u00e9s parancssorb\u00f3l is ki tudjuk adni a sz\u00fcks\u00e9ges clone, commit, push stb. parancsokat. Az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt a t\u00e1rgy keret\u00e9ben a Git telep\u00edt\u00e9s\u00e9re \u00e9s m\u00e9g ink\u00e1bb a parancsok kiad\u00e1s\u00e1ra egy grafikus fel\u00fclettel rendelkez\u0151 eszk\u00f6z javasolt (de a rutinosak nyugodtan dolgozhatnak parancssorb\u00f3l is). A c\u00e9lnak t\u00f6k\u00e9letesen megfelel a Visual Studio, mely integr\u00e1lt grafikus Git szolg\u00e1ltat\u00e1sokat is biztos\u00edt, de ha valaki esetleg otthonosan haszn\u00e1lja m\u00e1r a parancssort, vagy valamilyen m\u00e1s grafikus eszk\u00f6zt (pl. GitExtensions, GitHub Desktop), term\u00e9szetesen ezek is t\u00f6k\u00e9letesen megfelelnek a c\u00e9lnak. Jelen \u00fatmutat\u00f3 mindenesetre a Visual Studio Git szolg\u00e1ltat\u00e1sait ismerteti.","title":"Visual Studio \u00e9s a Git"},{"location":"hazi/git-github-github-classroom/#git-telepitese","text":"Amennyiben a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre nincs m\u00e9g a Git telep\u00edtve, \u00e9s szeretn\u00e9nk azt parancssorb\u00f3l is haszn\u00e1lni, akkor innen telep\u00edthet\u0151 Windows oper\u00e1ci\u00f3s rendszerre: https://git-scm.com/download/win . Egy\u00e9b oper\u00e1ci\u00f3s rendszerekhez pedig innen \u00e9rdemes indulni: https://git-scm.com/downloads .","title":"Git telep\u00edt\u00e9se"},{"location":"hazi/hf-folyamat/","text":"A kiindul\u00f3 alkalmaz\u00e1skeret let\u00f6lt\u00e9s\u00e9nek \u00e9s a feladat bead\u00e1s\u00e1nak l\u00e9p\u00e9sei \u00b6 L\u00e9p\u00e9sek \u00b6 Az egyes h\u00e1zi feladatok kiindul\u00f3 keret\u00e9t GitHub seg\u00edts\u00e9g\u00e9vel publik\u00e1ljuk (a tov\u00e1bbi h\u00e1zi feladatok vonatkoz\u00e1s\u00e1ban k\u00e9s\u0151bb hozunk d\u00f6nt\u00e9st). A GitHub-on publik\u00e1lt h\u00e1zi feladatok kiindul\u00f3 k\u00f6rnyezet let\u00f6lt\u00e9s\u00e9nek \u00e9s a megold\u00e1s bead\u00e1s\u00e1nak l\u00e9p\u00e9sei a k\u00f6vetkez\u0151k: Az elindul\u00e1ssal ne v\u00e1rd meg a hat\u00e1rid\u0151 k\u00f6zeledt\u00e9t, legal\u00e1bb a saj\u00e1t rep\u00f3 l\u00e9trehoz\u00e1s\u00e1ig juss el miel\u0151bb. \u00cdgy, ha b\u00e1rmi elakad\u00e1s lenne, m\u00e9g id\u0151ben tudunk seg\u00edteni. Regisztr\u00e1lj egy GitHub accountot ( https://github.com/ ), ha m\u00e9g nem regisztr\u00e1lt\u00e1l \u00e9s l\u00e9pj be vele GitHub-ra. A feladathoz tartoz\u00f3 linket nyisd meg. Ez minden feladathoz m\u00e1s lesz, a t\u00e1rgy AUT honlapj\u00e1n ker\u00fclnek meghirdet\u00e9sre fokozatosan a f\u00e9l\u00e9v folyam\u00e1n. A form\u00e1tuma a k\u00f6vetkez\u0151h\u00f6z hasonl\u00f3: https://classroom.github.com/abcdefgh . Ha a hivatkoz\u00e1sra kattintva hib\u00e1t kapsz (\"There was a problem authenticating with GitHub, please try again.\"), copy-paste-tel m\u00e1sold be k\u00f6zvetlen\u00fcl a b\u00f6ng\u00e9sz\u0151 c\u00edmsor\u00e1ba a c\u00edmet. Ha k\u00e9ri, adj enged\u00e9lyt a GitHub Classroom alkalmaz\u00e1snak, hogy haszn\u00e1lja az account adataidat. L\u00e1tni fogsz egy oldalt, ahol elfogadhatod a feladatot (\"Accept this assignment\"). Kattints a gombra. V\u00e1rd meg, am\u00edg elk\u00e9sz\u00fcl a repository. A GitHub nem mindig friss\u00edti az oldalt mag\u00e1t\u00f3l, c\u00e9lszer\u0171 az oldal id\u0151nk\u00e9nti k\u00e9zi friss\u00edt\u00e9s\u00e9vel pr\u00f3b\u00e1lkozni (pl. F5 billenty\u0171). Ha elk\u00e9sz\u00fclt a repository, az oldal ki\u00edrja az \u00faj repository url-j\u00e9t, amin kattintva a repository-ra lehet navig\u00e1lni (ehhez hasonl\u00f3: https://github.com/bmeviauab00/hazi1-2023-username ). De nem is felt\u00e9tlen sz\u00fcks\u00e9ges az url elment\u00e9se, a GitHub nyit\u00f3oldal\u00e1n ( https://github.com/ ) baloldalt a saj\u00e1t repository-k k\u00f6zt b\u00e1rmikor meg lehet k\u00e9s\u0151bb is tal\u00e1lni. Kl\u00f3nozd le a repository-t (ennek mik\u00e9ntj\u00e9re r\u00f6videsen visszat\u00e9r\u00fcnk). Ebben tal\u00e1lni fogsz egy keretet, vagy kiindul\u00f3 k\u00f3dot. Ezen dolgozz, ezt v\u00e1ltoztasd. A kiindul\u00f3 projektben van egy .github/workflows mappa, ennek tartalm\u00e1t tilos megv\u00e1ltoztatni, t\u00f6r\u00f6lni stb. A munka sor\u00e1n a kiindul\u00e1si rep\u00f3ban lev\u0151 solutionben/projektben kell dolgozni, \u00faj projektet/solutiont ne hozz l\u00e9tre. A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s. Oldd meg a feladatot. Pushold a hat\u00e1rid\u0151ig. Ak\u00e1rh\u00e1ny commitod lehet, a legutols\u00f3 \u00e1llapotot fogjuk n\u00e9zni. Az eredm\u00e9nyt a t\u00e1rgy tansz\u00e9ki port\u00e1lj\u00e1n fogjuk meghirdetni a kapcsol\u00f3d\u00f3 sz\u00e1monk\u00e9r\u00e9s alatt az adott feladatra vonatkoz\u00f3 hat\u00e1rid\u0151t k\u00f6vet\u0151 p\u00e1r napon bel\u00fcl. A h\u00e1zi feladatot k\u00fcl\u00f6n explicit beadni nem kell, csak legyen fent GitHub-on hat\u00e1rid\u0151re a megold\u00e1s. Amikor a h\u00e1zi feladatod beadottnak tekinted, c\u00e9lszer\u0171 ellen\u0151rizni a b\u00f6ng\u00e9sz\u0151ben a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st push-olt\u00e1l-e, \u00e9s hogy a neptun.txt val\u00f3ban ki van-e t\u00f6ltve. A fenti l\u00e9p\u00e9sek kapcs\u00e1n k\u00e9t k\u00e9rd\u00e9s fogalmaz\u00f3dat meg benn\u00fcnk: Hogyan kl\u00f3nozzuk (clone) a rep\u00f3nkat (mely a h\u00e1zi feladat kiindul\u00f3 keret\u00e9t tartalmazza)? Hogyan commit-\u00e1ljunk \u00e9s push-oljunk a Visual Studio seg\u00edts\u00e9g\u00e9vel GitHub-ra? Az al\u00e1bbiakban ezekre is kit\u00e9r\u00fcnk. GitHub repository kl\u00f3noz\u00e1sa \u00b6 K\u00e9t lehet\u0151s\u00e9get n\u00e9z\u00fcnk meg al\u00e1bb: Clone a GitHub webes fel\u00fclet\u00e9r\u0151l indulva Visual Studioban Clone parancssorb\u00f3l Clone a GitHub webes fel\u00fclet\u00e9r\u0151l indulva Visual Studio-ban \u00b6 Egy (h\u00e1zi feladathoz tartoz\u00f3) repository kl\u00f3noz\u00e1sra sz\u00e1mos m\u00f3d van, egy lehet\u0151s\u00e9g a k\u00f6vetkez\u0151. Nyissuk meg az elk\u00e9sz\u00fclt repository online oldal\u00e1t, melyre t\u00f6bb m\u00f3don eljuthatunk. Lehet\u0151s\u00e9gek pl.: A repo l\u00e9trehoz\u00e1sakor megjelenik a GitHub fel\u00fcleten az url, csak kattintani kell rajta. A GitHub nyit\u00f3oldalon ( https://github.com ) - ha be vagyunk l\u00e9pve - list\u00e1z\u00f3dnak baloldalt azon repository-k, melyekhez van hozz\u00e1f\u00e9r\u00e9s\u00fcnk, csak kattintsunk a megfelel\u0151n. Amikor elk\u00e9sz\u00fcl a rep\u00f3nk (a GitHub classroom feladat elfogad\u00e1sa sor\u00e1n), e-mail \u00e9rtes\u00edt\u00e9st is kapunk r\u00f3la, ebben is megtal\u00e1lhat\u00f3 a link. Az oldal k\u00e9pe nagyj\u00e1b\u00f3l megfelel a k\u00f6vetkez\u0151nek (az mindenk\u00e9ppen k\u00fcl\u00f6nbs\u00e9g, hogy a rep\u00f3 url v\u00e9g\u00e9n mindenkin\u00e9l a saj\u00e1t felhaszn\u00e1l\u00f3neve szerepel): Kattintsunk a z\u00f6ld sz\u00edn\u0171 Code gombon, majd a leny\u00edl\u00f3 men\u00fcben az \"Open in Visual Studio\" linkre: A b\u00f6ng\u00e9sz\u0151nk ekkor j\u00f3 es\u00e9llyel feldob egy ablakot (pl. a Chrome/Edge eset\u00e9ben a c\u00edmsor alatt) melyben egy k\u00fcl\u00f6n gombkattint\u00e1ssal ( Open\u2026 ) tudjuk ind\u00edtani a Visual Studio-t. A felk\u00edn\u00e1lt lehet\u0151s\u00e9gnek lehet, kiss\u00e9 fura a neve, ha \"Microsoft Visual Studio Web Protocol Handler Selector\" n\u00e9ven hivatkozik r\u00e1, v\u00e1lasszuk ki b\u00e1tran. Ha minden j\u00f3l megy, a Visual Studio elindul, \u00e9s indul\u00e1s ut\u00e1n feldob egy ablakot, melyben a \"Repository location\" ki is van t\u00f6ltve a repository-nk URL-j\u00e9vel. A Path alatt adjuk meg, hogy hova szeretn\u00e9nk a h\u00e1tt\u00e9rt\u00e1runkon clone-ozni, majd kattintsunk a Clone gombra: Megjegyz\u00e9s: ha nem m\u0171k\u00f6dik a b\u00f6ng\u00e9sz\u0151ablakban az \"Open in Visual Studio\" vagy \"Microsoft Visual Studio Web Protocol Handler Selector\" hivatkoz\u00e1s, akkor indulhatunk egyb\u0151l a Visual Studio-b\u00f3l is. Csak ind\u00edtsuk el a Visual Studio-t, \u00e9s a startup ablakban v\u00e1lasszuk jobboldalt a \"Clone Repository\" gombot (vagy a startup ablakot \u00e1tugorva v\u00e1lasszuk ki a \"Git/Clone Repository men\u00fct\" a VS f\u0151ablak\u00e1ban), melynek hat\u00e1s\u00e1ra a fenti ablak jelenik meg, a Repository URL-be pedig \u00edrjuk be a rep\u00f3nk URL-j\u00e9t. A Clone -ra kattintva n\u00e9h\u00e1ny m\u00e1sodperc alatt a repository a megadott c\u00e9lmapp\u00e1ba kl\u00f3noz\u00f3dik. Pl. Windows Explorer-ben meg tudjuk tekinteni a l\u00e9trehozott mapp\u00e1kat \u00e9s f\u00e1jlokat: Ebb\u0151l j\u00f3l l\u00e1that\u00f3, hogy egy Git repository nem m\u00e1s, mint mapp\u00e1k \u00e9s f\u00e1jlok gy\u0171jtem\u00e9nye, valamint egy a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 .git mappa, mely (n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel \u00e9lve) az egyes f\u00e1jlok verzi\u00f3t\u00f6rt\u00e9net\u00e9t tartalmazza. Az els\u0151 h\u00e1zi feladat kiv\u00e9telesen k\u00e9t f\u0151 r\u00e9szb\u0151l \u00e1ll, melyekhez elt\u00e9r\u0151 solution tartozik. Az els\u0151h\u00f6z a Feladat1 mapp\u00e1ban tal\u00e1lhat\u00f3 MusicApp.sln f\u00e1jlt, a m\u00e1sodikhoz a Feladat2-ben tal\u00e1lhat\u00f3 Shapes.sln-t kell megnyitni. A megnyit\u00e1st megtehetj\u00fck Explorerb\u0151l, az adott .sln f\u00e1jlon dupl\u00e1n kattintva. Ugyanakkor van erre m\u00e1s m\u00f3d is: amennyiben Visual Studio-ban a Git gy\u00f6k\u00e9rmapp\u00e1t nyitottuk meg (a Clone -t k\u00f6vet\u0151en is ez a helyzet \u00e1llt el\u0151) a Solution Explorer n\u00e9zet fejl\u00e9c\u00e9ben \"Switch View\" gombot lenyomva a Solution Explorer list\u00e1zza a Git gy\u00f6k\u00e9rmappa alatti solution-\u00f6ket, \u00e9s ezek b\u00e1rmelyik\u00e9n dupl\u00e1n kattintva az adott solution megny\u00edlik: Clone parancssorb\u00f3l \u00b6 Parancssorban navig\u00e1ljunk abba a mapp\u00e1ba, ahov\u00e1 a forr\u00e1sk\u00f3dot ki szeretn\u00e9nk clone-ozni, \u00e9s itt adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone <repo url> , ahol a <repo url> a repositorynk c\u00edme (pl. b\u00f6ng\u00e9sz\u0151 c\u00edms\u00e1vj\u00e1b\u00f3l bem\u00e1solva, ehhez hasonl\u00f3: https://github.com/bmeviauab00/hazi1-2022-bzolka ). Parancssori git Ne f\u00e9lj\u00fcnk a parancssori git-et haszn\u00e1lni, egy repository clone-oz\u00e1s\u00e1nak tulajdonk\u00e9ppen ez a legegyszer\u0171bb m\u00f3dja. Amennyiben a parancs futtat\u00e1sa sor\u00e1n azt tapasztaljuk, hogy a git parancsot nem ismeri fel a k\u00f6rnyezet, annak oka val\u00f3sz\u00edn\u0171leg az, hogy nem telep\u00edtett\u00fcnk m\u00e9g a parancssori gitet a g\u00e9p\u00fcnkre. Err\u0151l b\u0151vebben itt . Napi Git munka Visual Studio seg\u00edts\u00e9g\u00e9vel (commit, push) \u00b6 Miut\u00e1n lekl\u00f3noztuk az adott h\u00e1zi feladathoz tartoz\u00f3 GitHub repository-t a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre, \u00e9s ennek sor\u00e1n l\u00e9trej\u00f6tt a lok\u00e1lis Git repository-nk, a benne lev\u0151 .sln f\u00e1jlokat Visual Studioban megnyitva pont \u00fagy dolgozunk \u2013 vesz\u00fcnk fel \u00faj f\u00e1jlokat, m\u00f3dos\u00edtunk/t\u00f6rl\u00fcnk megl\u00e9v\u0151ket \u2013 mintha a f\u00e1jlok nem is tartozn\u00e1nak semmif\u00e9le Git rep\u00f3hoz. Ugyanakkor, legk\u00e9s\u0151bb a feladat bead\u00e1sakor a v\u00e1ltoztat\u00e1sainkat commit-olni kell, majd push-olni GitHub-ra. A munka sor\u00e1n ak\u00e1rh\u00e1nyszor commit-\u00e1lhatjuk/push-olhatjuk az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt m\u00f3dos\u00edt\u00e1sainkat: a h\u00e1zi feladat ellen\u0151rz\u00e9sekor a hat\u00e1rid\u0151 pillanat\u00e1ban a GitHub-on tal\u00e1lhat\u00f3 \u00e1llapot ker\u00fcl elb\u00edr\u00e1l\u00e1sra, teljesen mindegy, h\u00e1ny commit tartozik hozz\u00e1. A commit \u00e9s push m\u0171veletek v\u00e9grehajt\u00e1s\u00e1hoz a Visual Studio \"Git\" men\u00fcj\u00e9ben lev\u0151 parancsokat haszn\u00e1ljuk. Commit \u00b6 Az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt v\u00e1ltoztat\u00e1sok megtekint\u00e9s\u00e9hez v\u00e1lasszuk ki a \"View\\Git Changes\" men\u00fct. Ennek hat\u00e1s\u00e1ra megjelenik a \"Git Changes\" n\u00e9zet a v\u00e1ltoz\u00e1sok list\u00e1j\u00e1val: A v\u00e1ltoztat\u00e1sok commit-\u00e1l\u00e1s\u00e1hoz \u00edrjunk a fenti sz\u00f6vegmez\u0151be egy a v\u00e1ltoztat\u00e1sokra jellemz\u0151 egy-k\u00e9t soros le\u00edr\u00e1st (pl. \"V\u00e9gs\u0151 megold\u00e1s\", \"Az xyz hiba jav\u00edt\u00e1sa\", stb.). A lehet\u0151s\u00e9geink ezt k\u00f6vet\u0151en a k\u00f6vetkez\u0151k: \"Commit All\" gomb: Csak helyben commit-olja a v\u00e1ltoztat\u00e1sokat (a k\u00f6zponti Git rep\u00f3ban mindaddig nem jelenik meg a commit, am\u00edg egy k\u00fcl\u00f6n Push paranccsal fel nem \"toljuk\". \"Commit All and Push\" , mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit, majd ut\u00e1na push. Ha a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lni is szeretn\u00e9nk a GitHub-on lev\u0151 k\u00f6zponti rep\u00f3ba, akkor haszn\u00e1ljuk b\u00e1tran parancsot. A h\u00e1zi feladatok tekintet\u00e9ben c\u00e9lszer\u0171 is ezt haszn\u00e1lni, mert ekkor nincs sz\u00fcks\u00e9g a commit-ot k\u00f6vet\u0151en k\u00fcl\u00f6n push m\u0171veletre. Megjegyz\u00e9s: ha a parancs az \"Unable to push to the remote repository because your local branch is behind the remote branch\" hib\u00e1val z\u00e1rul, el\u0151bb pull-oljuk, majd ism\u00e9telj\u00fck meg a push-t. Erre m\u00e9g al\u00e1bb visszat\u00e9r\u00fcnk. \"Commit All and Sync\" , mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit ut\u00e1n pull (leszedi a saj\u00e1t helyi rep\u00f3nkba m\u00e1sok esetleges v\u00e1ltoztat\u00e1sait a k\u00f6zponti rep\u00f3b\u00f3l), majd push. \u00cdgy a k\u00f6zponti rep\u00f3ban lev\u0151 esetleges v\u00e1ltoz\u00e1sokat lehozza a helyi rep\u00f3nkba, az ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lja is ide. Note A git commit-ot mindig meg kell el\u0151zze egy \u00fan. stage l\u00e9p\u00e9s, mely sor\u00e1n kiv\u00e1lasztjuk azokat a helyi v\u00e1ltoztat\u00e1sokat, melyeket a k\u00f6vetkez\u0151 commit-ba be k\u00edv\u00e1nunk tenni. Ez az \u00fan. staging area ter\u00fcletre teszi az \u00e1ltalunk kiv\u00e1lasztott v\u00e1ltoz\u00e1sokat (a f\u00e9jlrendszerben nem mozgat semmif\u00e9le f\u00e1jlt, ez csak a git a bels\u0151 nyilv\u00e1ntart\u00e1s\u00e1ban jelenik meg). Ez az\u00e9rt j\u00f3, mert plusz rugalmass\u00e1got biztos\u00edt, hiszen nem biztos, mindig minden v\u00e1ltoztat\u00e1st bele k\u00edv\u00e1nunk tenni a k\u00f6vetkez\u0151 commit-ba. A fenti \"Commit all\" stb. parancsok nev\u00e9ben nem v\u00e9letlen van benne az \"all\": ezek a sz\u00ednfalak m\u00f6g\u00f6tt a commit el\u0151tt egy megfelel\u0151 git paranccsal valamennyi v\u00e1ltoz\u00e1st a git staging area-ra tesznek, \u00edgy ezt nek\u00fcnk nem kell k\u00fcl\u00f6n megtenn\u00fcnk. Push, Pull, Git history \u00b6 A commit m\u0171velet csak a helyi repository-ban \"\u00e9rv\u00e9nyes\u00edti\" a v\u00e1ltoztat\u00e1sokat. Ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sokat a GitHub k\u00f6zponti repository-nkba fel kell t\u00f6lteni a push m\u0171velettel. Erre a l\u00e9p\u00e9sre csak akkor van sz\u00fcks\u00e9g, ha a commit sor\u00e1n nem haszn\u00e1ltuk a \"Commit All and Push\" vagy \"Commit All and Sync\" parancsokat. A push m\u0171velet VS-ben a \"Git/Push\" men\u00fc seg\u00edt\u00e9s\u00e9vel ind\u00edthat\u00f3. Ha t\u00f6bben dolgozunk, a k\u00f6zponti repository-ban lehetnek m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok (vagy ak\u00e1r olyanok, melyeket mi magunk push-oltunk egy m\u00e1sik lok\u00e1lis clone-b\u00f3l, vagy ha a GitHub online fel\u00fclet\u00e9n eszk\u00f6z\u00f6lt\u00fcnk a k\u00f3don v\u00e1ltoz\u00e1sokat). Ezeket a pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni (Git/Pull men\u00fc). A h\u00e1zi feladat vonatkoz\u00e1s\u00e1ban ezt nem haszn\u00e1ljuk, hiszen mindenki saj\u00e1t dedik\u00e1lt k\u00f6zponti repositoryval rendelkezik, melyben egyed\u00fcl dolgozik (kiv\u00e9ve, ha esetleg valaki a GitHub fel\u00fclet\u00e9nek seg\u00edts\u00e9g\u00e9vel v\u00e1ltoztatott a k\u00f3don, akkor ezt egy pull-lal tudja a helyi rep\u00f3j\u00e1ba lehozni). Note A push csak akkor hajthat\u00f3 v\u00e9gre, ha a k\u00f6zponti rep\u00f3ban nincs olyan v\u00e1ltoz\u00e1s, melyet m\u00e9g a pull paranccsal nem hoztunk le \u00e9s merge-elt\u00fcnk a saj\u00e1t lok\u00e1lis rep\u00f3nkba. Ha ez nincs \u00edgy, egy ehhez hasonl\u00f3 hiba\u00fczenet kapunk: \"Unable to push to the remote repository because your local branch is behind the remote branch\". Ekkor pull-oljunk, ut\u00e1na ism\u00e9telj\u00fck meg a pusht. Note A pull m\u0171velet csak akkor hajthat\u00f3 v\u00e9gre, ha nincs olyan v\u00e1ltoztat\u00e1sunk helyben, melyeket m\u00e9g nem commit\u00e1ltunk. Ha van ilyen, akkor azokat vagy commit\u00e1ljuk, vagy ha ezt nem akarjuk megtenni m\u00e9g, akkor stash-elj\u00fck a pull idej\u00e9re. Tip A Pull \u00e9s Push parancsok a \u201eGit Changes\u201d (View/Git Changes men\u00fc jelen\u00edti meg) n\u00e9zet tetej\u00e9n el\u00e9rhet\u0151 le \u00e9s fel nyilakkal is el\u00e9rhet\u0151k: Commit el\u0151tt pull A amennyiben a j\u00f6v\u0151ben egy Git repository-n t\u00f6bben dolgozunk, a v\u00e1ltoztat\u00e1saink commitol\u00e1sa el\u0151tt c\u00e9lszer\u0171 kiadni egy Pull parancsot (Git/Pull men\u00fc). Ez lehozza a k\u00f6zponti Git repositoryb\u00f3l a t\u00f6bbi fejleszt\u0151 v\u00e1ltoztat\u00e1sait \u00e9s \u00f6sszemerge-eli a saj\u00e1t v\u00e1ltoztat\u00e1sainkkal (a helyi rep\u00f3nkban). \u00cdgy, ha valaki net\u00e1n pont azokon a f\u00e1jlokon dolgozott az el\u0151z\u0151 pullunk \u00f3ta, melyeken mi is v\u00e1ltoztattunk, ezek hat\u00e1sa megjelenik a k\u00f3dunkban, az esetleges \u00fctk\u00f6z\u00e9seket m\u00e1r idejekor\u00e1n fel tudjuk oldani, \u00e9s a tiszt\u00e1zott, minden v\u00e1ltoz\u00e1st egyben \u00e9s konzisztensen tartalmaz\u00f3 k\u00f3dot tudjuk commitolni. Git history \u00b6 A Git egy v\u00e1ltoz\u00e1sk\u00f6vet\u0151 rendszer. A v\u00e1ltoz\u00e1s egys\u00e9ge a commit (melyben testsz\u0151leges sz\u00e1m\u00fa f\u00e1jlt \u00e9rint\u0151 v\u00e1ltoz\u00e1s lehet), a Git historyban a commitok egym\u00e1sut\u00e1nis\u00e1g\u00e1t l\u00e1thatjuk. Minden f\u00e1jlokat \u00e9rint\u0151 v\u00e1ltoz\u00e1sokon t\u00falmen\u0151en minden commithoz tartozik egy egyedi azonos\u00edt\u00f3 (commit hash), id\u0151b\u00e9lyeg, illetve egy szerz\u0151 (a felhaszn\u00e1l\u00f3, aki a v\u00e1ltoz\u00e1sokat commitolta). Visual Studioban a historyt a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni, de a history term\u00e9szetesen a GitHubon is megjelen\u00edthet\u0151. A Visual Studioban a \"Git Repository\" n\u00e9zetet a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni. Outgoing commits: Megmutatja, hogy milyen a lok\u00e1lis repository-nkba m\u00e1r l\u00e9tez\u0151, de a k\u00f6zponti rep\u00f3ba m\u00e9g nem push-olt commitok vannak. Ezeket a Push m\u0171velettel tudjuk felt\u00f6lteni. Incoming commits: Megmutatja, hogy a k\u00f6zponti repository-ban milyen m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok vannak. Ezek akkor jelennek meg, ha a Fetch paranccsal lehozzuk a helyi rep\u00f3ba (ez m\u00e9g nem merge-el). Ezeket a Pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni. A fetch parancsot ritk\u00e1n haszn\u00e1ljuk: \u00e1ltal\u00e1ban a pullt haszn\u00e1ljuk mag\u00e1ban, ami egy fecth + merge (v\u00e1ltoz\u00e1sok merge-el\u00e9se a helyi rep\u00f3ba) kombin\u00e1ci\u00f3ja. P\u00e9lda: Tip Am\u00edg nem vagyunk rutinosak a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00fcnk-e. Egy\u00e9b ir\u00e1nyelvek \u00b6 A Git commit \u00e9s push sor\u00e1n megfigyelhetj\u00fck, hogy a solution-jeink k\u00f6ztes \u00e9s kimeneti \u00e1llom\u00e1nyai (.dll, .exe, stb. f\u00e1jlok) nem ker\u00fclnek bele a commitba \u00e9s \u00edgy nem ker\u00fclnek fel GitHubra sem. Ez \u00edgy is van j\u00f3l, ezen \u00e1llom\u00e1nyok b\u00e1rmikor reproduk\u00e1lhat\u00f3k, a verzi\u00f3kezel\u0151 rendszernek nem feladata ezek t\u00e1rol\u00e1sa, csak felesleges \u00e9s zavar\u00f3 helyfoglal\u00f3k lenn\u00e9nek. Felmer\u00fcl a k\u00e9rd\u00e9s, honnan tudja a Git, hogy mely \u00e1llom\u00e1nyokat sz\u00fcks\u00e9ges figyelmen k\u00edv\u00fcl hagyni a commit sor\u00e1n. Erre szolg\u00e1l a repository-ban (tipikusan annak gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban) tal\u00e1lhat\u00f3 .gitignore f\u00e1jl, mely felsorolja azon mapp\u00e1kat, f\u00e1jlkiterjeszt\u00e9seket, illetve egyedi f\u00e1jlokat, melyeket a commit sor\u00e1n figyelmen k\u00edv\u00fcl szeretn\u00e9nk hagyni. A .gitignore f\u00e1jl tartalma teljes eg\u00e9sz\u00e9ben a kez\u00fcnk al\u00e1 tartozik, szabadon szerkeszthet\u0151/commit\u00e1lhat\u00f3/pusholhat\u00f3. A t\u00e1rgy keret\u00e9ben minden kiindul\u00f3 rep\u00f3nak r\u00e9sze egy .gitignore f\u00e1jl, ne v\u00e1ltoztassuk a tartalm\u00e1t! \u00cdgy a commit/push sor\u00e1n a kimeneti \u00e1llom\u00e1nyok a h\u00e1zi feladatok eset\u00e9ben sem ker\u00fclnek fel GitHub-ra, \u00e9s egy \u00edgy is van rendj\u00e9n. A f\u00e9l\u00e9vben a feladatok megold\u00e1sa sor\u00e1n az egyes oszt\u00e1lyok, interf\u00e9szek, stb. forr\u00e1sk\u00f3dj\u00e1t k\u00fcl\u00f6n f\u00e1jlba kell tenni, vagyis egy C# forr\u00e1sf\u00e1jlban egy oszt\u00e1ly/interf\u00e9sz/stb. defin\u00edci\u00f3ja legyen. Git haszn\u00e1lata parancssorb\u00f3l \u00b6 B\u00e1r sokan \u00f3dzkodnak a git parancssori alkalmaz\u00e1s\u00e1t\u00f3l, az egyszer\u0171bb m\u0171veleteket gyakran gyorsabban v\u00e9gre tudjuk hajtani parancssorb\u00f3l, mint a fel\u00fcleteken t\u00f6rt\u00e9n\u0151 kattintgat\u00e1sokkal. Az al\u00e1bbiakban egy egyszer\u0171 l\u00e9p\u00e9ssorozattal illusztr\u00e1ljuk ezt. Ezeket a t\u00e1rgy keret\u00e9ben nem kell tudni, de hosszabb t\u00e1von mindenk\u00e9ppen hasznos (\u00e9s az ipar\u00e1gban elv\u00e1r\u00e1s is) az ismeret\u00fck. Repository clone (ezt csak egyszer) git clone https://github.com/bmeviauab00/hazi1-2022-bzolka V\u00e1ltoztat\u00e1sok v\u00e9grehajt\u00e1sa a helyi rep\u00f3ban (f\u00e1jlrendszerben, fejleszt\u0151eszk\u00f6zben). V\u00e1ltoztat\u00e1sok megtekint\u00e9se, mutatja melyek az \u00faj/t\u00f6r\u00f6lt/m\u00f3dosult f\u00e1jlok (nem k\u00f6telez\u0151, csak ha k\u00edv\u00e1ncsiak vagyunk r\u00e1)* git status Minden v\u00e1ltoztat\u00e1s felt\u00e9tele a staging area-ra git add -A Ha ezt k\u00f6vet\u0151en ism\u00e9t kiadjuk git status parancsot (nem k\u00f6telez\u0151), l\u00e1tjuk, hogy minden v\u00e1ltoz\u00e1s stage-elve van. Commit git commit -m \"megjegyz\u00e9s a commithoz\" Push git push Megjegyz\u00e9sek: Ha t\u00f6bben is dolgozunk az adott git \u00e1gon, akkor 3. l\u00e9p\u00e9s el\u0151tt, de legk\u00e9s\u0151bb a 6. push el\u0151tt sz\u00fcks\u00e9g lehet/van egy git pull -ra, hogy m\u00e1sok v\u00e1ltoztat\u00e1sai jelenjenek meg a mi helyi rep\u00f3nkban (en\u00e9lk\u00fcl nem fogunk tudni push-olni). A pull-nak c\u00e9lszer\u0171 lehet megadni egy --rebase opci\u00f3t is, hogy ne sz\u00fclessen a merge-hez egy plusz merge commit, ennek magyar\u00e1zat\u00e1ra itt nem t\u00e9r\u00fcnk ki. Mint kor\u00e1bban eml\u00edtett\u00fck, a commit sor\u00e1n az commithoz hozz\u00e1rendel\u0151dik egy felhaszn\u00e1l\u00f3n\u00e9v \u00e9s e-mail c\u00edm. Ha ezek nincsenek a git sz\u00e1m\u00e1ra bekonfigur\u00e1lva, akkor a git a commit sor\u00e1n ezt hiba\u00fczenetben jelzi. Ekkor az al\u00e1bbi parancsokkal - \u00e9rtelemszer\u0171en a saj\u00e1t usernev\u00fcnket \u00e9s e-mail c\u00edm\u00fcnket megadva - tudjuk ezeket a git glob\u00e1lis konfigur\u00e1ci\u00f3j\u00e1ban be\u00e1ll\u00edtani (ezt csak egyszer kell megtenni): git config --global user.email \"you@example.com\" git config --global user.name \"myusername\" Windows parancssorban \u00f6sszevonhatunk t\u00f6bb parancsot is egy sorba, pl. egy l\u00e9p\u00e9sben stage/commit/push: git add -A & git commit -m \"All tests run\" & git push Powershell haszn\u00e1latakor a & helyett ; -t kell szepar\u00e1tork\u00e9nt haszn\u00e1lni.","title":"A kiindul\u00f3 alkalmaz\u00e1skeret let\u00f6lt\u00e9s\u00e9nek \u00e9s a feladat bead\u00e1s\u00e1nak l\u00e9p\u00e9sei"},{"location":"hazi/hf-folyamat/#a-kiindulo-alkalmazaskeret-letoltesenek-es-a-feladat-beadasanak-lepesei","text":"","title":"A kiindul\u00f3 alkalmaz\u00e1skeret let\u00f6lt\u00e9s\u00e9nek \u00e9s a feladat bead\u00e1s\u00e1nak l\u00e9p\u00e9sei"},{"location":"hazi/hf-folyamat/#lepesek","text":"Az egyes h\u00e1zi feladatok kiindul\u00f3 keret\u00e9t GitHub seg\u00edts\u00e9g\u00e9vel publik\u00e1ljuk (a tov\u00e1bbi h\u00e1zi feladatok vonatkoz\u00e1s\u00e1ban k\u00e9s\u0151bb hozunk d\u00f6nt\u00e9st). A GitHub-on publik\u00e1lt h\u00e1zi feladatok kiindul\u00f3 k\u00f6rnyezet let\u00f6lt\u00e9s\u00e9nek \u00e9s a megold\u00e1s bead\u00e1s\u00e1nak l\u00e9p\u00e9sei a k\u00f6vetkez\u0151k: Az elindul\u00e1ssal ne v\u00e1rd meg a hat\u00e1rid\u0151 k\u00f6zeledt\u00e9t, legal\u00e1bb a saj\u00e1t rep\u00f3 l\u00e9trehoz\u00e1s\u00e1ig juss el miel\u0151bb. \u00cdgy, ha b\u00e1rmi elakad\u00e1s lenne, m\u00e9g id\u0151ben tudunk seg\u00edteni. Regisztr\u00e1lj egy GitHub accountot ( https://github.com/ ), ha m\u00e9g nem regisztr\u00e1lt\u00e1l \u00e9s l\u00e9pj be vele GitHub-ra. A feladathoz tartoz\u00f3 linket nyisd meg. Ez minden feladathoz m\u00e1s lesz, a t\u00e1rgy AUT honlapj\u00e1n ker\u00fclnek meghirdet\u00e9sre fokozatosan a f\u00e9l\u00e9v folyam\u00e1n. A form\u00e1tuma a k\u00f6vetkez\u0151h\u00f6z hasonl\u00f3: https://classroom.github.com/abcdefgh . Ha a hivatkoz\u00e1sra kattintva hib\u00e1t kapsz (\"There was a problem authenticating with GitHub, please try again.\"), copy-paste-tel m\u00e1sold be k\u00f6zvetlen\u00fcl a b\u00f6ng\u00e9sz\u0151 c\u00edmsor\u00e1ba a c\u00edmet. Ha k\u00e9ri, adj enged\u00e9lyt a GitHub Classroom alkalmaz\u00e1snak, hogy haszn\u00e1lja az account adataidat. L\u00e1tni fogsz egy oldalt, ahol elfogadhatod a feladatot (\"Accept this assignment\"). Kattints a gombra. V\u00e1rd meg, am\u00edg elk\u00e9sz\u00fcl a repository. A GitHub nem mindig friss\u00edti az oldalt mag\u00e1t\u00f3l, c\u00e9lszer\u0171 az oldal id\u0151nk\u00e9nti k\u00e9zi friss\u00edt\u00e9s\u00e9vel pr\u00f3b\u00e1lkozni (pl. F5 billenty\u0171). Ha elk\u00e9sz\u00fclt a repository, az oldal ki\u00edrja az \u00faj repository url-j\u00e9t, amin kattintva a repository-ra lehet navig\u00e1lni (ehhez hasonl\u00f3: https://github.com/bmeviauab00/hazi1-2023-username ). De nem is felt\u00e9tlen sz\u00fcks\u00e9ges az url elment\u00e9se, a GitHub nyit\u00f3oldal\u00e1n ( https://github.com/ ) baloldalt a saj\u00e1t repository-k k\u00f6zt b\u00e1rmikor meg lehet k\u00e9s\u0151bb is tal\u00e1lni. Kl\u00f3nozd le a repository-t (ennek mik\u00e9ntj\u00e9re r\u00f6videsen visszat\u00e9r\u00fcnk). Ebben tal\u00e1lni fogsz egy keretet, vagy kiindul\u00f3 k\u00f3dot. Ezen dolgozz, ezt v\u00e1ltoztasd. A kiindul\u00f3 projektben van egy .github/workflows mappa, ennek tartalm\u00e1t tilos megv\u00e1ltoztatni, t\u00f6r\u00f6lni stb. A munka sor\u00e1n a kiindul\u00e1si rep\u00f3ban lev\u0151 solutionben/projektben kell dolgozni, \u00faj projektet/solutiont ne hozz l\u00e9tre. A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s. Oldd meg a feladatot. Pushold a hat\u00e1rid\u0151ig. Ak\u00e1rh\u00e1ny commitod lehet, a legutols\u00f3 \u00e1llapotot fogjuk n\u00e9zni. Az eredm\u00e9nyt a t\u00e1rgy tansz\u00e9ki port\u00e1lj\u00e1n fogjuk meghirdetni a kapcsol\u00f3d\u00f3 sz\u00e1monk\u00e9r\u00e9s alatt az adott feladatra vonatkoz\u00f3 hat\u00e1rid\u0151t k\u00f6vet\u0151 p\u00e1r napon bel\u00fcl. A h\u00e1zi feladatot k\u00fcl\u00f6n explicit beadni nem kell, csak legyen fent GitHub-on hat\u00e1rid\u0151re a megold\u00e1s. Amikor a h\u00e1zi feladatod beadottnak tekinted, c\u00e9lszer\u0171 ellen\u0151rizni a b\u00f6ng\u00e9sz\u0151ben a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st push-olt\u00e1l-e, \u00e9s hogy a neptun.txt val\u00f3ban ki van-e t\u00f6ltve. A fenti l\u00e9p\u00e9sek kapcs\u00e1n k\u00e9t k\u00e9rd\u00e9s fogalmaz\u00f3dat meg benn\u00fcnk: Hogyan kl\u00f3nozzuk (clone) a rep\u00f3nkat (mely a h\u00e1zi feladat kiindul\u00f3 keret\u00e9t tartalmazza)? Hogyan commit-\u00e1ljunk \u00e9s push-oljunk a Visual Studio seg\u00edts\u00e9g\u00e9vel GitHub-ra? Az al\u00e1bbiakban ezekre is kit\u00e9r\u00fcnk.","title":"L\u00e9p\u00e9sek"},{"location":"hazi/hf-folyamat/#github-repository-klonozasa","text":"K\u00e9t lehet\u0151s\u00e9get n\u00e9z\u00fcnk meg al\u00e1bb: Clone a GitHub webes fel\u00fclet\u00e9r\u0151l indulva Visual Studioban Clone parancssorb\u00f3l","title":"GitHub repository kl\u00f3noz\u00e1sa"},{"location":"hazi/hf-folyamat/#clone-a-github-webes-feluleterol-indulva-visual-studio-ban","text":"Egy (h\u00e1zi feladathoz tartoz\u00f3) repository kl\u00f3noz\u00e1sra sz\u00e1mos m\u00f3d van, egy lehet\u0151s\u00e9g a k\u00f6vetkez\u0151. Nyissuk meg az elk\u00e9sz\u00fclt repository online oldal\u00e1t, melyre t\u00f6bb m\u00f3don eljuthatunk. Lehet\u0151s\u00e9gek pl.: A repo l\u00e9trehoz\u00e1sakor megjelenik a GitHub fel\u00fcleten az url, csak kattintani kell rajta. A GitHub nyit\u00f3oldalon ( https://github.com ) - ha be vagyunk l\u00e9pve - list\u00e1z\u00f3dnak baloldalt azon repository-k, melyekhez van hozz\u00e1f\u00e9r\u00e9s\u00fcnk, csak kattintsunk a megfelel\u0151n. Amikor elk\u00e9sz\u00fcl a rep\u00f3nk (a GitHub classroom feladat elfogad\u00e1sa sor\u00e1n), e-mail \u00e9rtes\u00edt\u00e9st is kapunk r\u00f3la, ebben is megtal\u00e1lhat\u00f3 a link. Az oldal k\u00e9pe nagyj\u00e1b\u00f3l megfelel a k\u00f6vetkez\u0151nek (az mindenk\u00e9ppen k\u00fcl\u00f6nbs\u00e9g, hogy a rep\u00f3 url v\u00e9g\u00e9n mindenkin\u00e9l a saj\u00e1t felhaszn\u00e1l\u00f3neve szerepel): Kattintsunk a z\u00f6ld sz\u00edn\u0171 Code gombon, majd a leny\u00edl\u00f3 men\u00fcben az \"Open in Visual Studio\" linkre: A b\u00f6ng\u00e9sz\u0151nk ekkor j\u00f3 es\u00e9llyel feldob egy ablakot (pl. a Chrome/Edge eset\u00e9ben a c\u00edmsor alatt) melyben egy k\u00fcl\u00f6n gombkattint\u00e1ssal ( Open\u2026 ) tudjuk ind\u00edtani a Visual Studio-t. A felk\u00edn\u00e1lt lehet\u0151s\u00e9gnek lehet, kiss\u00e9 fura a neve, ha \"Microsoft Visual Studio Web Protocol Handler Selector\" n\u00e9ven hivatkozik r\u00e1, v\u00e1lasszuk ki b\u00e1tran. Ha minden j\u00f3l megy, a Visual Studio elindul, \u00e9s indul\u00e1s ut\u00e1n feldob egy ablakot, melyben a \"Repository location\" ki is van t\u00f6ltve a repository-nk URL-j\u00e9vel. A Path alatt adjuk meg, hogy hova szeretn\u00e9nk a h\u00e1tt\u00e9rt\u00e1runkon clone-ozni, majd kattintsunk a Clone gombra: Megjegyz\u00e9s: ha nem m\u0171k\u00f6dik a b\u00f6ng\u00e9sz\u0151ablakban az \"Open in Visual Studio\" vagy \"Microsoft Visual Studio Web Protocol Handler Selector\" hivatkoz\u00e1s, akkor indulhatunk egyb\u0151l a Visual Studio-b\u00f3l is. Csak ind\u00edtsuk el a Visual Studio-t, \u00e9s a startup ablakban v\u00e1lasszuk jobboldalt a \"Clone Repository\" gombot (vagy a startup ablakot \u00e1tugorva v\u00e1lasszuk ki a \"Git/Clone Repository men\u00fct\" a VS f\u0151ablak\u00e1ban), melynek hat\u00e1s\u00e1ra a fenti ablak jelenik meg, a Repository URL-be pedig \u00edrjuk be a rep\u00f3nk URL-j\u00e9t. A Clone -ra kattintva n\u00e9h\u00e1ny m\u00e1sodperc alatt a repository a megadott c\u00e9lmapp\u00e1ba kl\u00f3noz\u00f3dik. Pl. Windows Explorer-ben meg tudjuk tekinteni a l\u00e9trehozott mapp\u00e1kat \u00e9s f\u00e1jlokat: Ebb\u0151l j\u00f3l l\u00e1that\u00f3, hogy egy Git repository nem m\u00e1s, mint mapp\u00e1k \u00e9s f\u00e1jlok gy\u0171jtem\u00e9nye, valamint egy a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 .git mappa, mely (n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel \u00e9lve) az egyes f\u00e1jlok verzi\u00f3t\u00f6rt\u00e9net\u00e9t tartalmazza. Az els\u0151 h\u00e1zi feladat kiv\u00e9telesen k\u00e9t f\u0151 r\u00e9szb\u0151l \u00e1ll, melyekhez elt\u00e9r\u0151 solution tartozik. Az els\u0151h\u00f6z a Feladat1 mapp\u00e1ban tal\u00e1lhat\u00f3 MusicApp.sln f\u00e1jlt, a m\u00e1sodikhoz a Feladat2-ben tal\u00e1lhat\u00f3 Shapes.sln-t kell megnyitni. A megnyit\u00e1st megtehetj\u00fck Explorerb\u0151l, az adott .sln f\u00e1jlon dupl\u00e1n kattintva. Ugyanakkor van erre m\u00e1s m\u00f3d is: amennyiben Visual Studio-ban a Git gy\u00f6k\u00e9rmapp\u00e1t nyitottuk meg (a Clone -t k\u00f6vet\u0151en is ez a helyzet \u00e1llt el\u0151) a Solution Explorer n\u00e9zet fejl\u00e9c\u00e9ben \"Switch View\" gombot lenyomva a Solution Explorer list\u00e1zza a Git gy\u00f6k\u00e9rmappa alatti solution-\u00f6ket, \u00e9s ezek b\u00e1rmelyik\u00e9n dupl\u00e1n kattintva az adott solution megny\u00edlik:","title":"Clone a GitHub webes fel\u00fclet\u00e9r\u0151l indulva Visual Studio-ban"},{"location":"hazi/hf-folyamat/#clone-parancssorbol","text":"Parancssorban navig\u00e1ljunk abba a mapp\u00e1ba, ahov\u00e1 a forr\u00e1sk\u00f3dot ki szeretn\u00e9nk clone-ozni, \u00e9s itt adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone <repo url> , ahol a <repo url> a repositorynk c\u00edme (pl. b\u00f6ng\u00e9sz\u0151 c\u00edms\u00e1vj\u00e1b\u00f3l bem\u00e1solva, ehhez hasonl\u00f3: https://github.com/bmeviauab00/hazi1-2022-bzolka ). Parancssori git Ne f\u00e9lj\u00fcnk a parancssori git-et haszn\u00e1lni, egy repository clone-oz\u00e1s\u00e1nak tulajdonk\u00e9ppen ez a legegyszer\u0171bb m\u00f3dja. Amennyiben a parancs futtat\u00e1sa sor\u00e1n azt tapasztaljuk, hogy a git parancsot nem ismeri fel a k\u00f6rnyezet, annak oka val\u00f3sz\u00edn\u0171leg az, hogy nem telep\u00edtett\u00fcnk m\u00e9g a parancssori gitet a g\u00e9p\u00fcnkre. Err\u0151l b\u0151vebben itt .","title":"Clone parancssorb\u00f3l"},{"location":"hazi/hf-folyamat/#napi-git-munka-visual-studio-segitsegevel-commit-push","text":"Miut\u00e1n lekl\u00f3noztuk az adott h\u00e1zi feladathoz tartoz\u00f3 GitHub repository-t a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre, \u00e9s ennek sor\u00e1n l\u00e9trej\u00f6tt a lok\u00e1lis Git repository-nk, a benne lev\u0151 .sln f\u00e1jlokat Visual Studioban megnyitva pont \u00fagy dolgozunk \u2013 vesz\u00fcnk fel \u00faj f\u00e1jlokat, m\u00f3dos\u00edtunk/t\u00f6rl\u00fcnk megl\u00e9v\u0151ket \u2013 mintha a f\u00e1jlok nem is tartozn\u00e1nak semmif\u00e9le Git rep\u00f3hoz. Ugyanakkor, legk\u00e9s\u0151bb a feladat bead\u00e1sakor a v\u00e1ltoztat\u00e1sainkat commit-olni kell, majd push-olni GitHub-ra. A munka sor\u00e1n ak\u00e1rh\u00e1nyszor commit-\u00e1lhatjuk/push-olhatjuk az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt m\u00f3dos\u00edt\u00e1sainkat: a h\u00e1zi feladat ellen\u0151rz\u00e9sekor a hat\u00e1rid\u0151 pillanat\u00e1ban a GitHub-on tal\u00e1lhat\u00f3 \u00e1llapot ker\u00fcl elb\u00edr\u00e1l\u00e1sra, teljesen mindegy, h\u00e1ny commit tartozik hozz\u00e1. A commit \u00e9s push m\u0171veletek v\u00e9grehajt\u00e1s\u00e1hoz a Visual Studio \"Git\" men\u00fcj\u00e9ben lev\u0151 parancsokat haszn\u00e1ljuk.","title":"Napi Git munka Visual Studio seg\u00edts\u00e9g\u00e9vel (commit, push)"},{"location":"hazi/hf-folyamat/#commit","text":"Az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt v\u00e1ltoztat\u00e1sok megtekint\u00e9s\u00e9hez v\u00e1lasszuk ki a \"View\\Git Changes\" men\u00fct. Ennek hat\u00e1s\u00e1ra megjelenik a \"Git Changes\" n\u00e9zet a v\u00e1ltoz\u00e1sok list\u00e1j\u00e1val: A v\u00e1ltoztat\u00e1sok commit-\u00e1l\u00e1s\u00e1hoz \u00edrjunk a fenti sz\u00f6vegmez\u0151be egy a v\u00e1ltoztat\u00e1sokra jellemz\u0151 egy-k\u00e9t soros le\u00edr\u00e1st (pl. \"V\u00e9gs\u0151 megold\u00e1s\", \"Az xyz hiba jav\u00edt\u00e1sa\", stb.). A lehet\u0151s\u00e9geink ezt k\u00f6vet\u0151en a k\u00f6vetkez\u0151k: \"Commit All\" gomb: Csak helyben commit-olja a v\u00e1ltoztat\u00e1sokat (a k\u00f6zponti Git rep\u00f3ban mindaddig nem jelenik meg a commit, am\u00edg egy k\u00fcl\u00f6n Push paranccsal fel nem \"toljuk\". \"Commit All and Push\" , mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit, majd ut\u00e1na push. Ha a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lni is szeretn\u00e9nk a GitHub-on lev\u0151 k\u00f6zponti rep\u00f3ba, akkor haszn\u00e1ljuk b\u00e1tran parancsot. A h\u00e1zi feladatok tekintet\u00e9ben c\u00e9lszer\u0171 is ezt haszn\u00e1lni, mert ekkor nincs sz\u00fcks\u00e9g a commit-ot k\u00f6vet\u0151en k\u00fcl\u00f6n push m\u0171veletre. Megjegyz\u00e9s: ha a parancs az \"Unable to push to the remote repository because your local branch is behind the remote branch\" hib\u00e1val z\u00e1rul, el\u0151bb pull-oljuk, majd ism\u00e9telj\u00fck meg a push-t. Erre m\u00e9g al\u00e1bb visszat\u00e9r\u00fcnk. \"Commit All and Sync\" , mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit ut\u00e1n pull (leszedi a saj\u00e1t helyi rep\u00f3nkba m\u00e1sok esetleges v\u00e1ltoztat\u00e1sait a k\u00f6zponti rep\u00f3b\u00f3l), majd push. \u00cdgy a k\u00f6zponti rep\u00f3ban lev\u0151 esetleges v\u00e1ltoz\u00e1sokat lehozza a helyi rep\u00f3nkba, az ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lja is ide. Note A git commit-ot mindig meg kell el\u0151zze egy \u00fan. stage l\u00e9p\u00e9s, mely sor\u00e1n kiv\u00e1lasztjuk azokat a helyi v\u00e1ltoztat\u00e1sokat, melyeket a k\u00f6vetkez\u0151 commit-ba be k\u00edv\u00e1nunk tenni. Ez az \u00fan. staging area ter\u00fcletre teszi az \u00e1ltalunk kiv\u00e1lasztott v\u00e1ltoz\u00e1sokat (a f\u00e9jlrendszerben nem mozgat semmif\u00e9le f\u00e1jlt, ez csak a git a bels\u0151 nyilv\u00e1ntart\u00e1s\u00e1ban jelenik meg). Ez az\u00e9rt j\u00f3, mert plusz rugalmass\u00e1got biztos\u00edt, hiszen nem biztos, mindig minden v\u00e1ltoztat\u00e1st bele k\u00edv\u00e1nunk tenni a k\u00f6vetkez\u0151 commit-ba. A fenti \"Commit all\" stb. parancsok nev\u00e9ben nem v\u00e9letlen van benne az \"all\": ezek a sz\u00ednfalak m\u00f6g\u00f6tt a commit el\u0151tt egy megfelel\u0151 git paranccsal valamennyi v\u00e1ltoz\u00e1st a git staging area-ra tesznek, \u00edgy ezt nek\u00fcnk nem kell k\u00fcl\u00f6n megtenn\u00fcnk.","title":"Commit"},{"location":"hazi/hf-folyamat/#push-pull-git-history","text":"A commit m\u0171velet csak a helyi repository-ban \"\u00e9rv\u00e9nyes\u00edti\" a v\u00e1ltoztat\u00e1sokat. Ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sokat a GitHub k\u00f6zponti repository-nkba fel kell t\u00f6lteni a push m\u0171velettel. Erre a l\u00e9p\u00e9sre csak akkor van sz\u00fcks\u00e9g, ha a commit sor\u00e1n nem haszn\u00e1ltuk a \"Commit All and Push\" vagy \"Commit All and Sync\" parancsokat. A push m\u0171velet VS-ben a \"Git/Push\" men\u00fc seg\u00edt\u00e9s\u00e9vel ind\u00edthat\u00f3. Ha t\u00f6bben dolgozunk, a k\u00f6zponti repository-ban lehetnek m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok (vagy ak\u00e1r olyanok, melyeket mi magunk push-oltunk egy m\u00e1sik lok\u00e1lis clone-b\u00f3l, vagy ha a GitHub online fel\u00fclet\u00e9n eszk\u00f6z\u00f6lt\u00fcnk a k\u00f3don v\u00e1ltoz\u00e1sokat). Ezeket a pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni (Git/Pull men\u00fc). A h\u00e1zi feladat vonatkoz\u00e1s\u00e1ban ezt nem haszn\u00e1ljuk, hiszen mindenki saj\u00e1t dedik\u00e1lt k\u00f6zponti repositoryval rendelkezik, melyben egyed\u00fcl dolgozik (kiv\u00e9ve, ha esetleg valaki a GitHub fel\u00fclet\u00e9nek seg\u00edts\u00e9g\u00e9vel v\u00e1ltoztatott a k\u00f3don, akkor ezt egy pull-lal tudja a helyi rep\u00f3j\u00e1ba lehozni). Note A push csak akkor hajthat\u00f3 v\u00e9gre, ha a k\u00f6zponti rep\u00f3ban nincs olyan v\u00e1ltoz\u00e1s, melyet m\u00e9g a pull paranccsal nem hoztunk le \u00e9s merge-elt\u00fcnk a saj\u00e1t lok\u00e1lis rep\u00f3nkba. Ha ez nincs \u00edgy, egy ehhez hasonl\u00f3 hiba\u00fczenet kapunk: \"Unable to push to the remote repository because your local branch is behind the remote branch\". Ekkor pull-oljunk, ut\u00e1na ism\u00e9telj\u00fck meg a pusht. Note A pull m\u0171velet csak akkor hajthat\u00f3 v\u00e9gre, ha nincs olyan v\u00e1ltoztat\u00e1sunk helyben, melyeket m\u00e9g nem commit\u00e1ltunk. Ha van ilyen, akkor azokat vagy commit\u00e1ljuk, vagy ha ezt nem akarjuk megtenni m\u00e9g, akkor stash-elj\u00fck a pull idej\u00e9re. Tip A Pull \u00e9s Push parancsok a \u201eGit Changes\u201d (View/Git Changes men\u00fc jelen\u00edti meg) n\u00e9zet tetej\u00e9n el\u00e9rhet\u0151 le \u00e9s fel nyilakkal is el\u00e9rhet\u0151k: Commit el\u0151tt pull A amennyiben a j\u00f6v\u0151ben egy Git repository-n t\u00f6bben dolgozunk, a v\u00e1ltoztat\u00e1saink commitol\u00e1sa el\u0151tt c\u00e9lszer\u0171 kiadni egy Pull parancsot (Git/Pull men\u00fc). Ez lehozza a k\u00f6zponti Git repositoryb\u00f3l a t\u00f6bbi fejleszt\u0151 v\u00e1ltoztat\u00e1sait \u00e9s \u00f6sszemerge-eli a saj\u00e1t v\u00e1ltoztat\u00e1sainkkal (a helyi rep\u00f3nkban). \u00cdgy, ha valaki net\u00e1n pont azokon a f\u00e1jlokon dolgozott az el\u0151z\u0151 pullunk \u00f3ta, melyeken mi is v\u00e1ltoztattunk, ezek hat\u00e1sa megjelenik a k\u00f3dunkban, az esetleges \u00fctk\u00f6z\u00e9seket m\u00e1r idejekor\u00e1n fel tudjuk oldani, \u00e9s a tiszt\u00e1zott, minden v\u00e1ltoz\u00e1st egyben \u00e9s konzisztensen tartalmaz\u00f3 k\u00f3dot tudjuk commitolni.","title":"Push, Pull, Git history"},{"location":"hazi/hf-folyamat/#git-history","text":"A Git egy v\u00e1ltoz\u00e1sk\u00f6vet\u0151 rendszer. A v\u00e1ltoz\u00e1s egys\u00e9ge a commit (melyben testsz\u0151leges sz\u00e1m\u00fa f\u00e1jlt \u00e9rint\u0151 v\u00e1ltoz\u00e1s lehet), a Git historyban a commitok egym\u00e1sut\u00e1nis\u00e1g\u00e1t l\u00e1thatjuk. Minden f\u00e1jlokat \u00e9rint\u0151 v\u00e1ltoz\u00e1sokon t\u00falmen\u0151en minden commithoz tartozik egy egyedi azonos\u00edt\u00f3 (commit hash), id\u0151b\u00e9lyeg, illetve egy szerz\u0151 (a felhaszn\u00e1l\u00f3, aki a v\u00e1ltoz\u00e1sokat commitolta). Visual Studioban a historyt a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni, de a history term\u00e9szetesen a GitHubon is megjelen\u00edthet\u0151. A Visual Studioban a \"Git Repository\" n\u00e9zetet a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni. Outgoing commits: Megmutatja, hogy milyen a lok\u00e1lis repository-nkba m\u00e1r l\u00e9tez\u0151, de a k\u00f6zponti rep\u00f3ba m\u00e9g nem push-olt commitok vannak. Ezeket a Push m\u0171velettel tudjuk felt\u00f6lteni. Incoming commits: Megmutatja, hogy a k\u00f6zponti repository-ban milyen m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok vannak. Ezek akkor jelennek meg, ha a Fetch paranccsal lehozzuk a helyi rep\u00f3ba (ez m\u00e9g nem merge-el). Ezeket a Pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni. A fetch parancsot ritk\u00e1n haszn\u00e1ljuk: \u00e1ltal\u00e1ban a pullt haszn\u00e1ljuk mag\u00e1ban, ami egy fecth + merge (v\u00e1ltoz\u00e1sok merge-el\u00e9se a helyi rep\u00f3ba) kombin\u00e1ci\u00f3ja. P\u00e9lda: Tip Am\u00edg nem vagyunk rutinosak a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00fcnk-e.","title":"Git history"},{"location":"hazi/hf-folyamat/#egyeb-iranyelvek","text":"A Git commit \u00e9s push sor\u00e1n megfigyelhetj\u00fck, hogy a solution-jeink k\u00f6ztes \u00e9s kimeneti \u00e1llom\u00e1nyai (.dll, .exe, stb. f\u00e1jlok) nem ker\u00fclnek bele a commitba \u00e9s \u00edgy nem ker\u00fclnek fel GitHubra sem. Ez \u00edgy is van j\u00f3l, ezen \u00e1llom\u00e1nyok b\u00e1rmikor reproduk\u00e1lhat\u00f3k, a verzi\u00f3kezel\u0151 rendszernek nem feladata ezek t\u00e1rol\u00e1sa, csak felesleges \u00e9s zavar\u00f3 helyfoglal\u00f3k lenn\u00e9nek. Felmer\u00fcl a k\u00e9rd\u00e9s, honnan tudja a Git, hogy mely \u00e1llom\u00e1nyokat sz\u00fcks\u00e9ges figyelmen k\u00edv\u00fcl hagyni a commit sor\u00e1n. Erre szolg\u00e1l a repository-ban (tipikusan annak gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban) tal\u00e1lhat\u00f3 .gitignore f\u00e1jl, mely felsorolja azon mapp\u00e1kat, f\u00e1jlkiterjeszt\u00e9seket, illetve egyedi f\u00e1jlokat, melyeket a commit sor\u00e1n figyelmen k\u00edv\u00fcl szeretn\u00e9nk hagyni. A .gitignore f\u00e1jl tartalma teljes eg\u00e9sz\u00e9ben a kez\u00fcnk al\u00e1 tartozik, szabadon szerkeszthet\u0151/commit\u00e1lhat\u00f3/pusholhat\u00f3. A t\u00e1rgy keret\u00e9ben minden kiindul\u00f3 rep\u00f3nak r\u00e9sze egy .gitignore f\u00e1jl, ne v\u00e1ltoztassuk a tartalm\u00e1t! \u00cdgy a commit/push sor\u00e1n a kimeneti \u00e1llom\u00e1nyok a h\u00e1zi feladatok eset\u00e9ben sem ker\u00fclnek fel GitHub-ra, \u00e9s egy \u00edgy is van rendj\u00e9n. A f\u00e9l\u00e9vben a feladatok megold\u00e1sa sor\u00e1n az egyes oszt\u00e1lyok, interf\u00e9szek, stb. forr\u00e1sk\u00f3dj\u00e1t k\u00fcl\u00f6n f\u00e1jlba kell tenni, vagyis egy C# forr\u00e1sf\u00e1jlban egy oszt\u00e1ly/interf\u00e9sz/stb. defin\u00edci\u00f3ja legyen.","title":"Egy\u00e9b ir\u00e1nyelvek"},{"location":"hazi/hf-folyamat/#git-hasznalata-parancssorbol","text":"B\u00e1r sokan \u00f3dzkodnak a git parancssori alkalmaz\u00e1s\u00e1t\u00f3l, az egyszer\u0171bb m\u0171veleteket gyakran gyorsabban v\u00e9gre tudjuk hajtani parancssorb\u00f3l, mint a fel\u00fcleteken t\u00f6rt\u00e9n\u0151 kattintgat\u00e1sokkal. Az al\u00e1bbiakban egy egyszer\u0171 l\u00e9p\u00e9ssorozattal illusztr\u00e1ljuk ezt. Ezeket a t\u00e1rgy keret\u00e9ben nem kell tudni, de hosszabb t\u00e1von mindenk\u00e9ppen hasznos (\u00e9s az ipar\u00e1gban elv\u00e1r\u00e1s is) az ismeret\u00fck. Repository clone (ezt csak egyszer) git clone https://github.com/bmeviauab00/hazi1-2022-bzolka V\u00e1ltoztat\u00e1sok v\u00e9grehajt\u00e1sa a helyi rep\u00f3ban (f\u00e1jlrendszerben, fejleszt\u0151eszk\u00f6zben). V\u00e1ltoztat\u00e1sok megtekint\u00e9se, mutatja melyek az \u00faj/t\u00f6r\u00f6lt/m\u00f3dosult f\u00e1jlok (nem k\u00f6telez\u0151, csak ha k\u00edv\u00e1ncsiak vagyunk r\u00e1)* git status Minden v\u00e1ltoztat\u00e1s felt\u00e9tele a staging area-ra git add -A Ha ezt k\u00f6vet\u0151en ism\u00e9t kiadjuk git status parancsot (nem k\u00f6telez\u0151), l\u00e1tjuk, hogy minden v\u00e1ltoz\u00e1s stage-elve van. Commit git commit -m \"megjegyz\u00e9s a commithoz\" Push git push Megjegyz\u00e9sek: Ha t\u00f6bben is dolgozunk az adott git \u00e1gon, akkor 3. l\u00e9p\u00e9s el\u0151tt, de legk\u00e9s\u0151bb a 6. push el\u0151tt sz\u00fcks\u00e9g lehet/van egy git pull -ra, hogy m\u00e1sok v\u00e1ltoztat\u00e1sai jelenjenek meg a mi helyi rep\u00f3nkban (en\u00e9lk\u00fcl nem fogunk tudni push-olni). A pull-nak c\u00e9lszer\u0171 lehet megadni egy --rebase opci\u00f3t is, hogy ne sz\u00fclessen a merge-hez egy plusz merge commit, ennek magyar\u00e1zat\u00e1ra itt nem t\u00e9r\u00fcnk ki. Mint kor\u00e1bban eml\u00edtett\u00fck, a commit sor\u00e1n az commithoz hozz\u00e1rendel\u0151dik egy felhaszn\u00e1l\u00f3n\u00e9v \u00e9s e-mail c\u00edm. Ha ezek nincsenek a git sz\u00e1m\u00e1ra bekonfigur\u00e1lva, akkor a git a commit sor\u00e1n ezt hiba\u00fczenetben jelzi. Ekkor az al\u00e1bbi parancsokkal - \u00e9rtelemszer\u0171en a saj\u00e1t usernev\u00fcnket \u00e9s e-mail c\u00edm\u00fcnket megadva - tudjuk ezeket a git glob\u00e1lis konfigur\u00e1ci\u00f3j\u00e1ban be\u00e1ll\u00edtani (ezt csak egyszer kell megtenni): git config --global user.email \"you@example.com\" git config --global user.name \"myusername\" Windows parancssorban \u00f6sszevonhatunk t\u00f6bb parancsot is egy sorba, pl. egy l\u00e9p\u00e9sben stage/commit/push: git add -A & git commit -m \"All tests run\" & git push Powershell haszn\u00e1latakor a & helyett ; -t kell szepar\u00e1tork\u00e9nt haszn\u00e1lni.","title":"Git haszn\u00e1lata parancssorb\u00f3l"},{"location":"labor/1-model-es-kod-kapcsolata/","text":"1. A modell \u00e9s a k\u00f3d kapcsolata \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja: Ismerked\u00e9s a hallgat\u00f3kkal/gyakorlatvezet\u0151vel A gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyek pontos\u00edt\u00e1sa Elindul\u00e1s Visual Studio-val \u00e9s .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9vel. Egy egyszer\u0171 Hello World .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja Gyakorlatvezet\u0151knek A hallgat\u00f3k kor\u00e1bbi tanulm\u00e1nyaik sor\u00e1n C++ gyakorlaton m\u00e1r haszn\u00e1lt\u00e1k a Visual Studio k\u00f6rnyezet, \u00edgy a c\u00e9l jelen esetben az ismeretek feleleven\u00edt\u00e9se \u00e9s \u00e9let\u00fcnk els\u0151 C# alkalmaz\u00e1s\u00e1nak elk\u00e9sz\u00edt\u00e9se. Ugyanakkor el\u0151fordulhat, hogy a hallgat\u00f3k nem eml\u00e9keznek pontosan a Visual Studio haszn\u00e1lat\u00e1ra, \u00edgy a feladatok megold\u00e1sa sor\u00e1n ezeket folyamatosan eleven\u00edts\u00fck fel (pl. Solution Explorer, F5-futtat\u00e1s, breakpoint haszn\u00e1lat, stb.) El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Visual Studio-b\u00f3l a legfrissebb verzi\u00f3t c\u00e9lszer\u0171 feltenni. A Community Edition, Professional \u00e9s az Enterprise verzi\u00f3 is megfelel. A Community Edition ingyenes, let\u00f6lthet\u0151 a Microsoft honlapj\u00e1r\u00f3l. A Professional fizet\u0151s, de az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ez is ingyenesen el\u00e9rhet\u0151 ( https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben). Visual Studio Class Diagram t\u00e1mogat\u00e1s Jelen gyakorlat bizonyos feladatain\u00e1l (\u00e9s az els\u0151 h\u00e1zi feladat eset\u00e9ben is) a Visual Studio Class Designer t\u00e1mogat\u00e1s\u00e1t haszn\u00e1ljuk. A Visual Studio nem teszi fel minden esetben a Class Designer komponenst a telep\u00edt\u00e9s sor\u00e1n. Ha nem lehet Class Diagram-ot felvenni a Visual Studio projektbe (mert a Class Diagram nem szerepel a list\u00e1ban az Add New Item parancs sor\u00e1n megjelen\u0151 ablak list\u00e1j\u00e1ban \u2013 err\u0151l a jelen \u00fatmutat\u00f3 k\u00e9s\u0151bbi fejezet\u00e9ben b\u0151vebben), akkor a Class Diagram komponenst ut\u00f3lag kell telep\u00edteni: Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel). A megjelen\u0151 ablakban \u201eIndividual components\u201d f\u00fcl kiv\u00e1laszt\u00e1sa A keres\u0151mez\u0151be \u201eclass designer\u201d beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \u201eClass Designer\u201d elem ki van pip\u00e1lva. Amit \u00e9rdemes \u00e1tn\u00e9zned: A gyakorlathoz nem kapcsol\u00f3dik a t\u00e1rgyb\u00f3l el\u0151ad\u00e1s. Ugyanakkor a gyakorlat \u00e9p\u00edt az UML alapismeretekre, illetve az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d egym\u00e1sra t\u00f6rt\u00e9n\u0151 lek\u00e9pez\u00e9s\u00e9nek alapjaira. Gyakorlat menete \u00b6 A gyakorlatvezet\u0151 a gyakorlat elej\u00e9n \u00f6sszefoglalja a gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyeket: A t\u00e1rgyi adatlapon ezek t\u00f6bbs\u00e9ge megtal\u00e1lhat\u00f3 Az otthoni feladatokr\u00f3l inform\u00e1ci\u00f3 a t\u00e1rgy honlapj\u00e1n tal\u00e1lhat\u00f3. Visual Studio fejleszt\u0151eszk\u00f6zzel, .NET alkalmaz\u00e1sokat fogunk k\u00e9sz\u00edteni C# nyelven. A C# hasonl\u00edt a Java-hoz, fokozatosan ismerj\u00fck meg a k\u00fcl\u00f6nbs\u00e9geket. A gyakorlat vezetett, gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok. 1. Feladat - \u201eHello world\u201d .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se \u00b6 A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely a konzolra ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget. Az alkalmaz\u00e1st C# nyelven k\u00e9sz\u00edtj\u00fck el. A leford\u00edtott alkalmaz\u00e1s futtat\u00e1s\u00e1t a .NET runtime v\u00e9gzi. A ford\u00edt\u00e1s/futtat\u00e1s elm\u00e9leti h\u00e1tter\u00e9t, valamint a .NET alapjait az els\u0151 el\u0151ad\u00e1s ismerteti. A solution \u00e9s azon bel\u00fcli projekt l\u00e9trehoz\u00e1s\u00e1nak l\u00e9p\u00e9sei Visual Studio 2022 eset\u00e9n: \u00daj projekt var\u00e1zsl\u00f3 elind\u00edt\u00e1sa, melyre k\u00e9t m\u00f3d is van Ind\u00edt\u00f3ablak seg\u00edts\u00e9g\u00e9vel Ind\u00edtsuk el a Visual Studio-t A megjelen\u0151 ind\u00edt\u00f3ablak jobb oldali s\u00e1vj\u00e1ban Create new project M\u00e1r fut\u00f3 Visual Studio-ban File / New-Project A Create new project var\u00e1zsl\u00f3ban a Console app (\u00e9s NEM a Console app (.NET Framework) sablont v\u00e1lasszuk ki, ebb\u0151l is a C#-osat. Azt, hogy C#-os, a sablon ikonj\u00e1nak bal fels\u0151 sarka jelzi. Ha nem l\u00e1tjuk a list\u00e1ban, r\u00e1 kell keresni/sz\u0171rni. R\u00e1kereshet\u00fcnk a fels\u0151 keres\u0151s\u00e1vban a \u201econsole\u201d be\u00edr\u00e1s\u00e1val. Vagy az alatta lev\u0151 leny\u00edl\u00f3 mez\u0151k seg\u00edts\u00e9g\u00e9vel: az els\u0151ben (nyelvkiv\u00e1laszt\u00f3) \u201eC#\u201d, a harmadikban (projektt\u00edpus kiv\u00e1laszt\u00f3) \u201eConsole\u201d. Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon: Project name: Hello World Location: a laborokban a c:\\work\\ mapp\u00e1ba dolgozzunk, ehhez van \u00edr\u00e1si jogunk. Solution name: Hello World (elvileg ez be is lesz \u00edrva, mire ide\u00e9r\u00fcnk) Place solution and project in the same directory: nincs pipa (de nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge). Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon: Framework: .NET 6 (Long-term support) . A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be (ennek magyar\u00e1zat\u00e1ra mindj\u00e1rt visszat\u00e9r\u00fcnk). A projekttel egy \u00faj solution is l\u00e9trej\u00f6n, mely strukt\u00far\u00e1ja a Visual Studio Solution Explorer ablak\u00e1ban tekinthet\u0151 \u00e1t. Egy solution t\u00f6bb projectb\u0151l \u00e1llhat, egy project pedig t\u00f6bb f\u00e1jlb\u00f3l. A solution a teljes munkak\u00f6rnyezetet fogja \u00f6ssze (egy .sln kiterjeszt\u00e9s\u0171 f\u00e1jl tartozik hozz\u00e1), m\u00edg egy projekt kimenete egy .exe vagy .dll f\u00e1jl jellemz\u0151en, vagyis egy \u00f6sszetett alkalmaz\u00e1s/rendszer egy komponens\u00e9t \u00e1ll\u00edtja el\u0151. A projektf\u00e1jlok kiterjeszt\u00e9se C# alkalmaz\u00e1sok eset\u00e9n .csproj . A Program.cs f\u00e1jlunk tartalma a k\u00f6vetkez\u0151: Program.cs namespace HelloWorld { internal class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); } } } Vegy\u00fcnk fel egy Console.ReadKey() sort: namespace HelloWorld { internal class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); Console . ReadKey (); } } } Futtassuk az alkalmaz\u00e1st (pl. az F5 billenty\u0171 haszn\u00e1lat\u00e1val). A k\u00f3d fel\u00e9p\u00edt\u00e9se nagyon hasonl\u00edt a Java-hoz, illetve a C++-hoz. Az oszt\u00e1lyaink n\u00e9vterekbe szervezettek. N\u00e9vteret defini\u00e1lni a namespace kulcssz\u00f3val tudunk. N\u00e9vtereket hat\u00f3k\u00f6rbe \u201ehozni\u201d a using kulcssz\u00f3val tudjuk. pl.: using System.Collections.Generic ; Egy konzolos C# alkalmaz\u00e1sban az alkalmaz\u00e1sunk bel\u00e9p\u00e9si pontj\u00e1t egy statikus Main nev\u0171 f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1val adjuk meg. Az oszt\u00e1lyunk neve b\u00e1rmi lehet, a VS egy Program nev\u0171 oszt\u00e1lyt gener\u00e1lt eset\u00fcnkben. A Main f\u00fcggv\u00e9ny param\u00e9terlist\u00e1ja k\u00f6t\u00f6tt: vagy ne adjunk meg param\u00e9tereket, vagy egy string[] -\u00f6t adjunk meg, amiben fut\u00e1s k\u00f6zben megkapjuk az parancssori argumentumokat. .NET-ben a standard ki \u00e9s bemenet kezel\u00e9s\u00e9re a System n\u00e9vt\u00e9r Console oszt\u00e1lya haszn\u00e1land\u00f3. A WriteLine statikus m\u0171velet\u00e9vel egy sort tudunk ki\u00edrni, a ReadKey m\u0171velettel egy billenty\u0171 lenyom\u00e1s\u00e1ra v\u00e1rakozhatunk. Top level statements, Implicit \u00e9s static usings \u00e9s n\u00e9vterek A projekt l\u00e9trehoz\u00e1sakor kor\u00e1bban bepip\u00e1ltuk a \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet. Ha ezt nem tett\u00fck volna meg, akkor a Program.cs f\u00e1jlunkban mind\u00f6ssze egyetlen \u00e9rdemi sort tal\u00e1ltunk volna: // See https://aka.ms/new-console-template for more information Console . WriteLine ( \"Hello World!\" ); Ez m\u0171k\u00f6d\u00e9s\u00e9ben ekvivalens a fenti Program oszt\u00e1lyt \u00e9s ebben Main f\u00fcggv\u00e9nyt tartalmaz\u00f3 k\u00f3ddal. N\u00e9zz\u00fck, mik teszik ezt lehet\u0151v\u00e9 (ezekr\u0151l pl. itt https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements olvashatunk b\u0151vebben, mindkett\u0151 C# 10 \u00fajdons\u00e1g): Top level statements . Ennek az a l\u00e9nyege, hogy mindenf\u00e9le oszt\u00e1ly/ Main \u00e9s egy\u00e9b f\u00fcggv\u00e9nydefin\u00edci\u00f3 n\u00e9lk\u00fcl a projektben egyetlen forr\u00e1sf\u00e1jlban k\u00f6zvetlen\u00fcl is \u00edrhatunk k\u00f3dot. Ez esetben ezt a sz\u00ednfalak m\u00f6g\u00f6tt a ford\u00edt\u00f3 berakja egy \u00e1ltalunk nem l\u00e1that\u00f3 oszt\u00e1ly statikus Main f\u00fcggv\u00e9ny\u00e9be. A bevezet\u00e9s\u00e9nek a motiv\u00e1ci\u00f3ja az volt, hogy a nagyon egyszer\u0171, \u201escript\u201d szer\u0171 alkalmaz\u00e1sok eset\u00e9n kevesebb legyen a boilerplate k\u00f3d. Implicit global usings . Annak f\u00fcggv\u00e9ny\u00e9ben, hogy pontosan milyen projektt\u00edpust hoztunk l\u00e9tre, bizonyos alapn\u00e9vterek a sz\u00ednfalak m\u00f6g\u00f6tt automatikusan using-olva lesznek minden forr\u00e1sf\u00e1jlban (ehhez a compiler a global using utas\u00edt\u00e1st haszn\u00e1lja). A l\u00e9nyeg: a fejleszt\u0151knek \u00edgy bizonyos, gyakran haszn\u00e1lt n\u00e9vtereket (pl. System.IO , System.Collections.Generic stb.) nem kell a forr\u00e1sf\u00e1jlonk\u00e9nt using-olni. Static using . Lehet\u0151s\u00e9g\u00fcnk van C#-ban n\u00e9vterek helyett statikus oszt\u00e1lyokat is usingolni, \u00edgy azokat a haszn\u00e1latuk sor\u00e1n nem fontos ki\u00edrni. Gyakori eset erre a Console vagy a Math oszt\u00e1ly usingol\u00e1sa. using static System . Console ; namespace ConsoleApp12 { internal class Program { static void Main ( string [] args ) { WriteLine ( \"Hello, World!\" ); } } } F\u00e1jl szint\u0171 n\u00e9vterek . C# 10-ben szint\u00e9n egy egyszer\u0171s\u00edt\u00e9st kapunk a n\u00e9vterek deklar\u00e1l\u00e1sa sor\u00e1n, mert m\u00e1r nem k\u00f6telez\u0151 a kapcsos z\u00e1r\u00f3jeleket kitenni, \u00edgy az adott namespace a teljes f\u00e1jlra \u00e9rv\u00e9nyes lesz pl.: namespace HelloWorld ; internal class Program { // ... } Inconsistent visibility vagy inconsistent accessibility hiba A f\u00e9l\u00e9v sor\u00e1n a programoz\u00e1si feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n tal\u00e1lkozhatunk inconsistent visibility -re vagy inconsistent accessibility -re panaszkod\u00f3 ford\u00edt\u00e1si hiba\u00fczenetekkel. A jelens\u00e9g h\u00e1tter\u00e9ben az \u00e1ll, hogy .NET k\u00f6rnyezetben lehet\u0151s\u00e9g van az egyes t\u00edpusok (oszt\u00e1ly, interf\u00e9sz, stb.) l\u00e1that\u00f3s\u00e1g\u00e1nak szab\u00e1lyoz\u00e1s\u00e1ra: internal vagy nem adjuk meg a l\u00e1that\u00f3s\u00e1got: a t\u00edpus csak az adott szerelv\u00e9nyen (.exe, .dll)/projekten, bel\u00fcl l\u00e1that\u00f3 public : a t\u00edpus m\u00e1s szerelv\u00e9nyek/projektek sz\u00e1m\u00e1ra is l\u00e1that\u00f3 A hiba legegyszer\u0171bben \u00fagy h\u00e1r\u00edthat\u00f3 el, ha minden t\u00edpusunkat publikusnak defini\u00e1ljuk, pl.: public class HardDisk { // ... } Elm\u00e9leti \u00e1ttekint\u00e9s \u00b6 Az alfejezetek nem tartalmaznak feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismertetik a kapcsol\u00f3d\u00f3 elm\u00e9leti t\u00e9mak\u00f6r\u00f6ket, p\u00e9ld\u00e1kkal illusztr\u00e1lva. A) Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete [hallgat\u00f3]* \u00b6 Az anyag itt el\u00e9rhet\u0151: Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolata . Ez a t\u00e9mak\u00f6r kor\u00e1bbi f\u00e9l\u00e9vben a Szoftvertechnol\u00f3gia t\u00e1rgy keret\u00e9ben ker\u00fclt ismertet\u00e9sre. B) Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly [hallgat\u00f3]* \u00b6 Az anyag itt el\u00e9rhet\u0151: Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly . T\u00e9mak\u00f6r\u00f6k: Absztrakt oszt\u00e1ly fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven Interf\u00e9sz fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa 2. Feladat - Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se \u00b6 Feladat le\u00edr\u00e1sa - Equipment inventory \u00b6 Feladat: Egy sz\u00e1m\u00edt\u00f3g\u00e9palkatr\u00e9sz nyilv\u00e1ntart\u00f3 alkalmaz\u00e1s kifejleszt\u00e9s\u00e9vel b\u00edztak meg benn\u00fcnket. B\u0151vebben: K\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00fa alkatr\u00e9szeket kell tudni kezelni. Kezdetben a HardDisk , SoundCard \u00e9s LedDisplay t\u00edpusokat kell t\u00e1mogatni, de a rendszer legyen k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00faj t\u00edpusokkal. Az alkatr\u00e9szekhez tartoz\u00f3 adatok: beszerz\u00e9s \u00e9ve, \u00e9letkora (sz\u00e1m\u00edtott), beszerz\u00e9si \u00e1ra \u00e9s aktu\u00e1lis \u00e1ra (sz\u00e1m\u00edtott), de ezeken fel\u00fcl t\u00edpusf\u00fcgg\u0151 adatokat is tartalmazhatnak (pl. a HardDisk eset\u00e9ben a kapacit\u00e1s). Az aktu\u00e1lis \u00e1r f\u00fcgg az alkatr\u00e9sz t\u00edpus\u00e1t\u00f3l, a beszerz\u00e9si \u00e1rt\u00f3l \u00e9s az alkatr\u00e9sz gy\u00e1rt\u00e1si \u00e9v\u00e9t\u0151l. Pl. min\u00e9l \u00f6regebb egy alkatr\u00e9sz, ann\u00e1l nagyobb kedvezm\u00e9nyt adunk r\u00e1, de a kedvezm\u00e9ny m\u00e9rt\u00e9ke f\u00fcgg az alkatr\u00e9sz t\u00edpust\u00f3l is. List\u00e1zni kell tudni a k\u00e9szleten lev\u0151 alkatr\u00e9szeket. A LedDisplay oszt\u00e1lynak k\u00f6telez\u0151en egy DisplayBase oszt\u00e1lyb\u00f3l kell sz\u00e1rmaznia, \u00e9s a DisplayBase oszt\u00e1ly forr\u00e1sk\u00f3dja nem megv\u00e1ltoztathat\u00f3. Jelen p\u00e9ld\u00e1ban ennek nincs sok \u00e9rtelme, a gyakorlatban azonban gyakran tal\u00e1lkozunk hasonl\u00f3 helyzettel, amikor is az \u00e1ltalunk haszn\u00e1lt keretrendszer/platform el\u0151\u00edrja, hogy adott esetben egy-egy be\u00e9p\u00edtett oszt\u00e1lyb\u00f3l kell sz\u00e1rmaztassunk. Tipikusan ez a helyzet, amikor ablakokkal, \u0171rlapokkal, saj\u00e1t vez\u00e9rl\u0151t\u00edpusokkal dolgozunk: ezeket a keretrendszer be\u00e9p\u00edtett oszt\u00e1lyaib\u00f3l kell sz\u00e1rmaztatnunk, \u00e9s a keretrendszer - pl. Java, .NET - forr\u00e1sk\u00f3dja nem \u00e1ll rendelkez\u00e9s\u00fcnkre (de legal\u00e1bbis biztosan nem akarjuk megv\u00e1ltoztatni). A p\u00e9ld\u00e1nkban a DisplayBase -b\u0151l val\u00f3 sz\u00e1rmaztat\u00e1s el\u0151\u00edr\u00e1s\u00e1val ezt a helyzetet szimul\u00e1ljuk. A megval\u00f3s\u00edt\u00e1s sor\u00e1n jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9l\u00fcnk: az alkatr\u00e9szeket csak mem\u00f3ri\u00e1ban tarjuk nyilv\u00e1n, a list\u00e1z\u00e1s is a lehet\u0151 legegyszer\u0171bb, egyszer\u0171en csak ki\u00edrjuk a nyilv\u00e1ntartott alkatr\u00e9szek adatait a konzolra. A kezdeti egyeztet\u00e9sek sor\u00e1n a megrendel\u0151nkt\u0151l a k\u00f6vetkez\u0151 inform\u00e1ci\u00f3t kapjuk: egy bels\u0151 munkat\u00e1rsuk m\u00e1r elindult a fejleszt\u00e9ssel, de id\u0151 hi\u00e1ny\u00e1ban csak f\u00e9lk\u00e9sz megold\u00e1sig jutott. A feladatunk r\u00e9sz\u00e9t k\u00e9pezi a f\u00e9lk\u00e9sz megold\u00e1s megismer\u00e9se, illetve ebb\u0151l kiindulva kell a feladatot megval\u00f3s\u00edtani. Class Diagram \u00b6 Nyissuk meg a megrendel\u0151nkt\u0151l kapott forr\u00e1sk\u00f3d solution-j\u00e9t, melyet a k\u00f6vetkez\u0151 l\u00e9p\u00e9seket k\u00f6vetve tudunk megtenni. Ehhez kl\u00f3nozzuk le a kiindul\u00f3 projekt online GitHub rendszerben el\u00e9rhet\u0151 Git repositoryj\u00e1t a C:\\Work mapp\u00e1n bel\u00fcl egy \u00faj saj\u00e1t mapp\u00e1ba: pl.: C:\\Work\\NEPTUN\\lab1 . Ebben az \u00faj mapp\u00e1ban nyissunk meg egy command line-t vagy powershellt \u00e9s futtassuk az al\u00e1bbi git parancsot: git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo.git Note A Git-r\u0151l, mint forr\u00e1sk\u00f3dkezel\u0151 rendszerr\u0151l, az els\u0151 h\u00e1zi feladat kontextus\u00e1ban olvashatunk majd b\u0151vebben. Nyissuk meg a lekl\u00f3nozott mapp\u00e1ban tal\u00e1lhat\u00f3 src/EquipmentInventory.sln Visual Studio solutiont. A Solution Explorerben szemmel fussuk \u00e1t a f\u00e1jlokat. Az meg\u00e9rt\u00e9st seg\u00edten\u00e9, ha egy oszt\u00e1lydiagramon megjelen\u00edten\u00e9nk az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatokat. Vegy\u00fcnk is fel egy oszt\u00e1lydiagramot a projekt\u00fcnkbe. A Solution Explorerben a projekten (\u00e9s nem a solution-\u00f6n!) jobb gombbal kattintva a felugr\u00f3 men\u00fcben az Add/New Item elemet v\u00e1lasztva, majd a megjelen\u0151 ablakban a Class Diagram elemet v\u00e1lasszuk ki, az ablak alj\u00e1n a diagram nev\u00e9nek a Main.cd-t adjuk meg, \u00e9s OK-zuk le az ablakot. Class Diagram hi\u00e1nyz\u00f3 sablon Ha a Class Diagram elem nem jelenik meg a list\u00e1ban, akkor nincs telep\u00edtve a VS megfelel\u0151 komponense. Err\u0151l jelen dokumentum El\u0151felt\u00e9telek fejezet\u00e9ben olvashatsz b\u0151vebben. Ekkor a Solution Explorerben megjelenik a Main.cd diagramf\u00e1jl, duplakattint\u00e1ssal nyissuk meg. A diagramunk jelenleg \u00fcres. A Solution Explorerb\u0151l drag&drop-pal dobjuk r\u00e1 a .cs forr\u00e1sf\u00e1jlokat a diagramra. Ekkor a VS megn\u00e9zi, milyen oszt\u00e1lyok vannak ezekben a forr\u00e1sf\u00e1jlokban, \u00e9s visszafejti \u0151ket UML oszt\u00e1lyokk\u00e1. Alak\u00edtsuk ki a k\u00f6vetkez\u0151 \u00e1br\u00e1nak megfelel\u0151 elrendez\u00e9st (az oszt\u00e1lyok tagjainak megjelen\u00edt\u00e9s\u00e9t a t\u00e9glalapuk jobb fels\u0151 sark\u00e1ban lev\u0151 duplany\u00edlra kattint\u00e1ssal \u00e9rhetj\u00fck el): Az oszt\u00e1lyokhoz tartoz\u00f3 forr\u00e1sk\u00f3dot is megn\u00e9zhetj\u00fck, ak\u00e1r a diagramon a megfelel\u0151 oszt\u00e1lyra dupl\u00e1n kattintva, ak\u00e1r a Solution Explorerb\u0151l a .cs f\u00e1jlokat megnyitva. A k\u00f6vetkez\u0151ket tapasztaljuk: A SoundCard , HardDisk \u00e9s LedDisplay oszt\u00e1lyok viszonylag j\u00f3l kidolgozottak, rendelkeznek a sz\u00fcks\u00e9ges attrib\u00fatumokkal \u00e9s lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyekkel. Az LedDisplay a k\u00f6vetelm\u00e9nyeknek megfelel\u0151en a DisplayBase oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Az EquipmentInventory felel\u0151s ugyan a k\u00e9szleten lev\u0151 alkatr\u00e9szek nyilv\u00e1ntart\u00e1s\u00e1\u00e9rt, de gyakorlatilag semmi nincs ebb\u0151l megval\u00f3s\u00edtva. Tal\u00e1lunk egy IEquipment interf\u00e9szt, GetAge \u00e9s GetPrice m\u0171veletekkel EquipmentInventory \u00b6 \u00c1lljunk neki a megold\u00e1s kidolgoz\u00e1s\u00e1nak. El\u0151sz\u00f6r is az alapkoncepci\u00f3kat fektess\u00fck le. Az EquipmentInventory oszt\u00e1lyban egy heterog\u00e9n kollekci\u00f3ban t\u00e1roljuk a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusokat. Ez a kulcsa az alkatr\u00e9szek egys\u00e9ges kezel\u00e9s\u00e9nek, vagyis annak, hogy a megold\u00e1sunk \u00faj alkatr\u00e9szt\u00edpusokkal k\u00f6nnyen b\u0151v\u00edthet\u0151 legyen. Mint kor\u00e1bban taglaltuk, az egys\u00e9ges kezel\u00e9st vagy k\u00f6z\u00f6s \u0151soszt\u00e1ly, vagy k\u00f6z\u00f6s interf\u00e9sz bevezet\u00e9s\u00e9vel lehet megoldani. Eset\u00fcnkben a k\u00f6z\u00f6s \u0151soszt\u00e1ly (pl. EquipmentBase ) \u00fagy t\u0171nik, kiesik, mert ennek bevezet\u00e9s\u00e9vel az LedDisplay oszt\u00e1lynak k\u00e9t \u0151soszt\u00e1lya is lenne: a k\u00f6telez\u0151nek kik\u00f6t\u00f6tt DisplayBase , \u00e9s az \u00e1ltalunk az egys\u00e9ges kezel\u00e9sre bevezetett EquipmentBase . Ez nem lehets\u00e9ges, .NET k\u00f6rnyezetben egy oszt\u00e1lynak csak egy \u0151se lehet. Az a megold\u00e1s pedig, hogy a DisplayBase -t \u00fagy m\u00f3dos\u00edtjuk, hogy \u0151 is az EquipmentBase -b\u0151l sz\u00e1rmazik, a k\u00f6vetelm\u00e9ny\u00fcnknek megfelel\u0151en nem lehets\u00e9ges (kik\u00f6t\u00e9s volt, hogy a forr\u00e1sk\u00f3dja nem m\u00f3dos\u00edthat\u00f3). Marad teh\u00e1t az interf\u00e9sz alap\u00fa megk\u00f6zel\u00edt\u00e9s. Minden bizonnyal az alkalmaz\u00e1s kor\u00e1bbi fejleszt\u0151je is erre a k\u00f6vetkeztet\u00e9sre jutott, ez\u00e9rt is vezette be az IEquipment interf\u00e9szt. Vegy\u00fcnk fel egy IEquipment t\u00edpus\u00fa elemekb\u0151l \u00e1ll\u00f3 generikus list\u00e1t (ne property-t hanem field-et!) az EquipmentInventory oszt\u00e1lyba. A l\u00e1that\u00f3s\u00e1ga \u2013 az egys\u00e9gbez\u00e1r\u00e1sra t\u00f6rekedve \u2013 legyen private . A neve legyen equipment (ne legyen \u201es\u201d a v\u00e9g\u00e9n, angolban az equipment t\u00f6bbes sz\u00e1ma is equipment). A tagv\u00e1ltoz\u00f3 felv\u00e9tel\u00e9hez a Visual Studio Class Details ablak\u00e1t haszn\u00e1ljuk. Ha az ablak nem l\u00e1that\u00f3, a View / Other Windows / Class Details men\u00fc kiv\u00e1laszt\u00e1s\u00e1val jelen\u00edthet\u0151 meg. A tagv\u00e1ltoz\u00f3 t\u00edpusa teh\u00e1t List<IEquipment> . A .NET List t\u00edpusa egy dinamikusan ny\u00fajt\u00f3zkod\u00f3 generikus t\u00f6mb (mint Java-ban az ArrayList ). A diagramon az EquipmentInventory oszt\u00e1lyra pillantva azt l\u00e1tjuk, hogy csak a tagv\u00e1ltoz\u00f3 neve jelenik meg, a t\u00edpusa nem. A diagram h\u00e1tter\u00e9n jobb gombbal kattintva a Change Members Format men\u00fcb\u0151l a Display Full Signature -t v\u00e1lasszuk ki. Ezt k\u00f6vet\u0151en a diagramon l\u00e1that\u00f3v\u00e1 v\u00e1lik a tagv\u00e1ltoz\u00f3k t\u00edpusa, valamint a m\u0171veletek teljes szignat\u00far\u00e1ja. Az EquipmentInventory oszt\u00e1lyon dupl\u00e1n kattintva elnavig\u00e1lhatunk a forr\u00e1sk\u00f3dba, \u00e9s mint l\u00e1that\u00f3, val\u00f3ban egy lista t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k\u00e9nt jelenik meg a k\u00f3dban: class EquipmentInventory { private List < IEquipment > equipment ; Ennek egyr\u00e9szt \u00f6r\u00fcl\u00fcnk, mert a Visual Studio t\u00e1mogatja a round-trip engineering technik\u00e1t: a modellt \u00e9rint\u0151 v\u00e1ltoz\u00e1sokat azonnal \u00e1tvezeti a k\u00f3dba, \u00e9s viszont . M\u00e1sr\u00e9szt a kor\u00e1bbiakban azt taglaltuk, hogy ha egy oszt\u00e1lyban egy gy\u0171jtem\u00e9ny tag van egy m\u00e1sik oszt\u00e1ly elemeib\u0151l, akkor annak az UML modellben egy 1-t\u00f6bb t\u00edpus\u00fa asszoci\u00e1ci\u00f3s kapcsolatk\u00e9nt \u201eillik\u201d megjelennie a k\u00e9t oszt\u00e1ly k\u00f6z\u00f6tt. A modell\u00fcnkben egyel\u0151re nem ezt tapasztaljuk. Szerencs\u00e9re a VS modellez\u0151 fel\u00fclete r\u00e1vehet\u0151, hogy ilyen form\u00e1ban jelen\u00edtse meg ezt a kapcsolatt\u00edpust. Ehhez kattintsunk a diagramon jobb gombbal az equipment tagv\u00e1ltoz\u00f3n, \u00e9s a men\u00fcb\u0151l v\u00e1lasszuk ki a Show as Collection Association elemet. Az IEquipment interf\u00e9szt ezt k\u00f6vet\u0151en mozgassuk ki jobbra, hogy kell\u0151 hely legyen a diagramon az asszoci\u00e1ci\u00f3s kapcsolat \u00e9s a kapcsolaton lev\u0151 szerep (role) adatainak megjelen\u00edt\u00e9s\u00e9re: A dupla ny\u00edl v\u00e9gz\u0151d\u00e9s a \u201et\u00f6bbes\u201d oldalon nem szabv\u00e1nyos UML, de ne szomorodjunk el t\u0151le k\u00fcl\u00f6n\u00f6sebben, nincs semmi jelent\u0151s\u00e9ge. Annak mindenk\u00e9ppen \u00f6r\u00fcl\u00fcnk, hogy a kapcsolatot reprezent\u00e1l\u00f3 ny\u00edl az IEquipment v\u00e9g\u00e9n a szerepben a tagv\u00e1ltoz\u00f3 neve (s\u0151t, m\u00e9g a pontos t\u00edpusa is) fel van t\u00fcntetve. Navig\u00e1ljunk el az EquipmentInventory forr\u00e1sk\u00f3dj\u00e1hoz, \u00e9s \u00edrjuk meg a konstruktor\u00e1t, ami inicializ\u00e1lja az equipment gy\u0171jtem\u00e9nyt! public EquipmentInventory () { equipment = new List < IEquipment >(); } Ezut\u00e1n \u00edrjuk meg a ListAll met\u00f3dust, ami ki\u00edrja az elemek \u00e9letkor\u00e1t, \u00e9s az aktu\u00e1lis \u00e9rt\u00e9k\u00fcket: public void ListAll () { foreach ( IEquipment eq in equipment ) { Console . WriteLine ( $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\" ); } } Az elemeken a foreach utas\u00edt\u00e1ssal iter\u00e1lunk v\u00e9gig. A foreach utas\u00edt\u00e1s haszn\u00e1lata sor\u00e1n az in kulcssz\u00f3 ut\u00e1n egy gy\u0171jtem\u00e9nynek kell \u00e1llnia, az in el\u0151tt pedig egy v\u00e1ltoz\u00f3 deklar\u00e1ci\u00f3nak (eset\u00fcnkben IEquipment eq ), ahol a t\u00edpus a gy\u0171jtem\u00e9ny elemt\u00edpusa. Minden iter\u00e1ci\u00f3ban ez a v\u00e1ltoz\u00f3 a gy\u0171jtem\u00e9ny iter\u00e1ci\u00f3beli \u00e9rt\u00e9k\u00e9t veszi fel. A Console.WriteLine m\u0171veletnek vagy egy egyszer\u0171 stringet adunk meg, vagy, mint eset\u00fcnkben, egy form\u00e1z\u00e1si stringet. A behelyettes\u00edt\u00e9seket string interpol\u00e1ci\u00f3val oldottuk meg: a behelyettes\u00edtend\u0151 \u00e9rt\u00e9keket {} k\u00f6z\u00f6tt kell megadni. Ha string interpol\u00e1ci\u00f3t haszn\u00e1lunk, a stringnek $ jellel kell kezd\u0151dnie. \u00cdrjunk meg egy AddEquipment nev\u0171 f\u00fcggv\u00e9nyt, ami felvesz egy \u00faj eszk\u00f6zt a k\u00e9szletbe: public void AddEquipment ( IEquipment eq ) { equipment . Add ( eq ); } IEquipment megval\u00f3s\u00edt\u00f3k \u00b6 Kor\u00e1bbi d\u00f6nt\u00e9s\u00fcnk \u00e9rtelm\u00e9ben az IEquipment interf\u00e9szt haszn\u00e1ljuk az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusok egys\u00e9ges kezel\u00e9s\u00e9re. Est\u00fcnkben mind a SoundCard , mind a HardDisk oszt\u00e1ly rendelkezik GetAge() \u00e9s GetPrice() met\u00f3dussal, m\u00e9gsem tudjuk \u0151ket egys\u00e9gesen kezelni (pl. k\u00f6z\u00f6s list\u00e1ban t\u00e1rolni). Ahhoz, hogy ezt meg tudjuk tenni, el kell \u00e9rn\u00fcnk, hogy mindk\u00e9t oszt\u00e1ly megval\u00f3s\u00edtsa az IEquipment interf\u00e9szt. M\u00f3dos\u00edtsuk a forr\u00e1sukat: public class SoundCard : IEquipment public class HardDisk : IEquipment Ezt k\u00f6vet\u0151en a SoundCard \u00e9s HardDisk oszt\u00e1lyban implement\u00e1lnunk kell az IEquipment interf\u00e9szben lev\u0151 met\u00f3dusokat. Azt tapasztaljuk, hogy ezzel nincs most teend\u0151k, a GetPrice \u00e9s GetAge f\u00fcggv\u00e9nyek m\u00e1r meg vannak \u00edrva mindk\u00e9t helyen. Pr\u00f3bak\u00e9ppen a Program.cs f\u00e1jlban tal\u00e1lhat\u00f3 Main f\u00fcggv\u00e9ny\u00fcnkben hozzunk l\u00e9tre egy EquipmentInventory objektumot, t\u00f6lts\u00fck fel HardDisk \u00e9s SoundCard objektumokkal, majd list\u00e1zzuk a k\u00e9sztelet a konzolra. Ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra! static void Main ( string [] args ) { EquipmentInventory ei = new EquipmentInventory (); ei . AddEquipment ( new HardDisk ( 2021 , 30000 , 80 )); ei . AddEquipment ( new HardDisk ( 2020 , 25000 , 120 )); ei . AddEquipment ( new HardDisk ( 2020 , 25000 , 250 )); ei . AddEquipment ( new SoundCard ( 2021 , 8000 )); ei . AddEquipment ( new SoundCard ( 2020 , 7000 )); ei . AddEquipment ( new SoundCard ( 2020 , 6000 )); ei . ListAll (); } Az alkalmaz\u00e1st futtatva azt tapasztaljuk, hogy b\u00e1r megold\u00e1sunk kezdetleges, de m\u0171k\u00f6dik: Folytassuk a munk\u00e1t a LedDisplay oszt\u00e1llyal. A DisplayBase \u0151s forr\u00e1sk\u00f3dj\u00e1t a k\u00f6vetelm\u00e9nyek miatt nem m\u00f3dos\u00edthatjuk. De ez semmif\u00e9le probl\u00e9m\u00e1t nem okoz, a LedDisplay oszt\u00e1lyunk fogja az IEquipment interf\u00e9szt implement\u00e1lni, m\u00f3dos\u00edtsuk a k\u00f3dot ennek megfelel\u0151en: public class LedDisplay : DisplayBase , IEquipment A LedDisplay oszt\u00e1lyban m\u00e1r meg kell \u00edrni az interf\u00e9szben szerepl\u0151 f\u00fcggv\u00e9nyeket: public double GetPrice () { return this . price ; } public int GetAge () { return DateTime . Today . Year - this . manufacturingYear ; } B\u0151v\u00edts\u00fck a Main f\u00fcggv\u00e9ny\u00fcnket is, vegy\u00fcnk fel k\u00e9t LedDisplay objektumot a k\u00e9szlet\u00fcnkbe (itt is \u00e9l, hogy ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra! ei . AddEquipment ( new LedDisplay ( 2020 , 80000 , 17 , 16 ) ); ei . AddEquipment ( new LedDisplay ( 2021 , 70000 , 17 , 12 ) ); ei . ListAll (); Console . ReadKey (); Tesztel\u00e9sk\u00e9ppen futtassuk az alkalmaz\u00e1st. 3. Feladat - Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja \u00b6 Interf\u00e9sz problematik\u00e1ja \u00b6 \u00c9rt\u00e9kelj\u00fck a jelenlegi, interf\u00e9sz alap\u00fa megold\u00e1sunkat. Az egyik f\u0151 probl\u00e9ma, hogy k\u00f3dunk tele van a karbantarthat\u00f3s\u00e1got \u00e9s b\u0151v\u00edthet\u0151s\u00e9get rombol\u00f3 k\u00f3dduplik\u00e1ci\u00f3val: A yearOfCreation \u00e9s newPrice tagok minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis LedDisplay -t) k\u00f6z\u00f6sek, ezeket \u00faj t\u00edpus bevezet\u00e9sekor is copy-paste technik\u00e1val \u00e1t kell venni. A GetAge f\u00fcggv\u00e9ny implement\u00e1ci\u00f3ja szinten minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis LedDisplay -t) azonos, szint\u00e9n copy-paste-tel \u201eszapor\u00edtand\u00f3\u201d. A konstruktorok yearOfCreation \u00e9s newPrice tagokat inicializ\u00e1l\u00f3 sorai szint\u00e9n duplik\u00e1ltak az egyes oszt\u00e1lyokban. B\u00e1r ez a k\u00f3dduplik\u00e1ci\u00f3 egyel\u0151re nem t\u0171nik jelent\u0151snek, \u00faj alkatr\u00e9sz t\u00edpusok bevezet\u00e9s\u00e9vel egyre ink\u00e1bb elm\u00e9rgesedik a helyzet, jobb id\u0151ben elej\u00e9t venni a j\u00f6v\u0151beli f\u00e1jdalmaknak. A m\u00e1sik probl\u00e9ma abb\u00f3l ad\u00f3dik, hogy az alkatr\u00e9sz adatok list\u00e1z\u00e1sa jelenleg f\u00e1jdalmasan hi\u00e1nyos, nem jelenik meg az alkatr\u00e9sz t\u00edpusa (csak a kora \u00e9s az \u00e1ra). A t\u00edpus megjelen\u00edt\u00e9s\u00e9hez az IEquipment interf\u00e9szt b\u0151v\u00edteni kell, pl. egy GetDescription nev\u0171 m\u0171velet bevezet\u00e9s\u00e9vel. Vegy\u00fcnk is fel egy GetDescription f\u00fcggv\u00e9nyt az interf\u00e9szbe! public interface IEquipment { double GetPrice (); int GetAge (); string GetDescription (); } Ekkor minden IEquipment interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban meg kellene val\u00f3s\u00edtani ezt a met\u00f3dust is, ami sok oszt\u00e1ly eset\u00e9n sok munka (valamint egy t\u00f6bbkomponens\u0171, vagyis t\u00f6bb DLL-b\u0151l \u00e1ll\u00f3 alkalmaz\u00e1s eset\u00e9ben, amikor ezek nem egy fejleszt\u0151 c\u00e9g kez\u00e9ben vannak, sokszor nem is megoldhat\u00f3). A Build parancs futtat\u00e1s\u00e1val ellen\u0151rizz\u00fck, hogy a GetDescription felv\u00e9tele ut\u00e1n h\u00e1rom helyen is ford\u00edt\u00e1si hib\u00e1t kapunk. Interf\u00e9szben alap\u00e9rtelmezett implement\u00e1ci\u00f3 megad\u00e1sa \u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja . B\u0151vebben inform\u00e1ci\u00f3 itt: default interface methods . public interface IEquipment { double GetPrice (); int GetAge (); string GetDescription () { return \"EquipmentBase\" ; } } Absztrakt oszt\u00e1ly \u00b6 Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelent egy k\u00f6z\u00f6s absztrakt \u0151s bevezet\u00e9se (kiv\u00e9ve az LedDiplay oszt\u00e1lyt, amire m\u00e9g visszat\u00e9r\u00fcnk). Ebbe fel tudjuk k\u00f6lt\u00f6ztetni a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot, valamint az \u00fajonnan bevezetett GetDescription m\u0171velethez egy alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni. Legyen az \u00faj absztrakt \u0151soszt\u00e1lyunk neve EquipmentBase . K\u00e9rd\u00e9s, sz\u00fcks\u00e9g van-e a tov\u00e1bbiakban az IEquipment interf\u00e9szre, vagy az teljesen kiv\u00e1lthat\u00f3 az \u00faj EquipmentBase oszt\u00e1llyal. Az IEquipment interf\u00e9szt meg kell tartsuk, mert a LedDisplay oszt\u00e1lyunkat nem tudjuk az EquipmentBase -b\u0151l sz\u00e1rmaztatni: m\u00e1r van egy k\u00f6telez\u0151en el\u0151\u00edrt \u0151soszt\u00e1lya, a DisplayBase : emiatt az EquipmentInventory a tov\u00e1bbfejlesztett megold\u00e1sunkban is IEquipment interf\u00e9szk\u00e9nt hivatkozik az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szekre. \u00c1lljunk is neki az \u00e1talak\u00edt\u00e1snak. Legyen az oszt\u00e1lydiagramunk az akt\u00edv tabf\u00fcl. A Toolbox -b\u00f3l drag&drop-pal dobjunk fel egy Abstract Class elemet a diagramra, a neve legyen EquipmentBase . A k\u00f6vetkez\u0151kben azt kell el\u00e9rj\u00fck, hogy a SoundCard \u00e9s a HardDisk oszt\u00e1lyok sz\u00e1rmazzanak az EquipmentBase -b\u0151l (a LedDisplay -nek m\u00e1r van m\u00e1sik \u0151se, \u00edgy ott ezt nem tudjuk megtenni). Ehhez v\u00e1lasszuk ki az Inheritance kapcsolatot a Toolbox -ban, majd h\u00fazzunk egy-egy vonalat a gyermekoszt\u00e1lyb\u00f3l kiindulva az \u0151soszt\u00e1lyba a SoundCard \u00e9s HardDisk eset\u00e9ben egyar\u00e1nt. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben alak\u00edtsuk \u00e1t \u00fagy a k\u00f3dot, hogy ne a HardDisk \u00e9s SoundCard val\u00f3s\u00edts\u00e1k meg k\u00fcl\u00f6n-k\u00fcl\u00f6n az IEquipment interf\u00e9szt, hanem a k\u00f6z\u00f6s \u0151s\u00fck, az EquipmentBase egyszer. Ehhez m\u00f3dos\u00edtsuk az EquipmentBase oszt\u00e1lyt \u00fagy, hogy val\u00f3s\u00edtsa meg az interf\u00e9szt (ak\u00e1r a diagramon h\u00fazzunk be egy inheritance kapcsolatot az EquipmentBase -b\u0151l az IEquipment -be, vagy az EquipmentBase forr\u00e1sk\u00f3dj\u00e1t m\u00f3dos\u00edtsuk). A HardDisk \u00e9s SoundCard oszt\u00e1lyokb\u00f3l t\u00f6r\u00f6lj\u00fck az IEquipment megval\u00f3s\u00edt\u00e1s\u00e1t (az \u0151s m\u00e1r implement\u00e1lja). A diagramunk \u00e9s a forr\u00e1sk\u00f3dunk vonatkoz\u00f3 r\u00e9szei ezt k\u00f6vet\u0151en \u00edgy n\u00e9znek ki: public abstract class EquipmentBase : IEquipment public class HardDisk : EquipmentBase public class SoundCard : EquipmentBase A k\u00f3dunk m\u00e9g nem fordul, ennek t\u00f6bb oka is van. Az EquipmentBase implement\u00e1lja az IEquipment interf\u00e9szt, de m\u00e9g nincsenek benne implement\u00e1lva az interf\u00e9sz m\u0171veletei. Vagy gener\u00e1ltassuk le a met\u00f3dusokat a smart tag haszn\u00e1lat\u00e1val, vagy g\u00e9pelj\u00fck be a k\u00f6vetkez\u0151 elveknek megfelel\u0151en: A newPrice \u00e9s yearOfCreation duplik\u00e1lva vannak a HardDisk \u00e9s SoundCard oszt\u00e1lyokban: mozgassuk (\u00e9s ne m\u00e1soljuk!) \u00e1t ezeket a k\u00f6z\u00f6s EquipmentBase \u0151sbe, \u00e9s protected l\u00e1that\u00f3s\u00e1got adjunk meg. A GetAge m\u0171velet duplik\u00e1lva van a HardDisk \u00e9s SoundCard oszt\u00e1lyokban, ezekb\u0151l t\u00f6r\u00f6lj\u00fck ki az implement\u00e1ci\u00f3t \u00e9s vigy\u00fck \u00e1t az EquipmentBase oszt\u00e1lyba. A GetPrice m\u0171veletet absztrakt m\u0171veletk\u00e9nt vegy\u00fck fel az \u0151sbe. Ez sz\u00e1nd\u00e9kos tervez\u0151i d\u00f6nt\u00e9s, \u00edgy r\u00e1k\u00e9nyszer\u00edtj\u00fck a lesz\u00e1rmazott oszt\u00e1lyokat, hogy mindenk\u00e9ppen defini\u00e1lj\u00e1k fel\u00fcl ezt a m\u0171veletet. A GetDescription eset\u00e9ben viszont pont ford\u00edtottja a helyzet: ezt virtu\u00e1lisnak defini\u00e1ljuk (\u00e9s nem absztraktnak), vagyis m\u00e1r az \u0151sben is adunk meg implement\u00e1ci\u00f3t. \u00cdgy a lesz\u00e1rmazottak nincsenek r\u00e1k\u00e9nyszer\u00edtve a m\u0171velet fel\u00fcldefini\u00e1l\u00e1s\u00e1ra. A fentieknek megfelel\u0151 k\u00f3d a k\u00f6vetkez\u0151: public abstract class EquipmentBase : IEquipment { protected int yearOfCreation ; protected int newPrice ; public int GetAge () { return DateTime . Today . Year - yearOfCreation ; } public abstract double GetPrice (); public virtual string GetDescription () { return \"EquipmentBase\" ; } } N\u00e9h\u00e1ny kieg\u00e9sz\u00edt\u0151 gondolat a k\u00f3dr\u00e9szletre vonatkoz\u00f3an: Az absztrakt oszt\u00e1lyok eset\u00e9ben az abstract kulcssz\u00f3t ki kell \u00edrni a class sz\u00f3 el\u00e9. Az absztrakt m\u0171veletek eset\u00e9ben az abstract kulcssz\u00f3t kell megadni .NET k\u00f6rnyezetben lehet\u0151s\u00e9g\u00fcnk van szab\u00e1lyozni, hogy egy m\u0171velet virtu\u00e1lis-e vagy sem. Ebb\u0151l a szempontb\u00f3l a C++ nyelvhez hasonl\u00edt. Amennyiben egy m\u0171veletet virtu\u00e1liss\u00e1 szeretn\u00e9nk tenni, a virtual kulcssz\u00f3t kell a m\u0171veletre megadni. Eml\u00e9keztet\u0151: akkor defini\u00e1ljunk egy m\u0171veletet virtu\u00e1lisnak, ha a lesz\u00e1rmazottak azt fel\u00fcldefini\u00e1l(hat)j\u00e1k. Csak ekkor garant\u00e1lt, hogy egy \u0151sreferenci\u00e1n megh\u00edvva az adott m\u0171veletet a lesz\u00e1rmazottbeli verzi\u00f3 h\u00edv\u00f3dik meg. Lesz\u00e1rmazottak \u00b6 A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t az EquipmentBase lesz\u00e1rmazottakra. C# nyelven az absztrakt \u00e9s virtu\u00e1lis m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor a lesz\u00e1rmazottban meg kell adni az override kulcssz\u00f3t. Els\u0151 l\u00e9p\u00e9sben a GetPrice m\u0171veletet defini\u00e1ljuk fel\u00fcl: HardDisk.cs public override double GetPrice () { return yearOfCreation < ( DateTime . Today . Year - 4 ) ? 0 : newPrice - ( DateTime . Today . Year - yearOfCreation ) * 5000 ; } SoundCard.cs public override double GetPrice () { return yearOfCreation < ( DateTime . Today . Year - 4 ) ? 0 : newPrice - ( DateTime . Today . Year - yearOfCreation ) * 2000 ; } A k\u00f6vetkez\u0151kben l\u00e9p\u00e9sben a GetDescription m\u0171veletet \u00edrjuk meg a HardDisk \u00e9s SoundCard oszt\u00e1lyokban. Mivel itt az \u0151sbeli virtu\u00e1lis f\u00fcggv\u00e9nyt defini\u00e1ljuk fel\u00fcl, szint\u00e9n meg kell adni az override kulcssz\u00f3t: HardDisk.cs public override string GetDescription () { return \"Hard Disk\" ; } SoundCard.cs public override string GetDescription () { return \"Sound Card\" ; } Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, mi\u00e9rt d\u00f6nt\u00f6ttek \u00fagy a C# nyelv tervez\u0151i, hogy a m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor egy extra kulcssz\u00f3t kelljen megadni, hasonl\u00f3ra pl. a C++ nyelv eset\u00e9ben nem volt sz\u00fcks\u00e9g. Az ok egyszer\u0171: a k\u00f3d \u00edgy kifejez\u0151bb. A lesz\u00e1rmazottak k\u00f3dj\u00e1t n\u00e9zve az override sz\u00f3 azonnal egy\u00e9rtelm\u0171v\u00e9 teszi, hogy valamelyik \u0151sben ez a m\u0171velet absztrakt vagy virtu\u00e1lis, nem kell valamennyi \u0151s k\u00f3dj\u00e1t ehhez \u00e1ttekinteni. LedDisplay \u0151se \u00b6 A LedDisplay oszt\u00e1lyunk \u0151se meg van k\u00f6tve, annak k\u00f3dja nem m\u00f3dos\u00edthat\u00f3, \u00edgy nem tudjuk az EquipmentBase -b\u0151l sz\u00e1rmaztatni. A GetAge m\u0171veletet \u00edgy nem tudjuk t\u00f6r\u00f6lni, ez a k\u00f3dduplik\u00e1ci\u00f3 itt megmarad (de csak a LedDisplay eset\u00e9ben, ami csak egy oszt\u00e1ly a sok k\u00f6z\u00fcl!). Note Val\u00f3j\u00e1ban egy kis plusz munk\u00e1val ett\u0151l a duplik\u00e1ci\u00f3t\u00f3l is meg tudn\u00e1nk szabadulni. Ehhez valamelyik oszt\u00e1lyban (pl. EquipmentBase ) fel kellene venni egy statikus seg\u00e9df\u00fcggv\u00e9nyt, mely param\u00e9terben megkapn\u00e1 a gy\u00e1rt\u00e1si \u00e9vet, \u00e9s visszaadn\u00e1 az \u00e9letkort. Az EquipmentBase.GetAge \u00e9s a LedDisplay.GetAge ezt a seg\u00e9df\u00fcggv\u00e9nyt haszn\u00e1ln\u00e1 kimenete el\u0151\u00e1ll\u00edt\u00e1s\u00e1ra. A LedDisplay oszt\u00e1lyunkban ad\u00f3sak vagyunk m\u00e9g a GetDescription meg\u00edr\u00e1s\u00e1val: LedDisplay.cs public string GetDescription () { return \"Led Display\" ; } Figyelj\u00fck meg, hogy itt NEM adtuk meg az override kulcssz\u00f3t. Mikor egy interf\u00e9sz f\u00fcggv\u00e9nyt implement\u00e1lunk, az override -ot nem kell/szabad ki\u00edrni. GetDescription haszn\u00e1lata \u00b6 M\u00f3dos\u00edtsuk az EquipmentInventory.ListAll m\u0171velet\u00e9t, hogy az elemek le\u00edr\u00e1s\u00e1t is \u00edrja ki a kimenetre: EquipmentInventory.cs public void ListAll () { foreach ( IEquipment eq in equipment ) { Console . WriteLine ( $\"Le\u00edr\u00e1s: {eq.GetDescription()}\\t\" + $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\" ); } } \u00cdgy m\u00e1r sokkal informat\u00edvabb kimetet kapunk az alkalmaz\u00e1s futtat\u00e1sakor: Konstruktor k\u00f3dduplik\u00e1ci\u00f3 \u00b6 A k\u00f3dunkat \u00e1ttekintve m\u00e9g egy helyen tal\u00e1lunk k\u00f3dduplik\u00e1ci\u00f3t. Valamennyi EquipmentBase lesz\u00e1rmazott ( HardDisk , SoundCard ) konstruktor\u00e1ban ott van ez a k\u00e9t sor: this . yearOfCreation = yearOfCreation ; this . newPrice = newPrice ; Ha belegondolunk, ezek a yearOfCreatio \u00e9s newPrice tagok az \u0151sben vannak defini\u00e1lva, \u00edgy egy\u00e9bk\u00e9nt is az \u0151 felel\u0151ss\u00e9ge kellene legyen ezek inicializ\u00e1l\u00e1sa. Vegy\u00fcnk is fel egy megfelel\u0151 konstruktort az EquipmentBase -ben: EquipmentBase.cs public EquipmentBase ( int yearOfCreation , int newPrice ) { this . yearOfCreation = yearOfCreation ; this . newPrice = newPrice ; } A HardDisk \u00e9s SoundCard lesz\u00e1rmazottak konstruktor\u00e1nak t\u00f6rzs\u00e9b\u0151l vegy\u00fck ki a k\u00e9t tag inicializ\u00e1l\u00e1s\u00e1t, helyette a base kulcssz\u00f3val hivatkozva h\u00edvjuk meg az \u0151s konstruktor\u00e1t: HardDisk.cs public HardDisk ( int yearOfCreation , int newPrice , int capacityGB ) : base ( yearOfCreation , newPrice ) { this . capacityGB = capacityGB ; } SoundCard.cs public SoundCard ( int yearOfCreation , int newPrice ) : base ( yearOfCreation , newPrice ) { } \u00c9rt\u00e9kel\u00e9s \u00b6 Az interf\u00e9sz \u00e9s absztrakt \u0151s egy\u00fcttes haszn\u00e1lat\u00e1val siker\u00fclt a legkevesebb kompromisszummal j\u00e1r\u00f3 megold\u00e1st kidolgoznunk: IEquipment interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk kezelni az alkatr\u00e9szek valamennyi t\u00edpus\u00e1t, m\u00e9g azokat is, melyekn\u00e9l az \u0151soszt\u00e1ly meg volt k\u00f6tve (puszt\u00e1n absztrakt \u0151s haszn\u00e1lat\u00e1val ezt nem tudtuk volna el\u00e9rni). Az EquipmentBase absztrakt \u0151s bevezet\u00e9s\u00e9vel egy kiv\u00e9telt\u0151l eltekintve a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szt\u00edpusokra k\u00f6z\u00f6s k\u00f3dot fel tudtuk vinni egy k\u00f6z\u00f6s \u0151sbe, \u00edgy el tudtuk ker\u00fclni a k\u00f3dduplik\u00e1ci\u00f3t. Az EquipmentBase absztrakt \u0151s bevezet\u00e9s\u00e9vel alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni az \u00fajonnan bevezetett IEquipment m\u0171veletek eset\u00e9ben (pl. GetDescripton ), \u00edgy nem vagyunk r\u00e1k\u00e9nyszer\u00edtve, hogy minden IEquipment implement\u00e1ci\u00f3s oszt\u00e1lyban meg kelljen azt adni. Z\u00e1r\u00e1sk\u00e9ppen vess\u00fcnk egy pillant\u00e1st megold\u00e1sunk UML (szer\u0171) oszt\u00e1lydiagramj\u00e1ra: Statikus interf\u00e9szek A C# 11 leg\u00fajabb \u00fajdons\u00e1ga a statikus interf\u00e9sz tagok defini\u00e1l\u00e1sa, amivel olyan tagokat k\u00f6vetelhet\u00fcnk meg az implement\u00e1l\u00f3 oszt\u00e1lyt\u00f3l, amelyek nem az objektum p\u00e9ld\u00e1nyra vonatkoznak, hanem az oszt\u00e1lynak kell egy adott statikus taggal rendelkeznie. B\u0151vebben Megjegyz\u00e9s - opcion\u00e1lis h\u00e1zi gyakorl\u00f3 feladat \u00b6 Jelen megold\u00e1sunk nem t\u00e1mogatja az alkatr\u00e9szspecifikus adatok (pl. HardDisk eset\u00e9ben a kapacit\u00e1s) megjelen\u00edt\u00e9s\u00e9t a list\u00e1z\u00e1s sor\u00e1n. Ahhoz, hogy ezt meg tudjuk tenni, az alkatr\u00e9sz adatok form\u00e1zott stringbe \u00edr\u00e1s\u00e1t az EqipmentInventory oszt\u00e1lyb\u00f3l az alkatr\u00e9sz oszt\u00e1lyokba kellene vinni, a k\u00f6vetkez\u0151 elveknek megfelel\u0151en: Bevezethet\u00fcnk ehhez az IEquipment interf\u00e9szbe egy GetFormattedString m\u0171veletet, mely egy string t\u00edpus\u00fa objektummal t\u00e9r vissza. Alternat\u00edv megold\u00e1s lehet, ha a System.Object ToString() m\u0171velet\u00e9t defini\u00e1ljuk fel\u00fcl. .NET-ben ugyanis minden t\u00edpus implicit m\u00f3don a System.Object -b\u0151l sz\u00e1rmazik, aminek van egy virtu\u00e1lis ToString() m\u0171velete. Az EquipmentBase -ben meg\u00edrjuk a k\u00f6z\u00f6s tagok (le\u00edr\u00e1s, \u00e1r, kor) stringbe form\u00e1z\u00e1s\u00e1t. Amennyiben egy alkatr\u00e9sz t\u00edpusspecifikus adattal is rendelkezik, akkor oszt\u00e1ly\u00e1ban override-oljuk a stringbe form\u00e1z\u00f3 f\u00fcggv\u00e9nyt: ennek a f\u00fcggv\u00e9nynek egyr\u00e9szt meg kell h\u00edvnia az \u0151s v\u00e1ltozat\u00e1t (a base kulcssz\u00f3 haszn\u00e1lat\u00e1val), majd ehhez hozz\u00e1 kell f\u0171zni a saj\u00e1t form\u00e1zott adatait, \u00e9s ezzel a stringgel kell visszat\u00e9rnie.","title":"1. A modell \u00e9s a k\u00f3d kapcsolata"},{"location":"labor/1-model-es-kod-kapcsolata/#1-a-modell-es-a-kod-kapcsolata","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n","title":"1. A modell \u00e9s a k\u00f3d kapcsolata"},{"location":"labor/1-model-es-kod-kapcsolata/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja: Ismerked\u00e9s a hallgat\u00f3kkal/gyakorlatvezet\u0151vel A gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyek pontos\u00edt\u00e1sa Elindul\u00e1s Visual Studio-val \u00e9s .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9vel. Egy egyszer\u0171 Hello World .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja Gyakorlatvezet\u0151knek A hallgat\u00f3k kor\u00e1bbi tanulm\u00e1nyaik sor\u00e1n C++ gyakorlaton m\u00e1r haszn\u00e1lt\u00e1k a Visual Studio k\u00f6rnyezet, \u00edgy a c\u00e9l jelen esetben az ismeretek feleleven\u00edt\u00e9se \u00e9s \u00e9let\u00fcnk els\u0151 C# alkalmaz\u00e1s\u00e1nak elk\u00e9sz\u00edt\u00e9se. Ugyanakkor el\u0151fordulhat, hogy a hallgat\u00f3k nem eml\u00e9keznek pontosan a Visual Studio haszn\u00e1lat\u00e1ra, \u00edgy a feladatok megold\u00e1sa sor\u00e1n ezeket folyamatosan eleven\u00edts\u00fck fel (pl. Solution Explorer, F5-futtat\u00e1s, breakpoint haszn\u00e1lat, stb.)","title":"A gyakorlat c\u00e9lja"},{"location":"labor/1-model-es-kod-kapcsolata/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Visual Studio-b\u00f3l a legfrissebb verzi\u00f3t c\u00e9lszer\u0171 feltenni. A Community Edition, Professional \u00e9s az Enterprise verzi\u00f3 is megfelel. A Community Edition ingyenes, let\u00f6lthet\u0151 a Microsoft honlapj\u00e1r\u00f3l. A Professional fizet\u0151s, de az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ez is ingyenesen el\u00e9rhet\u0151 ( https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben). Visual Studio Class Diagram t\u00e1mogat\u00e1s Jelen gyakorlat bizonyos feladatain\u00e1l (\u00e9s az els\u0151 h\u00e1zi feladat eset\u00e9ben is) a Visual Studio Class Designer t\u00e1mogat\u00e1s\u00e1t haszn\u00e1ljuk. A Visual Studio nem teszi fel minden esetben a Class Designer komponenst a telep\u00edt\u00e9s sor\u00e1n. Ha nem lehet Class Diagram-ot felvenni a Visual Studio projektbe (mert a Class Diagram nem szerepel a list\u00e1ban az Add New Item parancs sor\u00e1n megjelen\u0151 ablak list\u00e1j\u00e1ban \u2013 err\u0151l a jelen \u00fatmutat\u00f3 k\u00e9s\u0151bbi fejezet\u00e9ben b\u0151vebben), akkor a Class Diagram komponenst ut\u00f3lag kell telep\u00edteni: Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel). A megjelen\u0151 ablakban \u201eIndividual components\u201d f\u00fcl kiv\u00e1laszt\u00e1sa A keres\u0151mez\u0151be \u201eclass designer\u201d beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \u201eClass Designer\u201d elem ki van pip\u00e1lva. Amit \u00e9rdemes \u00e1tn\u00e9zned: A gyakorlathoz nem kapcsol\u00f3dik a t\u00e1rgyb\u00f3l el\u0151ad\u00e1s. Ugyanakkor a gyakorlat \u00e9p\u00edt az UML alapismeretekre, illetve az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d egym\u00e1sra t\u00f6rt\u00e9n\u0151 lek\u00e9pez\u00e9s\u00e9nek alapjaira.","title":"El\u0151felt\u00e9telek"},{"location":"labor/1-model-es-kod-kapcsolata/#gyakorlat-menete","text":"A gyakorlatvezet\u0151 a gyakorlat elej\u00e9n \u00f6sszefoglalja a gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyeket: A t\u00e1rgyi adatlapon ezek t\u00f6bbs\u00e9ge megtal\u00e1lhat\u00f3 Az otthoni feladatokr\u00f3l inform\u00e1ci\u00f3 a t\u00e1rgy honlapj\u00e1n tal\u00e1lhat\u00f3. Visual Studio fejleszt\u0151eszk\u00f6zzel, .NET alkalmaz\u00e1sokat fogunk k\u00e9sz\u00edteni C# nyelven. A C# hasonl\u00edt a Java-hoz, fokozatosan ismerj\u00fck meg a k\u00fcl\u00f6nbs\u00e9geket. A gyakorlat vezetett, gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok.","title":"Gyakorlat menete"},{"location":"labor/1-model-es-kod-kapcsolata/#1-feladat-hello-world-net-konzol-alkalmazas-elkeszitese","text":"A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely a konzolra ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget. Az alkalmaz\u00e1st C# nyelven k\u00e9sz\u00edtj\u00fck el. A leford\u00edtott alkalmaz\u00e1s futtat\u00e1s\u00e1t a .NET runtime v\u00e9gzi. A ford\u00edt\u00e1s/futtat\u00e1s elm\u00e9leti h\u00e1tter\u00e9t, valamint a .NET alapjait az els\u0151 el\u0151ad\u00e1s ismerteti. A solution \u00e9s azon bel\u00fcli projekt l\u00e9trehoz\u00e1s\u00e1nak l\u00e9p\u00e9sei Visual Studio 2022 eset\u00e9n: \u00daj projekt var\u00e1zsl\u00f3 elind\u00edt\u00e1sa, melyre k\u00e9t m\u00f3d is van Ind\u00edt\u00f3ablak seg\u00edts\u00e9g\u00e9vel Ind\u00edtsuk el a Visual Studio-t A megjelen\u0151 ind\u00edt\u00f3ablak jobb oldali s\u00e1vj\u00e1ban Create new project M\u00e1r fut\u00f3 Visual Studio-ban File / New-Project A Create new project var\u00e1zsl\u00f3ban a Console app (\u00e9s NEM a Console app (.NET Framework) sablont v\u00e1lasszuk ki, ebb\u0151l is a C#-osat. Azt, hogy C#-os, a sablon ikonj\u00e1nak bal fels\u0151 sarka jelzi. Ha nem l\u00e1tjuk a list\u00e1ban, r\u00e1 kell keresni/sz\u0171rni. R\u00e1kereshet\u00fcnk a fels\u0151 keres\u0151s\u00e1vban a \u201econsole\u201d be\u00edr\u00e1s\u00e1val. Vagy az alatta lev\u0151 leny\u00edl\u00f3 mez\u0151k seg\u00edts\u00e9g\u00e9vel: az els\u0151ben (nyelvkiv\u00e1laszt\u00f3) \u201eC#\u201d, a harmadikban (projektt\u00edpus kiv\u00e1laszt\u00f3) \u201eConsole\u201d. Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon: Project name: Hello World Location: a laborokban a c:\\work\\ mapp\u00e1ba dolgozzunk, ehhez van \u00edr\u00e1si jogunk. Solution name: Hello World (elvileg ez be is lesz \u00edrva, mire ide\u00e9r\u00fcnk) Place solution and project in the same directory: nincs pipa (de nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge). Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon: Framework: .NET 6 (Long-term support) . A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be (ennek magyar\u00e1zat\u00e1ra mindj\u00e1rt visszat\u00e9r\u00fcnk). A projekttel egy \u00faj solution is l\u00e9trej\u00f6n, mely strukt\u00far\u00e1ja a Visual Studio Solution Explorer ablak\u00e1ban tekinthet\u0151 \u00e1t. Egy solution t\u00f6bb projectb\u0151l \u00e1llhat, egy project pedig t\u00f6bb f\u00e1jlb\u00f3l. A solution a teljes munkak\u00f6rnyezetet fogja \u00f6ssze (egy .sln kiterjeszt\u00e9s\u0171 f\u00e1jl tartozik hozz\u00e1), m\u00edg egy projekt kimenete egy .exe vagy .dll f\u00e1jl jellemz\u0151en, vagyis egy \u00f6sszetett alkalmaz\u00e1s/rendszer egy komponens\u00e9t \u00e1ll\u00edtja el\u0151. A projektf\u00e1jlok kiterjeszt\u00e9se C# alkalmaz\u00e1sok eset\u00e9n .csproj . A Program.cs f\u00e1jlunk tartalma a k\u00f6vetkez\u0151: Program.cs namespace HelloWorld { internal class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); } } } Vegy\u00fcnk fel egy Console.ReadKey() sort: namespace HelloWorld { internal class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); Console . ReadKey (); } } } Futtassuk az alkalmaz\u00e1st (pl. az F5 billenty\u0171 haszn\u00e1lat\u00e1val). A k\u00f3d fel\u00e9p\u00edt\u00e9se nagyon hasonl\u00edt a Java-hoz, illetve a C++-hoz. Az oszt\u00e1lyaink n\u00e9vterekbe szervezettek. N\u00e9vteret defini\u00e1lni a namespace kulcssz\u00f3val tudunk. N\u00e9vtereket hat\u00f3k\u00f6rbe \u201ehozni\u201d a using kulcssz\u00f3val tudjuk. pl.: using System.Collections.Generic ; Egy konzolos C# alkalmaz\u00e1sban az alkalmaz\u00e1sunk bel\u00e9p\u00e9si pontj\u00e1t egy statikus Main nev\u0171 f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1val adjuk meg. Az oszt\u00e1lyunk neve b\u00e1rmi lehet, a VS egy Program nev\u0171 oszt\u00e1lyt gener\u00e1lt eset\u00fcnkben. A Main f\u00fcggv\u00e9ny param\u00e9terlist\u00e1ja k\u00f6t\u00f6tt: vagy ne adjunk meg param\u00e9tereket, vagy egy string[] -\u00f6t adjunk meg, amiben fut\u00e1s k\u00f6zben megkapjuk az parancssori argumentumokat. .NET-ben a standard ki \u00e9s bemenet kezel\u00e9s\u00e9re a System n\u00e9vt\u00e9r Console oszt\u00e1lya haszn\u00e1land\u00f3. A WriteLine statikus m\u0171velet\u00e9vel egy sort tudunk ki\u00edrni, a ReadKey m\u0171velettel egy billenty\u0171 lenyom\u00e1s\u00e1ra v\u00e1rakozhatunk. Top level statements, Implicit \u00e9s static usings \u00e9s n\u00e9vterek A projekt l\u00e9trehoz\u00e1sakor kor\u00e1bban bepip\u00e1ltuk a \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet. Ha ezt nem tett\u00fck volna meg, akkor a Program.cs f\u00e1jlunkban mind\u00f6ssze egyetlen \u00e9rdemi sort tal\u00e1ltunk volna: // See https://aka.ms/new-console-template for more information Console . WriteLine ( \"Hello World!\" ); Ez m\u0171k\u00f6d\u00e9s\u00e9ben ekvivalens a fenti Program oszt\u00e1lyt \u00e9s ebben Main f\u00fcggv\u00e9nyt tartalmaz\u00f3 k\u00f3ddal. N\u00e9zz\u00fck, mik teszik ezt lehet\u0151v\u00e9 (ezekr\u0151l pl. itt https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements olvashatunk b\u0151vebben, mindkett\u0151 C# 10 \u00fajdons\u00e1g): Top level statements . Ennek az a l\u00e9nyege, hogy mindenf\u00e9le oszt\u00e1ly/ Main \u00e9s egy\u00e9b f\u00fcggv\u00e9nydefin\u00edci\u00f3 n\u00e9lk\u00fcl a projektben egyetlen forr\u00e1sf\u00e1jlban k\u00f6zvetlen\u00fcl is \u00edrhatunk k\u00f3dot. Ez esetben ezt a sz\u00ednfalak m\u00f6g\u00f6tt a ford\u00edt\u00f3 berakja egy \u00e1ltalunk nem l\u00e1that\u00f3 oszt\u00e1ly statikus Main f\u00fcggv\u00e9ny\u00e9be. A bevezet\u00e9s\u00e9nek a motiv\u00e1ci\u00f3ja az volt, hogy a nagyon egyszer\u0171, \u201escript\u201d szer\u0171 alkalmaz\u00e1sok eset\u00e9n kevesebb legyen a boilerplate k\u00f3d. Implicit global usings . Annak f\u00fcggv\u00e9ny\u00e9ben, hogy pontosan milyen projektt\u00edpust hoztunk l\u00e9tre, bizonyos alapn\u00e9vterek a sz\u00ednfalak m\u00f6g\u00f6tt automatikusan using-olva lesznek minden forr\u00e1sf\u00e1jlban (ehhez a compiler a global using utas\u00edt\u00e1st haszn\u00e1lja). A l\u00e9nyeg: a fejleszt\u0151knek \u00edgy bizonyos, gyakran haszn\u00e1lt n\u00e9vtereket (pl. System.IO , System.Collections.Generic stb.) nem kell a forr\u00e1sf\u00e1jlonk\u00e9nt using-olni. Static using . Lehet\u0151s\u00e9g\u00fcnk van C#-ban n\u00e9vterek helyett statikus oszt\u00e1lyokat is usingolni, \u00edgy azokat a haszn\u00e1latuk sor\u00e1n nem fontos ki\u00edrni. Gyakori eset erre a Console vagy a Math oszt\u00e1ly usingol\u00e1sa. using static System . Console ; namespace ConsoleApp12 { internal class Program { static void Main ( string [] args ) { WriteLine ( \"Hello, World!\" ); } } } F\u00e1jl szint\u0171 n\u00e9vterek . C# 10-ben szint\u00e9n egy egyszer\u0171s\u00edt\u00e9st kapunk a n\u00e9vterek deklar\u00e1l\u00e1sa sor\u00e1n, mert m\u00e1r nem k\u00f6telez\u0151 a kapcsos z\u00e1r\u00f3jeleket kitenni, \u00edgy az adott namespace a teljes f\u00e1jlra \u00e9rv\u00e9nyes lesz pl.: namespace HelloWorld ; internal class Program { // ... } Inconsistent visibility vagy inconsistent accessibility hiba A f\u00e9l\u00e9v sor\u00e1n a programoz\u00e1si feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n tal\u00e1lkozhatunk inconsistent visibility -re vagy inconsistent accessibility -re panaszkod\u00f3 ford\u00edt\u00e1si hiba\u00fczenetekkel. A jelens\u00e9g h\u00e1tter\u00e9ben az \u00e1ll, hogy .NET k\u00f6rnyezetben lehet\u0151s\u00e9g van az egyes t\u00edpusok (oszt\u00e1ly, interf\u00e9sz, stb.) l\u00e1that\u00f3s\u00e1g\u00e1nak szab\u00e1lyoz\u00e1s\u00e1ra: internal vagy nem adjuk meg a l\u00e1that\u00f3s\u00e1got: a t\u00edpus csak az adott szerelv\u00e9nyen (.exe, .dll)/projekten, bel\u00fcl l\u00e1that\u00f3 public : a t\u00edpus m\u00e1s szerelv\u00e9nyek/projektek sz\u00e1m\u00e1ra is l\u00e1that\u00f3 A hiba legegyszer\u0171bben \u00fagy h\u00e1r\u00edthat\u00f3 el, ha minden t\u00edpusunkat publikusnak defini\u00e1ljuk, pl.: public class HardDisk { // ... }","title":"1. Feladat - \u201eHello world\u201d .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se"},{"location":"labor/1-model-es-kod-kapcsolata/#elmeleti-attekintes","text":"Az alfejezetek nem tartalmaznak feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismertetik a kapcsol\u00f3d\u00f3 elm\u00e9leti t\u00e9mak\u00f6r\u00f6ket, p\u00e9ld\u00e1kkal illusztr\u00e1lva.","title":"Elm\u00e9leti \u00e1ttekint\u00e9s"},{"location":"labor/1-model-es-kod-kapcsolata/#a-az-uml-osztalydiagram-es-a-kod-kapcsolatanak-elmelete-hallgato","text":"Az anyag itt el\u00e9rhet\u0151: Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolata . Ez a t\u00e9mak\u00f6r kor\u00e1bbi f\u00e9l\u00e9vben a Szoftvertechnol\u00f3gia t\u00e1rgy keret\u00e9ben ker\u00fclt ismertet\u00e9sre.","title":"A) Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete [hallgat\u00f3]*"},{"location":"labor/1-model-es-kod-kapcsolata/#b-interfesz-es-absztrakt-ososztaly-hallgato","text":"Az anyag itt el\u00e9rhet\u0151: Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly . T\u00e9mak\u00f6r\u00f6k: Absztrakt oszt\u00e1ly fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven Interf\u00e9sz fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa","title":"B) Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly [hallgat\u00f3]*"},{"location":"labor/1-model-es-kod-kapcsolata/#2-feladat-az-uml-es-a-kod-kapcsolatanak-szemleltetese","text":"","title":"2. Feladat - Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se"},{"location":"labor/1-model-es-kod-kapcsolata/#feladat-leirasa-equipment-inventory","text":"Feladat: Egy sz\u00e1m\u00edt\u00f3g\u00e9palkatr\u00e9sz nyilv\u00e1ntart\u00f3 alkalmaz\u00e1s kifejleszt\u00e9s\u00e9vel b\u00edztak meg benn\u00fcnket. B\u0151vebben: K\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00fa alkatr\u00e9szeket kell tudni kezelni. Kezdetben a HardDisk , SoundCard \u00e9s LedDisplay t\u00edpusokat kell t\u00e1mogatni, de a rendszer legyen k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00faj t\u00edpusokkal. Az alkatr\u00e9szekhez tartoz\u00f3 adatok: beszerz\u00e9s \u00e9ve, \u00e9letkora (sz\u00e1m\u00edtott), beszerz\u00e9si \u00e1ra \u00e9s aktu\u00e1lis \u00e1ra (sz\u00e1m\u00edtott), de ezeken fel\u00fcl t\u00edpusf\u00fcgg\u0151 adatokat is tartalmazhatnak (pl. a HardDisk eset\u00e9ben a kapacit\u00e1s). Az aktu\u00e1lis \u00e1r f\u00fcgg az alkatr\u00e9sz t\u00edpus\u00e1t\u00f3l, a beszerz\u00e9si \u00e1rt\u00f3l \u00e9s az alkatr\u00e9sz gy\u00e1rt\u00e1si \u00e9v\u00e9t\u0151l. Pl. min\u00e9l \u00f6regebb egy alkatr\u00e9sz, ann\u00e1l nagyobb kedvezm\u00e9nyt adunk r\u00e1, de a kedvezm\u00e9ny m\u00e9rt\u00e9ke f\u00fcgg az alkatr\u00e9sz t\u00edpust\u00f3l is. List\u00e1zni kell tudni a k\u00e9szleten lev\u0151 alkatr\u00e9szeket. A LedDisplay oszt\u00e1lynak k\u00f6telez\u0151en egy DisplayBase oszt\u00e1lyb\u00f3l kell sz\u00e1rmaznia, \u00e9s a DisplayBase oszt\u00e1ly forr\u00e1sk\u00f3dja nem megv\u00e1ltoztathat\u00f3. Jelen p\u00e9ld\u00e1ban ennek nincs sok \u00e9rtelme, a gyakorlatban azonban gyakran tal\u00e1lkozunk hasonl\u00f3 helyzettel, amikor is az \u00e1ltalunk haszn\u00e1lt keretrendszer/platform el\u0151\u00edrja, hogy adott esetben egy-egy be\u00e9p\u00edtett oszt\u00e1lyb\u00f3l kell sz\u00e1rmaztassunk. Tipikusan ez a helyzet, amikor ablakokkal, \u0171rlapokkal, saj\u00e1t vez\u00e9rl\u0151t\u00edpusokkal dolgozunk: ezeket a keretrendszer be\u00e9p\u00edtett oszt\u00e1lyaib\u00f3l kell sz\u00e1rmaztatnunk, \u00e9s a keretrendszer - pl. Java, .NET - forr\u00e1sk\u00f3dja nem \u00e1ll rendelkez\u00e9s\u00fcnkre (de legal\u00e1bbis biztosan nem akarjuk megv\u00e1ltoztatni). A p\u00e9ld\u00e1nkban a DisplayBase -b\u0151l val\u00f3 sz\u00e1rmaztat\u00e1s el\u0151\u00edr\u00e1s\u00e1val ezt a helyzetet szimul\u00e1ljuk. A megval\u00f3s\u00edt\u00e1s sor\u00e1n jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9l\u00fcnk: az alkatr\u00e9szeket csak mem\u00f3ri\u00e1ban tarjuk nyilv\u00e1n, a list\u00e1z\u00e1s is a lehet\u0151 legegyszer\u0171bb, egyszer\u0171en csak ki\u00edrjuk a nyilv\u00e1ntartott alkatr\u00e9szek adatait a konzolra. A kezdeti egyeztet\u00e9sek sor\u00e1n a megrendel\u0151nkt\u0151l a k\u00f6vetkez\u0151 inform\u00e1ci\u00f3t kapjuk: egy bels\u0151 munkat\u00e1rsuk m\u00e1r elindult a fejleszt\u00e9ssel, de id\u0151 hi\u00e1ny\u00e1ban csak f\u00e9lk\u00e9sz megold\u00e1sig jutott. A feladatunk r\u00e9sz\u00e9t k\u00e9pezi a f\u00e9lk\u00e9sz megold\u00e1s megismer\u00e9se, illetve ebb\u0151l kiindulva kell a feladatot megval\u00f3s\u00edtani.","title":"Feladat le\u00edr\u00e1sa - Equipment inventory"},{"location":"labor/1-model-es-kod-kapcsolata/#class-diagram","text":"Nyissuk meg a megrendel\u0151nkt\u0151l kapott forr\u00e1sk\u00f3d solution-j\u00e9t, melyet a k\u00f6vetkez\u0151 l\u00e9p\u00e9seket k\u00f6vetve tudunk megtenni. Ehhez kl\u00f3nozzuk le a kiindul\u00f3 projekt online GitHub rendszerben el\u00e9rhet\u0151 Git repositoryj\u00e1t a C:\\Work mapp\u00e1n bel\u00fcl egy \u00faj saj\u00e1t mapp\u00e1ba: pl.: C:\\Work\\NEPTUN\\lab1 . Ebben az \u00faj mapp\u00e1ban nyissunk meg egy command line-t vagy powershellt \u00e9s futtassuk az al\u00e1bbi git parancsot: git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo.git Note A Git-r\u0151l, mint forr\u00e1sk\u00f3dkezel\u0151 rendszerr\u0151l, az els\u0151 h\u00e1zi feladat kontextus\u00e1ban olvashatunk majd b\u0151vebben. Nyissuk meg a lekl\u00f3nozott mapp\u00e1ban tal\u00e1lhat\u00f3 src/EquipmentInventory.sln Visual Studio solutiont. A Solution Explorerben szemmel fussuk \u00e1t a f\u00e1jlokat. Az meg\u00e9rt\u00e9st seg\u00edten\u00e9, ha egy oszt\u00e1lydiagramon megjelen\u00edten\u00e9nk az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatokat. Vegy\u00fcnk is fel egy oszt\u00e1lydiagramot a projekt\u00fcnkbe. A Solution Explorerben a projekten (\u00e9s nem a solution-\u00f6n!) jobb gombbal kattintva a felugr\u00f3 men\u00fcben az Add/New Item elemet v\u00e1lasztva, majd a megjelen\u0151 ablakban a Class Diagram elemet v\u00e1lasszuk ki, az ablak alj\u00e1n a diagram nev\u00e9nek a Main.cd-t adjuk meg, \u00e9s OK-zuk le az ablakot. Class Diagram hi\u00e1nyz\u00f3 sablon Ha a Class Diagram elem nem jelenik meg a list\u00e1ban, akkor nincs telep\u00edtve a VS megfelel\u0151 komponense. Err\u0151l jelen dokumentum El\u0151felt\u00e9telek fejezet\u00e9ben olvashatsz b\u0151vebben. Ekkor a Solution Explorerben megjelenik a Main.cd diagramf\u00e1jl, duplakattint\u00e1ssal nyissuk meg. A diagramunk jelenleg \u00fcres. A Solution Explorerb\u0151l drag&drop-pal dobjuk r\u00e1 a .cs forr\u00e1sf\u00e1jlokat a diagramra. Ekkor a VS megn\u00e9zi, milyen oszt\u00e1lyok vannak ezekben a forr\u00e1sf\u00e1jlokban, \u00e9s visszafejti \u0151ket UML oszt\u00e1lyokk\u00e1. Alak\u00edtsuk ki a k\u00f6vetkez\u0151 \u00e1br\u00e1nak megfelel\u0151 elrendez\u00e9st (az oszt\u00e1lyok tagjainak megjelen\u00edt\u00e9s\u00e9t a t\u00e9glalapuk jobb fels\u0151 sark\u00e1ban lev\u0151 duplany\u00edlra kattint\u00e1ssal \u00e9rhetj\u00fck el): Az oszt\u00e1lyokhoz tartoz\u00f3 forr\u00e1sk\u00f3dot is megn\u00e9zhetj\u00fck, ak\u00e1r a diagramon a megfelel\u0151 oszt\u00e1lyra dupl\u00e1n kattintva, ak\u00e1r a Solution Explorerb\u0151l a .cs f\u00e1jlokat megnyitva. A k\u00f6vetkez\u0151ket tapasztaljuk: A SoundCard , HardDisk \u00e9s LedDisplay oszt\u00e1lyok viszonylag j\u00f3l kidolgozottak, rendelkeznek a sz\u00fcks\u00e9ges attrib\u00fatumokkal \u00e9s lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyekkel. Az LedDisplay a k\u00f6vetelm\u00e9nyeknek megfelel\u0151en a DisplayBase oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Az EquipmentInventory felel\u0151s ugyan a k\u00e9szleten lev\u0151 alkatr\u00e9szek nyilv\u00e1ntart\u00e1s\u00e1\u00e9rt, de gyakorlatilag semmi nincs ebb\u0151l megval\u00f3s\u00edtva. Tal\u00e1lunk egy IEquipment interf\u00e9szt, GetAge \u00e9s GetPrice m\u0171veletekkel","title":"Class Diagram"},{"location":"labor/1-model-es-kod-kapcsolata/#equipmentinventory","text":"\u00c1lljunk neki a megold\u00e1s kidolgoz\u00e1s\u00e1nak. El\u0151sz\u00f6r is az alapkoncepci\u00f3kat fektess\u00fck le. Az EquipmentInventory oszt\u00e1lyban egy heterog\u00e9n kollekci\u00f3ban t\u00e1roljuk a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusokat. Ez a kulcsa az alkatr\u00e9szek egys\u00e9ges kezel\u00e9s\u00e9nek, vagyis annak, hogy a megold\u00e1sunk \u00faj alkatr\u00e9szt\u00edpusokkal k\u00f6nnyen b\u0151v\u00edthet\u0151 legyen. Mint kor\u00e1bban taglaltuk, az egys\u00e9ges kezel\u00e9st vagy k\u00f6z\u00f6s \u0151soszt\u00e1ly, vagy k\u00f6z\u00f6s interf\u00e9sz bevezet\u00e9s\u00e9vel lehet megoldani. Eset\u00fcnkben a k\u00f6z\u00f6s \u0151soszt\u00e1ly (pl. EquipmentBase ) \u00fagy t\u0171nik, kiesik, mert ennek bevezet\u00e9s\u00e9vel az LedDisplay oszt\u00e1lynak k\u00e9t \u0151soszt\u00e1lya is lenne: a k\u00f6telez\u0151nek kik\u00f6t\u00f6tt DisplayBase , \u00e9s az \u00e1ltalunk az egys\u00e9ges kezel\u00e9sre bevezetett EquipmentBase . Ez nem lehets\u00e9ges, .NET k\u00f6rnyezetben egy oszt\u00e1lynak csak egy \u0151se lehet. Az a megold\u00e1s pedig, hogy a DisplayBase -t \u00fagy m\u00f3dos\u00edtjuk, hogy \u0151 is az EquipmentBase -b\u0151l sz\u00e1rmazik, a k\u00f6vetelm\u00e9ny\u00fcnknek megfelel\u0151en nem lehets\u00e9ges (kik\u00f6t\u00e9s volt, hogy a forr\u00e1sk\u00f3dja nem m\u00f3dos\u00edthat\u00f3). Marad teh\u00e1t az interf\u00e9sz alap\u00fa megk\u00f6zel\u00edt\u00e9s. Minden bizonnyal az alkalmaz\u00e1s kor\u00e1bbi fejleszt\u0151je is erre a k\u00f6vetkeztet\u00e9sre jutott, ez\u00e9rt is vezette be az IEquipment interf\u00e9szt. Vegy\u00fcnk fel egy IEquipment t\u00edpus\u00fa elemekb\u0151l \u00e1ll\u00f3 generikus list\u00e1t (ne property-t hanem field-et!) az EquipmentInventory oszt\u00e1lyba. A l\u00e1that\u00f3s\u00e1ga \u2013 az egys\u00e9gbez\u00e1r\u00e1sra t\u00f6rekedve \u2013 legyen private . A neve legyen equipment (ne legyen \u201es\u201d a v\u00e9g\u00e9n, angolban az equipment t\u00f6bbes sz\u00e1ma is equipment). A tagv\u00e1ltoz\u00f3 felv\u00e9tel\u00e9hez a Visual Studio Class Details ablak\u00e1t haszn\u00e1ljuk. Ha az ablak nem l\u00e1that\u00f3, a View / Other Windows / Class Details men\u00fc kiv\u00e1laszt\u00e1s\u00e1val jelen\u00edthet\u0151 meg. A tagv\u00e1ltoz\u00f3 t\u00edpusa teh\u00e1t List<IEquipment> . A .NET List t\u00edpusa egy dinamikusan ny\u00fajt\u00f3zkod\u00f3 generikus t\u00f6mb (mint Java-ban az ArrayList ). A diagramon az EquipmentInventory oszt\u00e1lyra pillantva azt l\u00e1tjuk, hogy csak a tagv\u00e1ltoz\u00f3 neve jelenik meg, a t\u00edpusa nem. A diagram h\u00e1tter\u00e9n jobb gombbal kattintva a Change Members Format men\u00fcb\u0151l a Display Full Signature -t v\u00e1lasszuk ki. Ezt k\u00f6vet\u0151en a diagramon l\u00e1that\u00f3v\u00e1 v\u00e1lik a tagv\u00e1ltoz\u00f3k t\u00edpusa, valamint a m\u0171veletek teljes szignat\u00far\u00e1ja. Az EquipmentInventory oszt\u00e1lyon dupl\u00e1n kattintva elnavig\u00e1lhatunk a forr\u00e1sk\u00f3dba, \u00e9s mint l\u00e1that\u00f3, val\u00f3ban egy lista t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k\u00e9nt jelenik meg a k\u00f3dban: class EquipmentInventory { private List < IEquipment > equipment ; Ennek egyr\u00e9szt \u00f6r\u00fcl\u00fcnk, mert a Visual Studio t\u00e1mogatja a round-trip engineering technik\u00e1t: a modellt \u00e9rint\u0151 v\u00e1ltoz\u00e1sokat azonnal \u00e1tvezeti a k\u00f3dba, \u00e9s viszont . M\u00e1sr\u00e9szt a kor\u00e1bbiakban azt taglaltuk, hogy ha egy oszt\u00e1lyban egy gy\u0171jtem\u00e9ny tag van egy m\u00e1sik oszt\u00e1ly elemeib\u0151l, akkor annak az UML modellben egy 1-t\u00f6bb t\u00edpus\u00fa asszoci\u00e1ci\u00f3s kapcsolatk\u00e9nt \u201eillik\u201d megjelennie a k\u00e9t oszt\u00e1ly k\u00f6z\u00f6tt. A modell\u00fcnkben egyel\u0151re nem ezt tapasztaljuk. Szerencs\u00e9re a VS modellez\u0151 fel\u00fclete r\u00e1vehet\u0151, hogy ilyen form\u00e1ban jelen\u00edtse meg ezt a kapcsolatt\u00edpust. Ehhez kattintsunk a diagramon jobb gombbal az equipment tagv\u00e1ltoz\u00f3n, \u00e9s a men\u00fcb\u0151l v\u00e1lasszuk ki a Show as Collection Association elemet. Az IEquipment interf\u00e9szt ezt k\u00f6vet\u0151en mozgassuk ki jobbra, hogy kell\u0151 hely legyen a diagramon az asszoci\u00e1ci\u00f3s kapcsolat \u00e9s a kapcsolaton lev\u0151 szerep (role) adatainak megjelen\u00edt\u00e9s\u00e9re: A dupla ny\u00edl v\u00e9gz\u0151d\u00e9s a \u201et\u00f6bbes\u201d oldalon nem szabv\u00e1nyos UML, de ne szomorodjunk el t\u0151le k\u00fcl\u00f6n\u00f6sebben, nincs semmi jelent\u0151s\u00e9ge. Annak mindenk\u00e9ppen \u00f6r\u00fcl\u00fcnk, hogy a kapcsolatot reprezent\u00e1l\u00f3 ny\u00edl az IEquipment v\u00e9g\u00e9n a szerepben a tagv\u00e1ltoz\u00f3 neve (s\u0151t, m\u00e9g a pontos t\u00edpusa is) fel van t\u00fcntetve. Navig\u00e1ljunk el az EquipmentInventory forr\u00e1sk\u00f3dj\u00e1hoz, \u00e9s \u00edrjuk meg a konstruktor\u00e1t, ami inicializ\u00e1lja az equipment gy\u0171jtem\u00e9nyt! public EquipmentInventory () { equipment = new List < IEquipment >(); } Ezut\u00e1n \u00edrjuk meg a ListAll met\u00f3dust, ami ki\u00edrja az elemek \u00e9letkor\u00e1t, \u00e9s az aktu\u00e1lis \u00e9rt\u00e9k\u00fcket: public void ListAll () { foreach ( IEquipment eq in equipment ) { Console . WriteLine ( $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\" ); } } Az elemeken a foreach utas\u00edt\u00e1ssal iter\u00e1lunk v\u00e9gig. A foreach utas\u00edt\u00e1s haszn\u00e1lata sor\u00e1n az in kulcssz\u00f3 ut\u00e1n egy gy\u0171jtem\u00e9nynek kell \u00e1llnia, az in el\u0151tt pedig egy v\u00e1ltoz\u00f3 deklar\u00e1ci\u00f3nak (eset\u00fcnkben IEquipment eq ), ahol a t\u00edpus a gy\u0171jtem\u00e9ny elemt\u00edpusa. Minden iter\u00e1ci\u00f3ban ez a v\u00e1ltoz\u00f3 a gy\u0171jtem\u00e9ny iter\u00e1ci\u00f3beli \u00e9rt\u00e9k\u00e9t veszi fel. A Console.WriteLine m\u0171veletnek vagy egy egyszer\u0171 stringet adunk meg, vagy, mint eset\u00fcnkben, egy form\u00e1z\u00e1si stringet. A behelyettes\u00edt\u00e9seket string interpol\u00e1ci\u00f3val oldottuk meg: a behelyettes\u00edtend\u0151 \u00e9rt\u00e9keket {} k\u00f6z\u00f6tt kell megadni. Ha string interpol\u00e1ci\u00f3t haszn\u00e1lunk, a stringnek $ jellel kell kezd\u0151dnie. \u00cdrjunk meg egy AddEquipment nev\u0171 f\u00fcggv\u00e9nyt, ami felvesz egy \u00faj eszk\u00f6zt a k\u00e9szletbe: public void AddEquipment ( IEquipment eq ) { equipment . Add ( eq ); }","title":"EquipmentInventory"},{"location":"labor/1-model-es-kod-kapcsolata/#iequipment-megvalositok","text":"Kor\u00e1bbi d\u00f6nt\u00e9s\u00fcnk \u00e9rtelm\u00e9ben az IEquipment interf\u00e9szt haszn\u00e1ljuk az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusok egys\u00e9ges kezel\u00e9s\u00e9re. Est\u00fcnkben mind a SoundCard , mind a HardDisk oszt\u00e1ly rendelkezik GetAge() \u00e9s GetPrice() met\u00f3dussal, m\u00e9gsem tudjuk \u0151ket egys\u00e9gesen kezelni (pl. k\u00f6z\u00f6s list\u00e1ban t\u00e1rolni). Ahhoz, hogy ezt meg tudjuk tenni, el kell \u00e9rn\u00fcnk, hogy mindk\u00e9t oszt\u00e1ly megval\u00f3s\u00edtsa az IEquipment interf\u00e9szt. M\u00f3dos\u00edtsuk a forr\u00e1sukat: public class SoundCard : IEquipment public class HardDisk : IEquipment Ezt k\u00f6vet\u0151en a SoundCard \u00e9s HardDisk oszt\u00e1lyban implement\u00e1lnunk kell az IEquipment interf\u00e9szben lev\u0151 met\u00f3dusokat. Azt tapasztaljuk, hogy ezzel nincs most teend\u0151k, a GetPrice \u00e9s GetAge f\u00fcggv\u00e9nyek m\u00e1r meg vannak \u00edrva mindk\u00e9t helyen. Pr\u00f3bak\u00e9ppen a Program.cs f\u00e1jlban tal\u00e1lhat\u00f3 Main f\u00fcggv\u00e9ny\u00fcnkben hozzunk l\u00e9tre egy EquipmentInventory objektumot, t\u00f6lts\u00fck fel HardDisk \u00e9s SoundCard objektumokkal, majd list\u00e1zzuk a k\u00e9sztelet a konzolra. Ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra! static void Main ( string [] args ) { EquipmentInventory ei = new EquipmentInventory (); ei . AddEquipment ( new HardDisk ( 2021 , 30000 , 80 )); ei . AddEquipment ( new HardDisk ( 2020 , 25000 , 120 )); ei . AddEquipment ( new HardDisk ( 2020 , 25000 , 250 )); ei . AddEquipment ( new SoundCard ( 2021 , 8000 )); ei . AddEquipment ( new SoundCard ( 2020 , 7000 )); ei . AddEquipment ( new SoundCard ( 2020 , 6000 )); ei . ListAll (); } Az alkalmaz\u00e1st futtatva azt tapasztaljuk, hogy b\u00e1r megold\u00e1sunk kezdetleges, de m\u0171k\u00f6dik: Folytassuk a munk\u00e1t a LedDisplay oszt\u00e1llyal. A DisplayBase \u0151s forr\u00e1sk\u00f3dj\u00e1t a k\u00f6vetelm\u00e9nyek miatt nem m\u00f3dos\u00edthatjuk. De ez semmif\u00e9le probl\u00e9m\u00e1t nem okoz, a LedDisplay oszt\u00e1lyunk fogja az IEquipment interf\u00e9szt implement\u00e1lni, m\u00f3dos\u00edtsuk a k\u00f3dot ennek megfelel\u0151en: public class LedDisplay : DisplayBase , IEquipment A LedDisplay oszt\u00e1lyban m\u00e1r meg kell \u00edrni az interf\u00e9szben szerepl\u0151 f\u00fcggv\u00e9nyeket: public double GetPrice () { return this . price ; } public int GetAge () { return DateTime . Today . Year - this . manufacturingYear ; } B\u0151v\u00edts\u00fck a Main f\u00fcggv\u00e9ny\u00fcnket is, vegy\u00fcnk fel k\u00e9t LedDisplay objektumot a k\u00e9szlet\u00fcnkbe (itt is \u00e9l, hogy ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra! ei . AddEquipment ( new LedDisplay ( 2020 , 80000 , 17 , 16 ) ); ei . AddEquipment ( new LedDisplay ( 2021 , 70000 , 17 , 12 ) ); ei . ListAll (); Console . ReadKey (); Tesztel\u00e9sk\u00e9ppen futtassuk az alkalmaz\u00e1st.","title":"IEquipment megval\u00f3s\u00edt\u00f3k"},{"location":"labor/1-model-es-kod-kapcsolata/#3-feladat-az-interfesz-es-az-absztrakt-ososztaly-alkalmazastechnikaja","text":"","title":"3. Feladat - Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja"},{"location":"labor/1-model-es-kod-kapcsolata/#interfesz-problematikaja","text":"\u00c9rt\u00e9kelj\u00fck a jelenlegi, interf\u00e9sz alap\u00fa megold\u00e1sunkat. Az egyik f\u0151 probl\u00e9ma, hogy k\u00f3dunk tele van a karbantarthat\u00f3s\u00e1got \u00e9s b\u0151v\u00edthet\u0151s\u00e9get rombol\u00f3 k\u00f3dduplik\u00e1ci\u00f3val: A yearOfCreation \u00e9s newPrice tagok minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis LedDisplay -t) k\u00f6z\u00f6sek, ezeket \u00faj t\u00edpus bevezet\u00e9sekor is copy-paste technik\u00e1val \u00e1t kell venni. A GetAge f\u00fcggv\u00e9ny implement\u00e1ci\u00f3ja szinten minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis LedDisplay -t) azonos, szint\u00e9n copy-paste-tel \u201eszapor\u00edtand\u00f3\u201d. A konstruktorok yearOfCreation \u00e9s newPrice tagokat inicializ\u00e1l\u00f3 sorai szint\u00e9n duplik\u00e1ltak az egyes oszt\u00e1lyokban. B\u00e1r ez a k\u00f3dduplik\u00e1ci\u00f3 egyel\u0151re nem t\u0171nik jelent\u0151snek, \u00faj alkatr\u00e9sz t\u00edpusok bevezet\u00e9s\u00e9vel egyre ink\u00e1bb elm\u00e9rgesedik a helyzet, jobb id\u0151ben elej\u00e9t venni a j\u00f6v\u0151beli f\u00e1jdalmaknak. A m\u00e1sik probl\u00e9ma abb\u00f3l ad\u00f3dik, hogy az alkatr\u00e9sz adatok list\u00e1z\u00e1sa jelenleg f\u00e1jdalmasan hi\u00e1nyos, nem jelenik meg az alkatr\u00e9sz t\u00edpusa (csak a kora \u00e9s az \u00e1ra). A t\u00edpus megjelen\u00edt\u00e9s\u00e9hez az IEquipment interf\u00e9szt b\u0151v\u00edteni kell, pl. egy GetDescription nev\u0171 m\u0171velet bevezet\u00e9s\u00e9vel. Vegy\u00fcnk is fel egy GetDescription f\u00fcggv\u00e9nyt az interf\u00e9szbe! public interface IEquipment { double GetPrice (); int GetAge (); string GetDescription (); } Ekkor minden IEquipment interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban meg kellene val\u00f3s\u00edtani ezt a met\u00f3dust is, ami sok oszt\u00e1ly eset\u00e9n sok munka (valamint egy t\u00f6bbkomponens\u0171, vagyis t\u00f6bb DLL-b\u0151l \u00e1ll\u00f3 alkalmaz\u00e1s eset\u00e9ben, amikor ezek nem egy fejleszt\u0151 c\u00e9g kez\u00e9ben vannak, sokszor nem is megoldhat\u00f3). A Build parancs futtat\u00e1s\u00e1val ellen\u0151rizz\u00fck, hogy a GetDescription felv\u00e9tele ut\u00e1n h\u00e1rom helyen is ford\u00edt\u00e1si hib\u00e1t kapunk. Interf\u00e9szben alap\u00e9rtelmezett implement\u00e1ci\u00f3 megad\u00e1sa \u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja . B\u0151vebben inform\u00e1ci\u00f3 itt: default interface methods . public interface IEquipment { double GetPrice (); int GetAge (); string GetDescription () { return \"EquipmentBase\" ; } }","title":"Interf\u00e9sz problematik\u00e1ja"},{"location":"labor/1-model-es-kod-kapcsolata/#absztrakt-osztaly","text":"Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelent egy k\u00f6z\u00f6s absztrakt \u0151s bevezet\u00e9se (kiv\u00e9ve az LedDiplay oszt\u00e1lyt, amire m\u00e9g visszat\u00e9r\u00fcnk). Ebbe fel tudjuk k\u00f6lt\u00f6ztetni a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot, valamint az \u00fajonnan bevezetett GetDescription m\u0171velethez egy alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni. Legyen az \u00faj absztrakt \u0151soszt\u00e1lyunk neve EquipmentBase . K\u00e9rd\u00e9s, sz\u00fcks\u00e9g van-e a tov\u00e1bbiakban az IEquipment interf\u00e9szre, vagy az teljesen kiv\u00e1lthat\u00f3 az \u00faj EquipmentBase oszt\u00e1llyal. Az IEquipment interf\u00e9szt meg kell tartsuk, mert a LedDisplay oszt\u00e1lyunkat nem tudjuk az EquipmentBase -b\u0151l sz\u00e1rmaztatni: m\u00e1r van egy k\u00f6telez\u0151en el\u0151\u00edrt \u0151soszt\u00e1lya, a DisplayBase : emiatt az EquipmentInventory a tov\u00e1bbfejlesztett megold\u00e1sunkban is IEquipment interf\u00e9szk\u00e9nt hivatkozik az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szekre. \u00c1lljunk is neki az \u00e1talak\u00edt\u00e1snak. Legyen az oszt\u00e1lydiagramunk az akt\u00edv tabf\u00fcl. A Toolbox -b\u00f3l drag&drop-pal dobjunk fel egy Abstract Class elemet a diagramra, a neve legyen EquipmentBase . A k\u00f6vetkez\u0151kben azt kell el\u00e9rj\u00fck, hogy a SoundCard \u00e9s a HardDisk oszt\u00e1lyok sz\u00e1rmazzanak az EquipmentBase -b\u0151l (a LedDisplay -nek m\u00e1r van m\u00e1sik \u0151se, \u00edgy ott ezt nem tudjuk megtenni). Ehhez v\u00e1lasszuk ki az Inheritance kapcsolatot a Toolbox -ban, majd h\u00fazzunk egy-egy vonalat a gyermekoszt\u00e1lyb\u00f3l kiindulva az \u0151soszt\u00e1lyba a SoundCard \u00e9s HardDisk eset\u00e9ben egyar\u00e1nt. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben alak\u00edtsuk \u00e1t \u00fagy a k\u00f3dot, hogy ne a HardDisk \u00e9s SoundCard val\u00f3s\u00edts\u00e1k meg k\u00fcl\u00f6n-k\u00fcl\u00f6n az IEquipment interf\u00e9szt, hanem a k\u00f6z\u00f6s \u0151s\u00fck, az EquipmentBase egyszer. Ehhez m\u00f3dos\u00edtsuk az EquipmentBase oszt\u00e1lyt \u00fagy, hogy val\u00f3s\u00edtsa meg az interf\u00e9szt (ak\u00e1r a diagramon h\u00fazzunk be egy inheritance kapcsolatot az EquipmentBase -b\u0151l az IEquipment -be, vagy az EquipmentBase forr\u00e1sk\u00f3dj\u00e1t m\u00f3dos\u00edtsuk). A HardDisk \u00e9s SoundCard oszt\u00e1lyokb\u00f3l t\u00f6r\u00f6lj\u00fck az IEquipment megval\u00f3s\u00edt\u00e1s\u00e1t (az \u0151s m\u00e1r implement\u00e1lja). A diagramunk \u00e9s a forr\u00e1sk\u00f3dunk vonatkoz\u00f3 r\u00e9szei ezt k\u00f6vet\u0151en \u00edgy n\u00e9znek ki: public abstract class EquipmentBase : IEquipment public class HardDisk : EquipmentBase public class SoundCard : EquipmentBase A k\u00f3dunk m\u00e9g nem fordul, ennek t\u00f6bb oka is van. Az EquipmentBase implement\u00e1lja az IEquipment interf\u00e9szt, de m\u00e9g nincsenek benne implement\u00e1lva az interf\u00e9sz m\u0171veletei. Vagy gener\u00e1ltassuk le a met\u00f3dusokat a smart tag haszn\u00e1lat\u00e1val, vagy g\u00e9pelj\u00fck be a k\u00f6vetkez\u0151 elveknek megfelel\u0151en: A newPrice \u00e9s yearOfCreation duplik\u00e1lva vannak a HardDisk \u00e9s SoundCard oszt\u00e1lyokban: mozgassuk (\u00e9s ne m\u00e1soljuk!) \u00e1t ezeket a k\u00f6z\u00f6s EquipmentBase \u0151sbe, \u00e9s protected l\u00e1that\u00f3s\u00e1got adjunk meg. A GetAge m\u0171velet duplik\u00e1lva van a HardDisk \u00e9s SoundCard oszt\u00e1lyokban, ezekb\u0151l t\u00f6r\u00f6lj\u00fck ki az implement\u00e1ci\u00f3t \u00e9s vigy\u00fck \u00e1t az EquipmentBase oszt\u00e1lyba. A GetPrice m\u0171veletet absztrakt m\u0171veletk\u00e9nt vegy\u00fck fel az \u0151sbe. Ez sz\u00e1nd\u00e9kos tervez\u0151i d\u00f6nt\u00e9s, \u00edgy r\u00e1k\u00e9nyszer\u00edtj\u00fck a lesz\u00e1rmazott oszt\u00e1lyokat, hogy mindenk\u00e9ppen defini\u00e1lj\u00e1k fel\u00fcl ezt a m\u0171veletet. A GetDescription eset\u00e9ben viszont pont ford\u00edtottja a helyzet: ezt virtu\u00e1lisnak defini\u00e1ljuk (\u00e9s nem absztraktnak), vagyis m\u00e1r az \u0151sben is adunk meg implement\u00e1ci\u00f3t. \u00cdgy a lesz\u00e1rmazottak nincsenek r\u00e1k\u00e9nyszer\u00edtve a m\u0171velet fel\u00fcldefini\u00e1l\u00e1s\u00e1ra. A fentieknek megfelel\u0151 k\u00f3d a k\u00f6vetkez\u0151: public abstract class EquipmentBase : IEquipment { protected int yearOfCreation ; protected int newPrice ; public int GetAge () { return DateTime . Today . Year - yearOfCreation ; } public abstract double GetPrice (); public virtual string GetDescription () { return \"EquipmentBase\" ; } } N\u00e9h\u00e1ny kieg\u00e9sz\u00edt\u0151 gondolat a k\u00f3dr\u00e9szletre vonatkoz\u00f3an: Az absztrakt oszt\u00e1lyok eset\u00e9ben az abstract kulcssz\u00f3t ki kell \u00edrni a class sz\u00f3 el\u00e9. Az absztrakt m\u0171veletek eset\u00e9ben az abstract kulcssz\u00f3t kell megadni .NET k\u00f6rnyezetben lehet\u0151s\u00e9g\u00fcnk van szab\u00e1lyozni, hogy egy m\u0171velet virtu\u00e1lis-e vagy sem. Ebb\u0151l a szempontb\u00f3l a C++ nyelvhez hasonl\u00edt. Amennyiben egy m\u0171veletet virtu\u00e1liss\u00e1 szeretn\u00e9nk tenni, a virtual kulcssz\u00f3t kell a m\u0171veletre megadni. Eml\u00e9keztet\u0151: akkor defini\u00e1ljunk egy m\u0171veletet virtu\u00e1lisnak, ha a lesz\u00e1rmazottak azt fel\u00fcldefini\u00e1l(hat)j\u00e1k. Csak ekkor garant\u00e1lt, hogy egy \u0151sreferenci\u00e1n megh\u00edvva az adott m\u0171veletet a lesz\u00e1rmazottbeli verzi\u00f3 h\u00edv\u00f3dik meg.","title":"Absztrakt oszt\u00e1ly"},{"location":"labor/1-model-es-kod-kapcsolata/#leszarmazottak","text":"A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t az EquipmentBase lesz\u00e1rmazottakra. C# nyelven az absztrakt \u00e9s virtu\u00e1lis m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor a lesz\u00e1rmazottban meg kell adni az override kulcssz\u00f3t. Els\u0151 l\u00e9p\u00e9sben a GetPrice m\u0171veletet defini\u00e1ljuk fel\u00fcl: HardDisk.cs public override double GetPrice () { return yearOfCreation < ( DateTime . Today . Year - 4 ) ? 0 : newPrice - ( DateTime . Today . Year - yearOfCreation ) * 5000 ; } SoundCard.cs public override double GetPrice () { return yearOfCreation < ( DateTime . Today . Year - 4 ) ? 0 : newPrice - ( DateTime . Today . Year - yearOfCreation ) * 2000 ; } A k\u00f6vetkez\u0151kben l\u00e9p\u00e9sben a GetDescription m\u0171veletet \u00edrjuk meg a HardDisk \u00e9s SoundCard oszt\u00e1lyokban. Mivel itt az \u0151sbeli virtu\u00e1lis f\u00fcggv\u00e9nyt defini\u00e1ljuk fel\u00fcl, szint\u00e9n meg kell adni az override kulcssz\u00f3t: HardDisk.cs public override string GetDescription () { return \"Hard Disk\" ; } SoundCard.cs public override string GetDescription () { return \"Sound Card\" ; } Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, mi\u00e9rt d\u00f6nt\u00f6ttek \u00fagy a C# nyelv tervez\u0151i, hogy a m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor egy extra kulcssz\u00f3t kelljen megadni, hasonl\u00f3ra pl. a C++ nyelv eset\u00e9ben nem volt sz\u00fcks\u00e9g. Az ok egyszer\u0171: a k\u00f3d \u00edgy kifejez\u0151bb. A lesz\u00e1rmazottak k\u00f3dj\u00e1t n\u00e9zve az override sz\u00f3 azonnal egy\u00e9rtelm\u0171v\u00e9 teszi, hogy valamelyik \u0151sben ez a m\u0171velet absztrakt vagy virtu\u00e1lis, nem kell valamennyi \u0151s k\u00f3dj\u00e1t ehhez \u00e1ttekinteni.","title":"Lesz\u00e1rmazottak"},{"location":"labor/1-model-es-kod-kapcsolata/#leddisplay-ose","text":"A LedDisplay oszt\u00e1lyunk \u0151se meg van k\u00f6tve, annak k\u00f3dja nem m\u00f3dos\u00edthat\u00f3, \u00edgy nem tudjuk az EquipmentBase -b\u0151l sz\u00e1rmaztatni. A GetAge m\u0171veletet \u00edgy nem tudjuk t\u00f6r\u00f6lni, ez a k\u00f3dduplik\u00e1ci\u00f3 itt megmarad (de csak a LedDisplay eset\u00e9ben, ami csak egy oszt\u00e1ly a sok k\u00f6z\u00fcl!). Note Val\u00f3j\u00e1ban egy kis plusz munk\u00e1val ett\u0151l a duplik\u00e1ci\u00f3t\u00f3l is meg tudn\u00e1nk szabadulni. Ehhez valamelyik oszt\u00e1lyban (pl. EquipmentBase ) fel kellene venni egy statikus seg\u00e9df\u00fcggv\u00e9nyt, mely param\u00e9terben megkapn\u00e1 a gy\u00e1rt\u00e1si \u00e9vet, \u00e9s visszaadn\u00e1 az \u00e9letkort. Az EquipmentBase.GetAge \u00e9s a LedDisplay.GetAge ezt a seg\u00e9df\u00fcggv\u00e9nyt haszn\u00e1ln\u00e1 kimenete el\u0151\u00e1ll\u00edt\u00e1s\u00e1ra. A LedDisplay oszt\u00e1lyunkban ad\u00f3sak vagyunk m\u00e9g a GetDescription meg\u00edr\u00e1s\u00e1val: LedDisplay.cs public string GetDescription () { return \"Led Display\" ; } Figyelj\u00fck meg, hogy itt NEM adtuk meg az override kulcssz\u00f3t. Mikor egy interf\u00e9sz f\u00fcggv\u00e9nyt implement\u00e1lunk, az override -ot nem kell/szabad ki\u00edrni.","title":"LedDisplay \u0151se"},{"location":"labor/1-model-es-kod-kapcsolata/#getdescription-hasznalata","text":"M\u00f3dos\u00edtsuk az EquipmentInventory.ListAll m\u0171velet\u00e9t, hogy az elemek le\u00edr\u00e1s\u00e1t is \u00edrja ki a kimenetre: EquipmentInventory.cs public void ListAll () { foreach ( IEquipment eq in equipment ) { Console . WriteLine ( $\"Le\u00edr\u00e1s: {eq.GetDescription()}\\t\" + $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\" ); } } \u00cdgy m\u00e1r sokkal informat\u00edvabb kimetet kapunk az alkalmaz\u00e1s futtat\u00e1sakor:","title":"GetDescription haszn\u00e1lata"},{"location":"labor/1-model-es-kod-kapcsolata/#konstruktor-kodduplikacio","text":"A k\u00f3dunkat \u00e1ttekintve m\u00e9g egy helyen tal\u00e1lunk k\u00f3dduplik\u00e1ci\u00f3t. Valamennyi EquipmentBase lesz\u00e1rmazott ( HardDisk , SoundCard ) konstruktor\u00e1ban ott van ez a k\u00e9t sor: this . yearOfCreation = yearOfCreation ; this . newPrice = newPrice ; Ha belegondolunk, ezek a yearOfCreatio \u00e9s newPrice tagok az \u0151sben vannak defini\u00e1lva, \u00edgy egy\u00e9bk\u00e9nt is az \u0151 felel\u0151ss\u00e9ge kellene legyen ezek inicializ\u00e1l\u00e1sa. Vegy\u00fcnk is fel egy megfelel\u0151 konstruktort az EquipmentBase -ben: EquipmentBase.cs public EquipmentBase ( int yearOfCreation , int newPrice ) { this . yearOfCreation = yearOfCreation ; this . newPrice = newPrice ; } A HardDisk \u00e9s SoundCard lesz\u00e1rmazottak konstruktor\u00e1nak t\u00f6rzs\u00e9b\u0151l vegy\u00fck ki a k\u00e9t tag inicializ\u00e1l\u00e1s\u00e1t, helyette a base kulcssz\u00f3val hivatkozva h\u00edvjuk meg az \u0151s konstruktor\u00e1t: HardDisk.cs public HardDisk ( int yearOfCreation , int newPrice , int capacityGB ) : base ( yearOfCreation , newPrice ) { this . capacityGB = capacityGB ; } SoundCard.cs public SoundCard ( int yearOfCreation , int newPrice ) : base ( yearOfCreation , newPrice ) { }","title":"Konstruktor k\u00f3dduplik\u00e1ci\u00f3"},{"location":"labor/1-model-es-kod-kapcsolata/#ertekeles","text":"Az interf\u00e9sz \u00e9s absztrakt \u0151s egy\u00fcttes haszn\u00e1lat\u00e1val siker\u00fclt a legkevesebb kompromisszummal j\u00e1r\u00f3 megold\u00e1st kidolgoznunk: IEquipment interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk kezelni az alkatr\u00e9szek valamennyi t\u00edpus\u00e1t, m\u00e9g azokat is, melyekn\u00e9l az \u0151soszt\u00e1ly meg volt k\u00f6tve (puszt\u00e1n absztrakt \u0151s haszn\u00e1lat\u00e1val ezt nem tudtuk volna el\u00e9rni). Az EquipmentBase absztrakt \u0151s bevezet\u00e9s\u00e9vel egy kiv\u00e9telt\u0151l eltekintve a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szt\u00edpusokra k\u00f6z\u00f6s k\u00f3dot fel tudtuk vinni egy k\u00f6z\u00f6s \u0151sbe, \u00edgy el tudtuk ker\u00fclni a k\u00f3dduplik\u00e1ci\u00f3t. Az EquipmentBase absztrakt \u0151s bevezet\u00e9s\u00e9vel alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni az \u00fajonnan bevezetett IEquipment m\u0171veletek eset\u00e9ben (pl. GetDescripton ), \u00edgy nem vagyunk r\u00e1k\u00e9nyszer\u00edtve, hogy minden IEquipment implement\u00e1ci\u00f3s oszt\u00e1lyban meg kelljen azt adni. Z\u00e1r\u00e1sk\u00e9ppen vess\u00fcnk egy pillant\u00e1st megold\u00e1sunk UML (szer\u0171) oszt\u00e1lydiagramj\u00e1ra: Statikus interf\u00e9szek A C# 11 leg\u00fajabb \u00fajdons\u00e1ga a statikus interf\u00e9sz tagok defini\u00e1l\u00e1sa, amivel olyan tagokat k\u00f6vetelhet\u00fcnk meg az implement\u00e1l\u00f3 oszt\u00e1lyt\u00f3l, amelyek nem az objektum p\u00e9ld\u00e1nyra vonatkoznak, hanem az oszt\u00e1lynak kell egy adott statikus taggal rendelkeznie. B\u0151vebben","title":"\u00c9rt\u00e9kel\u00e9s"},{"location":"labor/1-model-es-kod-kapcsolata/#megjegyzes-opcionalis-hazi-gyakorlo-feladat","text":"Jelen megold\u00e1sunk nem t\u00e1mogatja az alkatr\u00e9szspecifikus adatok (pl. HardDisk eset\u00e9ben a kapacit\u00e1s) megjelen\u00edt\u00e9s\u00e9t a list\u00e1z\u00e1s sor\u00e1n. Ahhoz, hogy ezt meg tudjuk tenni, az alkatr\u00e9sz adatok form\u00e1zott stringbe \u00edr\u00e1s\u00e1t az EqipmentInventory oszt\u00e1lyb\u00f3l az alkatr\u00e9sz oszt\u00e1lyokba kellene vinni, a k\u00f6vetkez\u0151 elveknek megfelel\u0151en: Bevezethet\u00fcnk ehhez az IEquipment interf\u00e9szbe egy GetFormattedString m\u0171veletet, mely egy string t\u00edpus\u00fa objektummal t\u00e9r vissza. Alternat\u00edv megold\u00e1s lehet, ha a System.Object ToString() m\u0171velet\u00e9t defini\u00e1ljuk fel\u00fcl. .NET-ben ugyanis minden t\u00edpus implicit m\u00f3don a System.Object -b\u0151l sz\u00e1rmazik, aminek van egy virtu\u00e1lis ToString() m\u0171velete. Az EquipmentBase -ben meg\u00edrjuk a k\u00f6z\u00f6s tagok (le\u00edr\u00e1s, \u00e1r, kor) stringbe form\u00e1z\u00e1s\u00e1t. Amennyiben egy alkatr\u00e9sz t\u00edpusspecifikus adattal is rendelkezik, akkor oszt\u00e1ly\u00e1ban override-oljuk a stringbe form\u00e1z\u00f3 f\u00fcggv\u00e9nyt: ennek a f\u00fcggv\u00e9nynek egyr\u00e9szt meg kell h\u00edvnia az \u0151s v\u00e1ltozat\u00e1t (a base kulcssz\u00f3 haszn\u00e1lat\u00e1val), majd ehhez hozz\u00e1 kell f\u0171zni a saj\u00e1t form\u00e1zott adatait, \u00e9s ezzel a stringgel kell visszat\u00e9rnie.","title":"Megjegyz\u00e9s - opcion\u00e1lis h\u00e1zi gyakorl\u00f3 feladat"},{"location":"labor/2-nyelvi-eszkozok/","text":"2. Nyelvi eszk\u00f6z\u00f6k \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: K\u0151v\u00e1ri Bence, Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja az al\u00e1bbi C# nyelvi elemek megismer\u00e9se: Tulajdons\u00e1g (property) Deleg\u00e1t (delegate, met\u00f3dusreferencia) Esem\u00e9ny (event) Attrib\u00fatum (attribute) Lambda kifejez\u00e9s Generikus t\u00edpus (generic type) Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: a 2. el\u0151ad\u00e1s \u00e9s a 3. el\u0151ad\u00e1s eleje \u2013 (Modern) programoz\u00e1si eszk\u00f6z\u00f6k. El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Bevezet\u0151 \u00b6 A gyakorlat sor\u00e1n a hallgat\u00f3k megismerkednek a legfontosabb modern, a .NET k\u00f6rnyezetben is rendelkez\u00e9sre \u00e1ll\u00f3 nyelvi eszk\u00f6z\u00f6kkel. Felt\u00e9telezz\u00fck, hogy a hallgat\u00f3 a kor\u00e1bbi tanulm\u00e1nyai sor\u00e1n elsaj\u00e1t\u00edtotta az objektum-orient\u00e1lt szeml\u00e9letm\u00f3dot, \u00e9s tiszt\u00e1ban van az objektum-orient\u00e1lt alapfogalmakkal. Jelen gyakorlat sor\u00e1n azokra a .NET-es nyelvi elemekre koncentr\u00e1lunk, amelyek t\u00falmutatnak az \u00e1ltal\u00e1nos objektum-orient\u00e1lt szeml\u00e9leten, ugyanakkor nagyban hozz\u00e1j\u00e1rulnak a j\u00f3l \u00e1tl\u00e1that\u00f3 \u00e9s k\u00f6nnyen karbantarthat\u00f3 k\u00f3d elk\u00e9sz\u00edt\u00e9s\u00e9hez. Ezek a k\u00f6vetkez\u0151k: Tulajdons\u00e1gok (properties) Deleg\u00e1tok (delegates) Esem\u00e9nyek (events) Attrib\u00fatumok (attributes) Generikus oszt\u00e1lyok (generics) Lambda kifejez\u00e9sek 1. Feladat \u2013 Tulajdons\u00e1g (property) \u00b6 A tulajdons\u00e1gok seg\u00edts\u00e9g\u00e9vel tipikusan (de nem kiz\u00e1r\u00f3lagosan) oszt\u00e1lyok tagv\u00e1ltoz\u00f3ihoz f\u00e9rhet\u00fcnk hozz\u00e1 szintaktikailag hasonl\u00f3 m\u00f3don, mintha egy hagyom\u00e1nyos tagv\u00e1ltoz\u00f3t \u00e9rn\u00e9nk el. A hozz\u00e1f\u00e9r\u00e9s sor\u00e1n azonban lehet\u0151s\u00e9g\u00fcnk van arra, hogy az egyszer\u0171 \u00e9rt\u00e9k lek\u00e9rdez\u00e9s vagy be\u00e1ll\u00edt\u00e1s helyett met\u00f3dusszer\u0171en implement\u00e1ljuk a v\u00e1ltoz\u00f3 el\u00e9r\u00e9s\u00e9nek a m\u00f3dj\u00e1t. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy Person nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy embert reprezent\u00e1l. K\u00e9t tagv\u00e1ltoz\u00f3ja van, name \u00e9s age . A tagv\u00e1ltoz\u00f3khoz k\u00f6zvetlen\u00fcl nem f\u00e9rhet\u00fcnk hozz\u00e1 (mivel priv\u00e1tok), csak a Name , illetve Age publikus tulajdons\u00e1gokon kereszt\u00fcl kezelhetj\u00fck \u0151ket. A p\u00e9lda j\u00f3l szeml\u00e9lteti, hogy a .NET-es tulajdons\u00e1gok egy\u00e9rtelm\u0171en megfelelnek a C++-b\u00f3l \u00e9s Java-b\u00f3l m\u00e1r j\u00f3l ismert SetX(\u2026) illetve GetX() t\u00edpus\u00fa met\u00f3dusoknak, csak itt ez a megold\u00e1s egys\u00e9gbez\u00e1rtabb m\u00f3don nyelvi szinten t\u00e1mogatott. Hozzunk l\u00e9tre egy \u00faj C# konzolos alkalmaz\u00e1st. .NET Core alap\u00fat, vagyis ne .NET Framework-\u00f6set: Erre az els\u0151 gyakorlat alkalm\u00e1val l\u00e1ttunk p\u00e9ld\u00e1t, le\u00edr\u00e1sa annak \u00fatmutat\u00f3j\u00e1ban szerepel. A \" Do not use top level statements \" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be a projekt l\u00e9trehoz\u00e1s sor\u00e1n. Adjunk hozz\u00e1 egy \u00faj oszt\u00e1lyt az alkalmaz\u00e1sunkhoz Person n\u00e9ven. (\u00daj oszt\u00e1ly hozz\u00e1ad\u00e1s\u00e1hoz a Solution Explorerben kattintsunk jobb eg\u00e9rgombbal a projekt f\u00e1jlra \u00e9s v\u00e1lasszuk az \u201eAdd / class\u201d men\u00fcpontot. Az el\u0151ugr\u00f3 ablakban a l\u00e9trehozand\u00f3 f\u00e1jl nev\u00e9t m\u00f3dos\u00edtsuk Person.cs -re, majd nyomjuk meg az Add gombot.) Tegy\u00fck az oszt\u00e1lyt publikuss\u00e1. Ehhez az oszt\u00e1ly neve el\u00e9 be kell \u00edrni a public kulcssz\u00f3t. Erre a m\u00f3dos\u00edt\u00e1sra itt val\u00f3j\u00e1ban m\u00e9g nem volna sz\u00fcks\u00e9g, ugyanakkor a 4. feladat m\u00e1r egy publikus oszt\u00e1lyt fog ig\u00e9nyelni. Hozzunk l\u00e9tre az oszt\u00e1lyon bel\u00fcl egy int t\u00edpus\u00fa age nev\u0171 mez\u0151t \u00e9s egy ezt el\u00e9rhet\u0151v\u00e9 tev\u0151 Age tulajdons\u00e1got. public class Person { private int age ; public int Age { get { return age ; } set { age = value ; } } } Eg\u00e9sz\u00edts\u00fck ki a Program.cs f\u00e1jl Main f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj oszt\u00e1lyunkat. static void Main ( string [] args ) { Person p = new Person (); p . Age = 17 ; p . Age ++; Console . WriteLine ( p . Age ); } Futtassuk a programunkat (F5) L\u00e1thatjuk, hogy a tulajdons\u00e1g a tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an haszn\u00e1lhat\u00f3. A tulajdons\u00e1g lek\u00e9rdez\u00e9se eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt get r\u00e9sz fog lefutni, \u00e9s a tulajdons\u00e1g \u00e9rt\u00e9ke a return \u00e1ltal visszaadott \u00e9rt\u00e9k lesz. A tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sa eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt set r\u00e9sz fog lefutni, \u00e9s a speci\u00e1lis value v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke ebben a szakaszban megfelel a tulajdons\u00e1gnak \u00e9rt\u00e9k\u00fcl adott kifejez\u00e9ssel. Figyelj\u00fck meg a fenti megold\u00e1sban azt, hogy milyen eleg\u00e1nsan tudjuk egy \u00e9vvel megemelni az ember \u00e9letkor\u00e1t. Java, vagy C++ k\u00f3dban egy hasonl\u00f3 m\u0171veletet a p.setAge(p.getAge()+1) form\u00e1ban \u00edrhattunk volna le, amely jelent\u0151sen k\u00f6r\u00fclm\u00e9nyesebb \u00e9s nehezen olvashat\u00f3bb szintaktika a fentin\u00e9l. A tulajdons\u00e1gok haszn\u00e1lat\u00e1nak legf\u0151bb hozad\u00e9ka, hogy k\u00f3dunk szintaktikailag tiszt\u00e1bb lesz, az \u00e9rt\u00e9kad\u00e1sok illetve lek\u00e9rdez\u00e9sek pedig az esetek t\u00f6bbs\u00e9g\u00e9ben j\u00f3l elv\u00e1lnak a t\u00e9nyleges f\u00fcggv\u00e9nyh\u00edv\u00e1sokt\u00f3l. Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a programunk val\u00f3ban elv\u00e9gzi a get \u00e9s set r\u00e9szek h\u00edv\u00e1s\u00e1t. Ehhez helyezz\u00fcnk t\u00f6r\u00e9spontokat (breakpoint) a getter \u00e9s setter blokkok belsej\u00e9be a k\u00f3dszerkeszt\u0151 bal sz\u00e9l\u00e9n l\u00e1that\u00f3 sz\u00fcrke s\u00e1vra kattintva. Futtassuk a programot l\u00e9p\u00e9sr\u0151l l\u00e9p\u00e9sre. Ehhez a programot F5 helyett az F11 billenty\u0171vel ind\u00edtsuk, majd az F11 tov\u00e1bbi megnyom\u00e1saival engedj\u00fck sorr\u00f3l sorra a v\u00e9grehajt\u00e1st. L\u00e1thatjuk, hogy a programunk val\u00f3ban minden egyes alkalommal megh\u00edvja a gettert, amikor \u00e9rt\u00e9klek\u00e9rdez\u00e9s, illetve a settert, amikor \u00e9rt\u00e9kbe\u00e1ll\u00edt\u00e1s t\u00f6rt\u00e9nik. A setter f\u00fcggv\u00e9nyek egyik fontos funkci\u00f3ja, hogy lehet\u0151s\u00e9get k\u00edn\u00e1lnak az \u00e9rt\u00e9kvalid\u00e1ci\u00f3ra. Eg\u00e9sz\u00edts\u00fck ki ennek szellem\u00e9ben az Age tulajdons\u00e1g setter-\u00e9t. public int Age { get { return age ; } set { if ( value < 0 ) throw new Exception ( \"\u00c9rv\u00e9nytelen \u00e9letkor!\" ); age = value ; } } Figyelj\u00fck meg, hogy m\u00edg az egyszer\u0171 getter \u00e9s setter eset\u00e9ben az \u00e9rt\u00e9klek\u00e9rdez\u00e9st/be\u00e1ll\u00edt\u00e1st egy sorban tartjuk, addig komplexebb t\u00f6rzs eset\u00e9n m\u00e1r t\u00f6bb sorra t\u00f6rdelj\u00fck. Az alkalmaz\u00e1s tesztel\u00e9s\u00e9hez rendelj\u00fcnk hozz\u00e1 negat\u00edv \u00e9rt\u00e9ket az \u00e9letkorhoz a Program oszt\u00e1ly Main f\u00fcggv\u00e9ny\u00e9ben. p . Age = - 2 ; Futtassuk a programot, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy az ellen\u0151rz\u00e9s helyesen m\u0171k\u00f6dik, majd a tov\u00e1bbi munka kedv\u00e9\u00e9rt h\u00e1r\u00edtsuk el a hib\u00e1t azzal, hogy pozit\u00edvra cser\u00e9lj\u00fck a be\u00e1ll\u00edtott \u00e9letkort. p . Age = 2 ; A mindennapi munk\u00e1nk sor\u00e1n tal\u00e1lkozhatunk a tulajdons\u00e1goknak egy sokkal t\u00f6m\u00f6rebb szintaktik\u00e1j\u00e1val is. Ez a szintaktika akkor alkalmazhat\u00f3, ha egy olyan tulajdons\u00e1got szeretn\u00e9nk l\u00e9trehozni, melyben: nincs sz\u00fcks\u00e9g\u00fcnk a priv\u00e1t tagv\u00e1ltoz\u00f3 k\u00f6zvetlen el\u00e9r\u00e9s\u00e9re nem szeretn\u00e9nk semmilyen kieg\u00e9sz\u00edt\u0151 logik\u00e1val ell\u00e1tni a getter \u00e9s setter met\u00f3dusokat Erre n\u00e9zz\u00fcnk a k\u00f6vetkez\u0151kben p\u00e9ld\u00e1t. Eg\u00e9sz\u00edts\u00fck ki a Person oszt\u00e1lyunkat egy ilyen, \u00fan. \u201eautoimplement\u00e1lt\u201d tulajdons\u00e1ggal (auto-implemented property) . Sz\u00farjuk be a k\u00f6vetkez\u0151 sort k\u00f6zvetlen\u00fcl az Age tulajdons\u00e1g z\u00e1r\u00f3 kapcsos z\u00e1r\u00f3jel\u00e9t k\u00f6vet\u0151en: public string Name { get ; set ; } Autoimplemet\u00e1lt tulajdons\u00e1g eset\u00e9n a ford\u00edt\u00f3 egy rejtett, k\u00f3db\u00f3l nem el\u00e9rhet\u0151 v\u00e1ltoz\u00f3t gener\u00e1l az oszt\u00e1lyba, mely a tulajdons\u00e1g aktu\u00e1lis \u00e9rt\u00e9k\u00e9nek t\u00e1rol\u00e1s\u00e1ra szolg\u00e1l. Most ellen\u0151rizz\u00fck a m\u0171k\u00f6d\u00e9s\u00e9t a Main f\u00fcggv\u00e9ny kieg\u00e9sz\u00edt\u00e9s\u00e9vel. static void Main ( string [] args ) { \u2026 p . Name = \"Luke\" ; \u2026 Console . WriteLine ( p . Name ); } Note A tov\u00e1bbi feladatok \u00e9p\u00edteni fognak az el\u0151z\u0151 feladatok v\u00e9geredm\u00e9nyeire. Ha programod nem fordul le, vagy nem megfelel\u0151en m\u0171k\u00f6dik, jelezd ezt a gyakorlatvezet\u0151dnek a feladatok v\u00e9g\u00e9n, \u00e9s seg\u00edt elh\u00e1r\u00edtani a hib\u00e1t. 2. Feladat \u2013 Deleg\u00e1t (delegate, met\u00f3dusreferencia) \u00b6 A deleg\u00e1tok t\u00edpusos met\u00f3dusreferenci\u00e1kat jelentenek .NET-ben, a C/C++ f\u00fcggv\u00e9nypointerek modern megfelel\u0151i. Egy deleg\u00e1t defini\u00e1l\u00e1s\u00e1val egy olyan v\u00e1ltoz\u00f3t defini\u00e1lunk, amellyel r\u00e1mutathatunk egy olyan met\u00f3dusra, amely t\u00edpusa (param\u00e9terlist\u00e1ja \u00e9s visszat\u00e9r\u00e9si \u00e9rt\u00e9ke) megfelel a deleg\u00e1t t\u00edpus\u00e1nak. A deleg\u00e1t megh\u00edv\u00e1s\u00e1val az \u00e9rt\u00e9k\u00fcl adott (beregisztr\u00e1lt) met\u00f3dus automatikusan megh\u00edv\u00f3dik. A deleg\u00e1tok haszn\u00e1lat\u00e1nak egyik el\u0151nye az, hogy fut\u00e1si id\u0151ben d\u00f6nthetj\u00fck el, hogy t\u00f6bb met\u00f3dus k\u00f6z\u00fcl \u00e9ppen melyiket szeretn\u00e9nk megh\u00edvni. N\u00e9h\u00e1ny p\u00e9lda deleg\u00e1tok haszn\u00e1lat\u00e1ra: egy univerz\u00e1lis sorrendez\u0151 f\u00fcggv\u00e9nynek param\u00e9terk\u00e9nt az elemek \u00f6sszehasonl\u00edt\u00e1s\u00e1t v\u00e9gz\u0151 f\u00fcggv\u00e9ny \u00e1tad\u00e1sa, egy \u00e1ltal\u00e1nos gy\u0171jtem\u00e9nyen univerz\u00e1lis sz\u0171r\u00e9si logika megval\u00f3s\u00edt\u00e1sa, melynek param\u00e9terben egy deleg\u00e1t form\u00e1j\u00e1ban adjuk \u00e1t azt a f\u00fcggv\u00e9nyt, amely eld\u00f6nti, hogy egy elemet bele kell-e venni a sz\u0171rt list\u00e1ba, a publish-subscribe minta megval\u00f3s\u00edt\u00e1sa, amikor bizonyos objektumok m\u00e1s objektumokat \u00e9rtes\u00edtenek bizonyos magukkal kapcsolatos esem\u00e9nyek bek\u00f6vetkez\u00e9s\u00e9r\u0151l. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1nkban lehet\u0151v\u00e9 tessz\u00fck, hogy a kor\u00e1bban l\u00e9trehozott Person oszt\u00e1ly objektumai szabadon \u00e9rtes\u00edthess\u00e9k m\u00e1s oszt\u00e1lyok objektumait arr\u00f3l, ha egy szem\u00e9ly \u00e9letkora megv\u00e1ltozott. Ennek \u00e9rdek\u00e9ben bevezet\u00fcnk egy deleg\u00e1t t\u00edpust ( AgeChangingDelegate ), mely param\u00e9terlist\u00e1j\u00e1ban \u00e1t tudja adni az ember\u00fcnk \u00e9letkor\u00e1nak aktu\u00e1lis, illetve \u00faj \u00e9rt\u00e9k\u00e9t. Ezt k\u00f6vet\u0151en l\u00e9trehozunk egy publikus AgeChangingDelegate t\u00edpus\u00fa mez\u0151t a Person oszt\u00e1lyban, mely lehet\u0151v\u00e9 teszi, hogy egy k\u00fcls\u0151 f\u00e9l megadhassa azt a f\u00fcggv\u00e9nyt, amelyen kereszt\u00fcl az adott Person p\u00e9ld\u00e1ny v\u00e1ltoz\u00e1sair\u00f3l \u00e9rtes\u00edt\u00e9st k\u00e9r. Hozzunk l\u00e9tre egy \u00faj deleg\u00e1t t\u00edpust , mely void visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171, \u00e9s k\u00e9t darab int param\u00e9tert elv\u00e1r\u00f3 f\u00fcggv\u00e9nyre tud hivatkozni. Figyelj\u00fcnk r\u00e1, hogy az \u00faj t\u00edpust a Program oszt\u00e1ly el\u0151tt, k\u00f6zvetlen\u00fcl a n\u00e9vt\u00e9r scope-j\u00e1ban defini\u00e1ljuk! namespace PropertyDemo { public delegate void AgeChangingDelegate ( int oldAge , int newAge ); class Program { \u2026 Az AgeChangingDelegate egy t\u00edpus, mely b\u00e1rhol szerepelhet, ahol t\u00edpus \u00e1llhat (pl. lehet l\u00e9trehozni ez alapj\u00e1n tagv\u00e1ltoz\u00f3t, lok\u00e1lis v\u00e1ltoz\u00f3t, f\u00fcggv\u00e9ny param\u00e9tert stb.). Tegy\u00fck lehet\u0151v\u00e9, hogy a Person objektumai r\u00e1mutathassanak tetsz\u0151leges, a fenti szignat\u00far\u00e1nak megfelel\u0151 f\u00fcggv\u00e9nyre. Ehhez hozzunk l\u00e9tre egy AgeChangingDelegate t\u00edpus\u00fa mez\u0151t a Person oszt\u00e1lyban! class Person { public AgeChangingDelegate AgeChanging ; \u2026 Note Megjegyz\u00e9s: a publikus mez\u0151k\u00e9nt l\u00e9trehozott met\u00f3dusreferencia val\u00f3j\u00e1ban (egyel\u0151re) s\u00e9rti az OO elveket. Erre k\u00e9s\u0151bb visszat\u00e9r\u00fcnk m\u00e9g. H\u00edvjuk meg a f\u00fcggv\u00e9nyt minden alkalommal, amikor az ember\u00fcnk kora megv\u00e1ltozik. Ehhez eg\u00e9sz\u00edts\u00fck ki az Age tulajdons\u00e1g setter\u00e9t a k\u00f6vetkez\u0151kkel. public int Age { get { return age ; } set { if ( value < 0 ) throw new Exception ( \"\u00c9rv\u00e9nytelen \u00e9letkor!\" ); if ( AgeChanging != null ) AgeChanging ( age , value ); age = value ; } } A fenti k\u00f3dr\u00e9szlet sz\u00e1mos fontos szab\u00e1lyt demonstr\u00e1l: A valid\u00e1ci\u00f3s logika \u00e1ltal\u00e1ban megel\u0151zi az \u00e9rtes\u00edt\u00e9si logik\u00e1t. Az \u00e9rtes\u00edt\u00e9si logika jelleg\u00e9t\u0151l f\u00fcgg, hogy az \u00e9rt\u00e9kad\u00e1s el\u0151tt, vagy ut\u00e1n futtatjuk le (ebben az esetben, mivel a \u201echanging\u201d sz\u00f3 egy.folyamatban l\u00e9v\u0151 dologra utal, az \u00e9rtes\u00edt\u00e9s megel\u0151zi az \u00e9rt\u00e9kad\u00e1st) Fel kell k\u00e9sz\u00fcln\u00fcnk r\u00e1, hogy a delegate t\u00edpus\u00fa mez\u0151nkh\u00f6z m\u00e9g senki nem rendelt \u00e9rt\u00e9ket (nincs egy subscriber/el\u0151fizet\u0151 sem). Ilyen esetekben a megh\u00edv\u00e1suk kiv\u00e9telt okozna, ez\u00e9rt megh\u00edv\u00e1s el\u0151tt mindig ellen\u0151rizni kell, hogy a mez\u0151 \u00e9rt\u00e9ke null-e. Az esem\u00e9ny els\u00fct\u00e9sekor a null vizsg\u00e1latot \u00e9s az esem\u00e9ny els\u00fct\u00e9st eleg\u00e1nsabb, t\u00f6m\u00f6rebb form\u00e1ban is meg tudjuk tenni a \u201e ?. \u201d null-conditional oper\u00e1torral: if ( AgeChanging != null ) AgeChanging ( age , value ); helyett AgeChanging ?. Invoke ( age , value ); Ez csak akkor s\u00fcti el az esem\u00e9nyt, ha nem null, egy\u00e9bk\u00e9nt semmit nem csin\u00e1l. Ez C# 6-t\u00f3l kezdve haszn\u00e1lhat\u00f3, de ma m\u00e1r ez a javasolt technika. Ha szigor\u00faan n\u00e9zz\u00fck, akkor csak akkor kellene els\u00fctni az esem\u00e9nyt, ha a kor val\u00f3ban v\u00e1ltozik is, vagyis a property set \u00e1g\u00e1ban meg kellene vizsg\u00e1lni, az \u00faj \u00e9rt\u00e9k egyezik-e a r\u00e9givel. Megold\u00e1s lehet, ha a setter els\u0151 sor\u00e1ban azonnal visszat\u00e9r\u00fcnk, ha az \u00faj \u00e9rt\u00e9k egyezik a r\u00e9givel: if ( age == value ) return ; \u2026 K\u00e9sz vagyunk a Person oszt\u00e1ly k\u00f3dj\u00e1val. T\u00e9rj\u00fcnk \u00e1t az el\u0151fizet\u0151re! Ehhez mindenek el\u0151tt a Program oszt\u00e1lyt kell kieg\u00e9sz\u00edten\u00fcnk egy \u00fajabb f\u00fcggv\u00e9nnyel. class Program { \u2026 static void PersonAgeChanging ( int oldAge , int newAge ) { Console . WriteLine ( oldAge + \" => \" + newAge ); } \u2026 } Tipp: Fokozottan \u00fcgyelj\u00fcnk r\u00e1, hogy az \u00faj f\u00fcggv\u00e9ny a megfelel\u0151 scope-ba ker\u00fclj\u00f6n! V\u00e9gezet\u00fcl iratkozzunk fel a v\u00e1ltoz\u00e1sk\u00f6vet\u00e9sre a Main f\u00fcggv\u00e9nyben! static void Main ( string [] args ) { Person p = new Person (); p . AgeChanging = new AgeChangingDelegate ( PersonAgeChanging ); \u2026 Futtassuk a programot! Figyelj\u00fck meg, hogy az esem\u00e9ny minden egyes setter fut\u00e1skor, \u00edgy az els\u0151 \u00e9rt\u00e9kad\u00e1skor \u00e9s az inkrement\u00e1l\u00e1skor egyar\u00e1nt lefut. A megold\u00e1sunk azonban m\u00e9g fejleszthet\u0151. Eg\u00e9sz\u00edts\u00fck ki a Main f\u00fcggv\u00e9nyt t\u00f6bbsz\u00f6ri feliratkoz\u00e1ssal, majd futtassuk a programot. p . AgeChanging = new AgeChangingDelegate ( PersonAgeChanging ); p . AgeChanging += new AgeChangingDelegate ( PersonAgeChanging ); p . AgeChanging += PersonAgeChanging ; // T\u00f6m\u00f6rebb szintaktika L\u00e1that\u00f3an minden egyes \u00e9rt\u00e9kv\u00e1ltoz\u00e1skor mind a h\u00e1rom beregisztr\u00e1lt/\u201efeliratkozott\u201d f\u00fcggv\u00e9ny lefut. Ez az\u00e9rt lehets\u00e9ges, mert a delegate t\u00edpus\u00fa mez\u0151k val\u00f3j\u00e1ban nem csup\u00e1n egy f\u00fcggv\u00e9ny-referenci\u00e1t, hanem egy f\u00fcggv\u00e9ny-referencia list\u00e1t tartalmaznak (\u00e9s tartanak karban). Figyelj\u00fck meg a fenti harmadik sorban, hogy a f\u00fcggv\u00e9nyreferenci\u00e1kat az el\u0151sz\u00f6r l\u00e1tottn\u00e1l t\u00f6m\u00f6rebb szintaxissal is le\u00edrhatjuk: csak a f\u00fcggv\u00e9ny nev\u00e9t adjuk meg a += oper\u00e1tor ut\u00e1n, a new AgeChangingDelegate(...) n\u00e9lk\u00fcl. Ett\u0151l f\u00fcggetlen\u00fcl ekkor is egy AgeChangingDelegate objektum fogja becsomagolni a PersonAgeChanging f\u00fcggv\u00e9nyeket a sz\u00ednfalak m\u00f6g\u00f6tt. Pr\u00f3b\u00e1ljuk ki a leiratkoz\u00e1st is (szabadon v\u00e1lasztott ponton), majd futtassuk a programot. p . AgeChanging -= PersonAgeChanging ; 3. Feladat \u2013 Esem\u00e9ny (event) \u00b6 Ahogyan a tulajdons\u00e1gok a getter \u00e9s setter met\u00f3dusoknak, addig a fent l\u00e1tott delegate mechanizmus a Java-b\u00f3l ismert Event Listener-eknek k\u00edn\u00e1lj\u00e1k egy a szintaktika tekintet\u00e9ben letisztultabb alternat\u00edv\u00e1j\u00e1t. A fenti megold\u00e1sunk azonban egyel\u0151re m\u00e9g s\u00falyosan s\u00e9rt p\u00e1r OO elvet (egys\u00e9gbez\u00e1r\u00e1s, inform\u00e1ci\u00f3rejt\u00e9s). Ezt az al\u00e1bbi k\u00e9t p\u00e9ld\u00e1val tudjuk demonstr\u00e1lni. Az esem\u00e9nyt val\u00f3j\u00e1ban k\u00edv\u00fclr\u0151l (m\u00e1s oszt\u00e1lyok m\u0171veletib\u0151l) is ki tudjuk v\u00e1ltani. Ez szerencs\u00e9tlen, hisz \u00edgy az esem\u00e9nyre feliratkozott f\u00fcggv\u00e9nyeken kereszt\u00fcl az oszt\u00e1ly nev\u00e9ben hamis adatokat k\u00f6z\u00f6lhet\u00fcnk. Ennek demonstr\u00e1l\u00e1s\u00e1ra sz\u00farjuk be a k\u00f6vetkez\u0151 sort a Main f\u00fcggv\u00e9ny v\u00e9g\u00e9re. p . AgeChanging ( 67 , 12 ); Itt a p szem\u00e9ly objektum vonatkoz\u00e1s\u00e1ban egy \"kamu\" \u00e9letkorv\u00e1ltoz\u00e1s esem\u00e9nyt v\u00e1ltottunk ki a Person , becsapva minden el\u0151fizet\u0151t. A j\u00f3 megold\u00e1s az lenne, ha az esem\u00e9nyt csak a Person oszt\u00e1ly m\u0171veletei tudn\u00e1k kiv\u00e1ltani. B\u00e1r a += \u00e9s a -= tekintettel vannak a list\u00e1ba feliratkozott t\u00f6bbi f\u00fcggv\u00e9nyre, val\u00f3j\u00e1ban az = oper\u00e1torral b\u00e1rmikor fel\u00fcl\u00edrhatjuk (kit\u00f6r\u00f6lhetj\u00fck) m\u00e1sok feliratkoz\u00e1sait. Pr\u00f3b\u00e1ljuk ki ezt is, a k\u00f6vetkez\u0151 sor besz\u00far\u00e1s\u00e1val (k\u00f6zvetlen\u00fcl a fel \u00e9s leiratkoz\u00e1sok ut\u00e1n sz\u00farjuk be). p . AgeChanging = null ; L\u00e1ssuk el az event kulcssz\u00f3val az AgeChanging mez\u0151t Person.cs -ben! class Person { public event AgeChangingDelegate AgeChanging ; \u2026 Az event kulcssz\u00f3 feladata val\u00f3j\u00e1ban az, hogy a fenti k\u00e9t jelens\u00e9get megtiltva visszak\u00e9nyszer\u00edtse programunkat az objektumorient\u00e1lt mederbe. Pr\u00f3b\u00e1ljuk meg leford\u00edtani a programot. L\u00e1tni fogjuk, hogy a ford\u00edt\u00f3 a kor\u00e1bbi kih\u00e1g\u00e1sainkat most m\u00e1r ford\u00edt\u00e1si hibak\u00e9nt kezeli. T\u00e1vol\u00edtsuk el a h\u00e1rom hib\u00e1s k\u00f3dsort (figyelj\u00fck meg, hogy m\u00e1r az els\u0151 k\u00f6zvetlen \u00e9rt\u00e9kad\u00e1s is hib\u00e1nak min\u0151s\u00fcl), majd ford\u00edtsuk le \u00e9s futtassuk az alkalmaz\u00e1sunkat! 4. Feladat \u2013 Attrib\u00fatumok \u00b6 A z attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel deklarat\u00edv m\u00f3don metaadatokkal l\u00e1thatjuk el forr\u00e1sk\u00f3dunkat . Az attrib\u00fatum is tulajdonk\u00e9ppen egy oszt\u00e1ly, melyet hozz\u00e1k\u00f6t\u00fcnk a program egy megadott elem\u00e9hez (t\u00edpushoz, oszt\u00e1lyhoz, interf\u00e9szhez, met\u00f3dushoz, \u2026). Ezeket a metainform\u00e1ci\u00f3kat a program fut\u00e1sa k\u00f6zben b\u00e1rki (ak\u00e1r mi magunk is) kiolvashatja az \u00fagynevezett reflection mechanizmus seg\u00edts\u00e9g\u00e9vel. Az attrib\u00fatumok a Java annot\u00e1ci\u00f3k .NET-beli megfelel\u0151inek is tekinthet\u0151k. A NET sz\u00e1mos be\u00e9p\u00edtett attrib\u00fatumot defini\u00e1l, melyek funkci\u00f3ja a legk\u00fcl\u00f6nb\u00f6z\u0151bb f\u00e9le lehet. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban haszn\u00e1lt attrib\u00fatumok p\u00e9ld\u00e1ul az XML soros\u00edt\u00f3val (serializer k\u00f6z\u00f6lnek k\u00fcl\u00f6nb\u00f6z\u0151 metainform\u00e1ci\u00f3kat. Sz\u00farjuk be a Main f\u00fcggv\u00e9ny v\u00e9g\u00e9re a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletet, majd futtassuk a programunkat! XmlSerializer serializer = new XmlSerializer ( typeof ( Person )); FileStream stream = new FileStream ( \"person.txt\" , FileMode . Create ); serializer . Serialize ( stream , p ); stream . Close (); // Process.Start(\"person.txt\"); A fenti p\u00e9ld\u00e1b\u00f3l az utols\u00f3 sor nem a soros\u00edt\u00f3 logika r\u00e9sze, csup\u00e1n egy frapp\u00e1ns megold\u00e1s arra, hogy a Windows alap\u00e9rtelmezett sz\u00f6vegf\u00e1jl n\u00e9zeget\u0151j\u00e9vel megnyissuk a keletkezett adat\u00e1llom\u00e1nyt. Ezt kipr\u00f3b\u00e1lhatjuk, de a haszn\u00e1lt .NET runtime-t\u00f3l \u00e9s az oper\u00e1ci\u00f3s rendszer\u00fcnkt\u0151l f\u00fcgg, t\u00e1mogatott-e. Ha nem, fut\u00e1s k\u00f6zben hib\u00e1t kapunk. Ez esetben hagyjuk kikommentezve, \u00e9s a person.txt f\u00e1jlt a f\u00e1jlrendszerben megkeresve k\u00e9zzel nyissuk meg (a Visual Studio mapp\u00e1nkban a \\bin\\Debug\\ alatt tal\u00e1lhat\u00f3 az .exe alkalmaz\u00e1sunk mellett. N\u00e9zz\u00fck meg a keletkezett f\u00e1jl szerkezet\u00e9t. Figyelj\u00fck meg, hogy minden tulajdons\u00e1g a nev\u00e9nek megfelel\u0151 XML elemre lett lek\u00e9pezve. .NET attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel olyan metaadatokkal l\u00e1thatjuk el a Person oszt\u00e1lyunkat, melyek k\u00f6zvetlen\u00fcl m\u00f3dos\u00edtj\u00e1k a soros\u00edt\u00f3 viselked\u00e9s\u00e9t. Az XmlRoot attrib\u00fatum lehet\u0151s\u00e9get k\u00edn\u00e1l a gy\u00f6k\u00e9relem \u00e1tnevez\u00e9s\u00e9re. Helyezz\u00fck el a Person oszt\u00e1ly f\u00f6l\u00e9! [XmlRoot(\"Szem\u00e9ly\")] public class Person { ... } Az XmlAttribute attrib\u00fatum jelzi a soros\u00edt\u00f3 sz\u00e1m\u00e1ra, hogy a jel\u00f6lt tulajdons\u00e1got ne xml elemre, hanem xml attrib\u00fatumra k\u00e9pezze le. L\u00e1ssuk el ezzel az Age tulajdons\u00e1got! [XmlAttribute(\"Kor\")] public int Age Az XmlIgnore attrib\u00fatum jelzi a soros\u00edt\u00f3nak, hogy a jel\u00f6lt tulajdons\u00e1g teljesen elhagyand\u00f3 az eredm\u00e9nyb\u0151l. Pr\u00f3b\u00e1ljuk ki a Name tulajdons\u00e1g f\u00f6l\u00f6tt. [XmlIgnore] public string Name { get ; set ; } Futtassuk az alkalmaz\u00e1sunkat! Hasonl\u00edtsuk \u00f6ssze az eredm\u00e9nyt a kor\u00e1bbiakkal. 5. Feladat \u2013 Deleg\u00e1t 2. \u00b6 A 2. \u00e9s 3. feladatokban a deleg\u00e1tokkal esem\u00e9ny alap\u00fa \u00fczenetk\u00fcld\u00e9st val\u00f3s\u00edtottunk meg. A deleg\u00e1tok haszn\u00e1lat\u00e1nak m\u00e1sik tipikus eset\u00e9ben a f\u00fcggv\u00e9nyreferenci\u00e1kat arra haszn\u00e1ljuk, hogy egy algoritmus vagy \u00f6sszetettebb m\u0171velet sz\u00e1m\u00e1ra egy el\u0151re nem defini\u00e1lt l\u00e9p\u00e9s implement\u00e1ci\u00f3j\u00e1t \u00e1tadjuk . A generikus lista oszt\u00e1ly ( List<T> ) FindAll f\u00fcggv\u00e9nye p\u00e9ld\u00e1ul k\u00e9pes arra, hogy visszaadjon egy \u00faj list\u00e1ban minden olyan elemet, mely egy adott felt\u00e9telnek eleget tesz. A konkr\u00e9t sz\u0171r\u00e9si felt\u00e9telt egy f\u00fcggv\u00e9ny form\u00e1j\u00e1ban adhatjuk meg param\u00e9terben (melyet a FindAll minden elemre megh\u00edv), mely igazat ad minden olyan elemre, amit az eredm\u00e9nylist\u00e1ban szeretn\u00e9nk l\u00e1tni. A f\u00fcggv\u00e9ny t\u00edpusa a k\u00f6vetkez\u0151 el\u0151re defini\u00e1lt delegate t\u00edpus: public delegate bool Predicate < T >( T obj ) Vagyis bemenetk\u00e9nt egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t v\u00e1r, mint a listaelemek t\u00edpusa, kimenetk\u00e9nt pedig egy logikai \u00e9rt\u00e9ket. A fentiek demonstr\u00e1l\u00e1s\u00e1ra kieg\u00e9sz\u00edtj\u00fck a kor\u00e1bbi programunkat egy sz\u0171r\u00e9ssel, mely a list\u00e1b\u00f3l csak a p\u00e1ratlan elemeket fogja megtartani. Val\u00f3s\u00edtsunk meg egy olyan sz\u0171r\u0151f\u00fcggv\u00e9nyt az alkalmaz\u00e1sunkban, amely a p\u00e1ratlan sz\u00e1mokat adja vissza: static bool MyFilter ( int n ) { return n % 2 == 1 ; } Eg\u00e9sz\u00edts\u00fck ki a kor\u00e1bban \u00edrt k\u00f3dunkat a sz\u0171r\u0151 f\u00fcggv\u00e9ny\u00fcnk haszn\u00e1lat\u00e1val: List < int > list = new List < int >(); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); list = list . FindAll ( MyFilter ); foreach ( int n in list ) { Console . WriteLine ( $\"Value: {n}\" ); } Futtassuk az alkalmaz\u00e1sunkat. Figyelj\u00fck meg, hogy a konzolon val\u00f3ban csak a p\u00e1ratlan sz\u00e1mok jelennek meg. \u00c9rdekess\u00e9gk\u00e9nt elhelyezhet\u00fcnk egy t\u00f6r\u00e9spontot (breakpoint) a MyFilter f\u00fcggv\u00e9ny\u00fcnk belsej\u00e9ben \u00e9s megfigyelhetj\u00fck, hogy a f\u00fcggv\u00e9ny val\u00f3ban minden egyes listaelemre k\u00fcl\u00f6n-k\u00fcl\u00f6n megh\u00edv\u00f3dik. 6. Feladat \u2013 Lambda kifejez\u00e9sek \u00b6 Az \u00e9rintett t\u00e9mak\u00f6r\u00f6k az el\u0151ad\u00e1sanyagban r\u00e9szletesen szerepelnek, itt nem ism\u00e9telj\u00fck meg \u0151ket L\u00e1sd \u201eEl\u0151ad\u00e1s 02 - Modern nyelvi eszk\u00f6z\u00f6k.pdf\u201d dokumentum \u201eLambda expression (lambda kifejez\u00e9s)\u201d fejezete. A kulcselem a => (lambda oper\u00e1tor) seg\u00edts\u00e9g\u00e9vel lambda kifejez\u00e9sek , vagyis n\u00e9vtelen f\u00fcggv\u00e9nyek defini\u00e1l\u00e1sa. Note A .NET be\u00e9p\u00edtett Func \u00e9s Action generikus delegate t\u00edpusokra itt id\u0151 hi\u00e1ny\u00e1\u00e9ban nem t\u00e9r\u00fcnk ki. Az el\u0151z\u0151, 5. feladatot oldjuk meg a k\u00f6vetkez\u0151k\u00e9ppen: ne adjunk meg k\u00fcl\u00f6n sz\u0171r\u0151f\u00fcggv\u00e9nyt, hanem a sz\u0171r\u00e9si logik\u00e1t egy lambda kifejez\u00e9s form\u00e1j\u00e1ban adjuk meg a FindAll m\u0171veletnek. Ehhez mind\u00f6ssze egy sort kell megv\u00e1ltoztatni: list = list . FindAll ( ( int n ) => { return n % 2 == 1 ; } ); Egy n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyt defini\u00e1ltunk \u00e9s adtunk \u00e1t a FindAll m\u0171veletnek: Ez egy lambda kifejez\u00e9s A => bal oldal\u00e1n megadtuk a m\u0171velet param\u00e9tereket (itt csak egy volt) A => jobb oldal\u00e1n a m\u0171velet t\u00f6rzs\u00e9t (ugyanaz, mint a kor\u00e1bbi MyFilter t\u00f6rzse) A fenti sort j\u00f3val egyszer\u0171bb \u00e9s \u00e1ttekinthet\u0151bb form\u00e1ba is \u00edrhatjuk: list = list . FindAll ( n => n % 2 == 1 ); A k\u00f6vetkez\u0151 egyszer\u0171s\u00edt\u00e9seket eszk\u00f6z\u00f6lt\u00fck: A param\u00e9ter t\u00edpus\u00e1t nem \u00edrtuk ki (a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni a FindAll delegate param\u00e9ter t\u00edpus\u00e1b\u00f3l) A param\u00e9ter k\u00f6r\u00fcli z\u00e1r\u00f3jelet elhagyhattuk ( mert csak egy param\u00e9ter van) A => jobb oldal\u00e1n elhagyhattuk a {} z\u00e1r\u00f3jeleket \u00e9s a return -t (mert egyetlen kifejez\u00e9sb\u0151l \u00e1llt a f\u00fcggv\u00e9ny t\u00f6rzse, mellyel a f\u00fcggv\u00e9ny visszat\u00e9r) 7. Feladat \u2013 Generikus oszt\u00e1lyok \u00b6 Megjegyz\u00e9s: erre a feladatra j\u00f3 es\u00e9llyel nem marad id\u0151. Ez esetben c\u00e9lszer\u0171 a feladatot gyakorl\u00e1sk\u00e9ppen otthon elv\u00e9gezni. A .NET generikus oszt\u00e1lyai megfelelnek a C++ nyelv template oszt\u00e1lyainak (noha vannak jelent\u0151sebb k\u00fcl\u00f6nbs\u00e9gek a m\u0171k\u00f6d\u00e9s\u00fckben). A seg\u00edts\u00e9g\u00fckkel \u00e1ltal\u00e1nos (t\u00f6bb t\u00edpusra is m\u0171k\u00f6d\u0151), de ugyanakkor t\u00edpusbiztos oszt\u00e1lyokat hozhatunk l\u00e9tre. Generikus oszt\u00e1lyok n\u00e9lk\u00fcl, ha \u00e1ltal\u00e1nosan szeretn\u00e9nk kezelni egy probl\u00e9m\u00e1t, akkor object t\u00edpus\u00fa adatokat haszn\u00e1lunk (mert .NET-ben minden oszt\u00e1ly az object oszt\u00e1lyb\u00f3l sz\u00e1rmazik). Ez a helyzet p\u00e9ld\u00e1ul az ArrayList -tel is, ami egy \u00e1ltal\u00e1nos c\u00e9l\u00fa gy\u0171jtem\u00e9ny, tetsz\u0151leges, object t\u00edpus\u00fa elemek t\u00e1rol\u00e1s\u00e1ra alkalmas. L\u00e1ssunk egy p\u00e9ld\u00e1t az ArrayList haszn\u00e1lat\u00e1ra: ArrayList list = new ArrayList (); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); for ( int n = 0 ; n < list . Count ; n ++) { // Castolni kell, k\u00fcl\u00f6nben nem fordul int i = ( int ) list [ n ]; Console . WriteLine ( $\"Value: {i}\" ); } A fenti megold\u00e1ssal a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k ad\u00f3dnak: Az ArrayList minden egyes elemet object -k\u00e9nt t\u00e1rol. Amikor hozz\u00e1 szeretn\u00e9nk f\u00e9rni a lista egy elem\u00e9hez, mindig a megfelel\u0151 t\u00edpus\u00fav\u00e1 kell cast-olni. Nem t\u00edpusbiztos. A fenti p\u00e9ld\u00e1ban semmi nem akad\u00e1lyoz meg abban (\u00e9s semmilyen hiba\u00fczenet sem jelzi), hogy az int t\u00edpus\u00fa adatok mell\u00e9 besz\u00farjunk a list\u00e1ba egy m\u00e1sik t\u00edpus\u00fa objektumot. Ilyenkor csak a lista bej\u00e1r\u00e1sa sor\u00e1n kapn\u00e1nk hib\u00e1t, amikor a nem int t\u00edpust int t\u00edpus\u00fara pr\u00f3b\u00e1lunk castolni. Generikus gy\u0171jtem\u00e9nyek haszn\u00e1latakor az ilyen hib\u00e1k m\u00e1r a ford\u00edt\u00e1s sor\u00e1n kider\u00fclnek. \u00c9rt\u00e9k t\u00edpus\u00fa adatok t\u00e1rol\u00e1sakor a lista lassabban m\u0171k\u00f6dik, mert az \u00e9rt\u00e9k t\u00edpust el\u0151sz\u00f6r be kell dobozolni (boxing), hogy az object -k\u00e9nt (azaz referencia t\u00edpusk\u00e9nt) t\u00e1rolhat\u00f3 legyen. A fenti probl\u00e9ma megold\u00e1sa egy generikus lista haszn\u00e1lat\u00e1val a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki (a gyakorlat sor\u00e1n csak a kiemelt sort m\u00f3dos\u00edtsuk a kor\u00e1bban beg\u00e9pelt p\u00e9ld\u00e1ban): List < int > list = new List < int >(); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); for ( int n = 0 ; n < list . Count ; n ++) { int i = list [ n ]; // Nem kell cast-olni Console . WriteLine ( $\"Value: {i}\" ); }","title":"2. Nyelvi eszk\u00f6z\u00f6k"},{"location":"labor/2-nyelvi-eszkozok/#2-nyelvi-eszkozok","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.31 Kidolgozta: K\u0151v\u00e1ri Bence, Benedek Zolt\u00e1n","title":"2. Nyelvi eszk\u00f6z\u00f6k"},{"location":"labor/2-nyelvi-eszkozok/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja az al\u00e1bbi C# nyelvi elemek megismer\u00e9se: Tulajdons\u00e1g (property) Deleg\u00e1t (delegate, met\u00f3dusreferencia) Esem\u00e9ny (event) Attrib\u00fatum (attribute) Lambda kifejez\u00e9s Generikus t\u00edpus (generic type) Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: a 2. el\u0151ad\u00e1s \u00e9s a 3. el\u0151ad\u00e1s eleje \u2013 (Modern) programoz\u00e1si eszk\u00f6z\u00f6k.","title":"A gyakorlat c\u00e9lja"},{"location":"labor/2-nyelvi-eszkozok/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022","title":"El\u0151felt\u00e9telek"},{"location":"labor/2-nyelvi-eszkozok/#bevezeto","text":"A gyakorlat sor\u00e1n a hallgat\u00f3k megismerkednek a legfontosabb modern, a .NET k\u00f6rnyezetben is rendelkez\u00e9sre \u00e1ll\u00f3 nyelvi eszk\u00f6z\u00f6kkel. Felt\u00e9telezz\u00fck, hogy a hallgat\u00f3 a kor\u00e1bbi tanulm\u00e1nyai sor\u00e1n elsaj\u00e1t\u00edtotta az objektum-orient\u00e1lt szeml\u00e9letm\u00f3dot, \u00e9s tiszt\u00e1ban van az objektum-orient\u00e1lt alapfogalmakkal. Jelen gyakorlat sor\u00e1n azokra a .NET-es nyelvi elemekre koncentr\u00e1lunk, amelyek t\u00falmutatnak az \u00e1ltal\u00e1nos objektum-orient\u00e1lt szeml\u00e9leten, ugyanakkor nagyban hozz\u00e1j\u00e1rulnak a j\u00f3l \u00e1tl\u00e1that\u00f3 \u00e9s k\u00f6nnyen karbantarthat\u00f3 k\u00f3d elk\u00e9sz\u00edt\u00e9s\u00e9hez. Ezek a k\u00f6vetkez\u0151k: Tulajdons\u00e1gok (properties) Deleg\u00e1tok (delegates) Esem\u00e9nyek (events) Attrib\u00fatumok (attributes) Generikus oszt\u00e1lyok (generics) Lambda kifejez\u00e9sek","title":"Bevezet\u0151"},{"location":"labor/2-nyelvi-eszkozok/#1-feladat-tulajdonsag-property","text":"A tulajdons\u00e1gok seg\u00edts\u00e9g\u00e9vel tipikusan (de nem kiz\u00e1r\u00f3lagosan) oszt\u00e1lyok tagv\u00e1ltoz\u00f3ihoz f\u00e9rhet\u00fcnk hozz\u00e1 szintaktikailag hasonl\u00f3 m\u00f3don, mintha egy hagyom\u00e1nyos tagv\u00e1ltoz\u00f3t \u00e9rn\u00e9nk el. A hozz\u00e1f\u00e9r\u00e9s sor\u00e1n azonban lehet\u0151s\u00e9g\u00fcnk van arra, hogy az egyszer\u0171 \u00e9rt\u00e9k lek\u00e9rdez\u00e9s vagy be\u00e1ll\u00edt\u00e1s helyett met\u00f3dusszer\u0171en implement\u00e1ljuk a v\u00e1ltoz\u00f3 el\u00e9r\u00e9s\u00e9nek a m\u00f3dj\u00e1t. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy Person nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy embert reprezent\u00e1l. K\u00e9t tagv\u00e1ltoz\u00f3ja van, name \u00e9s age . A tagv\u00e1ltoz\u00f3khoz k\u00f6zvetlen\u00fcl nem f\u00e9rhet\u00fcnk hozz\u00e1 (mivel priv\u00e1tok), csak a Name , illetve Age publikus tulajdons\u00e1gokon kereszt\u00fcl kezelhetj\u00fck \u0151ket. A p\u00e9lda j\u00f3l szeml\u00e9lteti, hogy a .NET-es tulajdons\u00e1gok egy\u00e9rtelm\u0171en megfelelnek a C++-b\u00f3l \u00e9s Java-b\u00f3l m\u00e1r j\u00f3l ismert SetX(\u2026) illetve GetX() t\u00edpus\u00fa met\u00f3dusoknak, csak itt ez a megold\u00e1s egys\u00e9gbez\u00e1rtabb m\u00f3don nyelvi szinten t\u00e1mogatott. Hozzunk l\u00e9tre egy \u00faj C# konzolos alkalmaz\u00e1st. .NET Core alap\u00fat, vagyis ne .NET Framework-\u00f6set: Erre az els\u0151 gyakorlat alkalm\u00e1val l\u00e1ttunk p\u00e9ld\u00e1t, le\u00edr\u00e1sa annak \u00fatmutat\u00f3j\u00e1ban szerepel. A \" Do not use top level statements \" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be a projekt l\u00e9trehoz\u00e1s sor\u00e1n. Adjunk hozz\u00e1 egy \u00faj oszt\u00e1lyt az alkalmaz\u00e1sunkhoz Person n\u00e9ven. (\u00daj oszt\u00e1ly hozz\u00e1ad\u00e1s\u00e1hoz a Solution Explorerben kattintsunk jobb eg\u00e9rgombbal a projekt f\u00e1jlra \u00e9s v\u00e1lasszuk az \u201eAdd / class\u201d men\u00fcpontot. Az el\u0151ugr\u00f3 ablakban a l\u00e9trehozand\u00f3 f\u00e1jl nev\u00e9t m\u00f3dos\u00edtsuk Person.cs -re, majd nyomjuk meg az Add gombot.) Tegy\u00fck az oszt\u00e1lyt publikuss\u00e1. Ehhez az oszt\u00e1ly neve el\u00e9 be kell \u00edrni a public kulcssz\u00f3t. Erre a m\u00f3dos\u00edt\u00e1sra itt val\u00f3j\u00e1ban m\u00e9g nem volna sz\u00fcks\u00e9g, ugyanakkor a 4. feladat m\u00e1r egy publikus oszt\u00e1lyt fog ig\u00e9nyelni. Hozzunk l\u00e9tre az oszt\u00e1lyon bel\u00fcl egy int t\u00edpus\u00fa age nev\u0171 mez\u0151t \u00e9s egy ezt el\u00e9rhet\u0151v\u00e9 tev\u0151 Age tulajdons\u00e1got. public class Person { private int age ; public int Age { get { return age ; } set { age = value ; } } } Eg\u00e9sz\u00edts\u00fck ki a Program.cs f\u00e1jl Main f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj oszt\u00e1lyunkat. static void Main ( string [] args ) { Person p = new Person (); p . Age = 17 ; p . Age ++; Console . WriteLine ( p . Age ); } Futtassuk a programunkat (F5) L\u00e1thatjuk, hogy a tulajdons\u00e1g a tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an haszn\u00e1lhat\u00f3. A tulajdons\u00e1g lek\u00e9rdez\u00e9se eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt get r\u00e9sz fog lefutni, \u00e9s a tulajdons\u00e1g \u00e9rt\u00e9ke a return \u00e1ltal visszaadott \u00e9rt\u00e9k lesz. A tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sa eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt set r\u00e9sz fog lefutni, \u00e9s a speci\u00e1lis value v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke ebben a szakaszban megfelel a tulajdons\u00e1gnak \u00e9rt\u00e9k\u00fcl adott kifejez\u00e9ssel. Figyelj\u00fck meg a fenti megold\u00e1sban azt, hogy milyen eleg\u00e1nsan tudjuk egy \u00e9vvel megemelni az ember \u00e9letkor\u00e1t. Java, vagy C++ k\u00f3dban egy hasonl\u00f3 m\u0171veletet a p.setAge(p.getAge()+1) form\u00e1ban \u00edrhattunk volna le, amely jelent\u0151sen k\u00f6r\u00fclm\u00e9nyesebb \u00e9s nehezen olvashat\u00f3bb szintaktika a fentin\u00e9l. A tulajdons\u00e1gok haszn\u00e1lat\u00e1nak legf\u0151bb hozad\u00e9ka, hogy k\u00f3dunk szintaktikailag tiszt\u00e1bb lesz, az \u00e9rt\u00e9kad\u00e1sok illetve lek\u00e9rdez\u00e9sek pedig az esetek t\u00f6bbs\u00e9g\u00e9ben j\u00f3l elv\u00e1lnak a t\u00e9nyleges f\u00fcggv\u00e9nyh\u00edv\u00e1sokt\u00f3l. Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a programunk val\u00f3ban elv\u00e9gzi a get \u00e9s set r\u00e9szek h\u00edv\u00e1s\u00e1t. Ehhez helyezz\u00fcnk t\u00f6r\u00e9spontokat (breakpoint) a getter \u00e9s setter blokkok belsej\u00e9be a k\u00f3dszerkeszt\u0151 bal sz\u00e9l\u00e9n l\u00e1that\u00f3 sz\u00fcrke s\u00e1vra kattintva. Futtassuk a programot l\u00e9p\u00e9sr\u0151l l\u00e9p\u00e9sre. Ehhez a programot F5 helyett az F11 billenty\u0171vel ind\u00edtsuk, majd az F11 tov\u00e1bbi megnyom\u00e1saival engedj\u00fck sorr\u00f3l sorra a v\u00e9grehajt\u00e1st. L\u00e1thatjuk, hogy a programunk val\u00f3ban minden egyes alkalommal megh\u00edvja a gettert, amikor \u00e9rt\u00e9klek\u00e9rdez\u00e9s, illetve a settert, amikor \u00e9rt\u00e9kbe\u00e1ll\u00edt\u00e1s t\u00f6rt\u00e9nik. A setter f\u00fcggv\u00e9nyek egyik fontos funkci\u00f3ja, hogy lehet\u0151s\u00e9get k\u00edn\u00e1lnak az \u00e9rt\u00e9kvalid\u00e1ci\u00f3ra. Eg\u00e9sz\u00edts\u00fck ki ennek szellem\u00e9ben az Age tulajdons\u00e1g setter-\u00e9t. public int Age { get { return age ; } set { if ( value < 0 ) throw new Exception ( \"\u00c9rv\u00e9nytelen \u00e9letkor!\" ); age = value ; } } Figyelj\u00fck meg, hogy m\u00edg az egyszer\u0171 getter \u00e9s setter eset\u00e9ben az \u00e9rt\u00e9klek\u00e9rdez\u00e9st/be\u00e1ll\u00edt\u00e1st egy sorban tartjuk, addig komplexebb t\u00f6rzs eset\u00e9n m\u00e1r t\u00f6bb sorra t\u00f6rdelj\u00fck. Az alkalmaz\u00e1s tesztel\u00e9s\u00e9hez rendelj\u00fcnk hozz\u00e1 negat\u00edv \u00e9rt\u00e9ket az \u00e9letkorhoz a Program oszt\u00e1ly Main f\u00fcggv\u00e9ny\u00e9ben. p . Age = - 2 ; Futtassuk a programot, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy az ellen\u0151rz\u00e9s helyesen m\u0171k\u00f6dik, majd a tov\u00e1bbi munka kedv\u00e9\u00e9rt h\u00e1r\u00edtsuk el a hib\u00e1t azzal, hogy pozit\u00edvra cser\u00e9lj\u00fck a be\u00e1ll\u00edtott \u00e9letkort. p . Age = 2 ; A mindennapi munk\u00e1nk sor\u00e1n tal\u00e1lkozhatunk a tulajdons\u00e1goknak egy sokkal t\u00f6m\u00f6rebb szintaktik\u00e1j\u00e1val is. Ez a szintaktika akkor alkalmazhat\u00f3, ha egy olyan tulajdons\u00e1got szeretn\u00e9nk l\u00e9trehozni, melyben: nincs sz\u00fcks\u00e9g\u00fcnk a priv\u00e1t tagv\u00e1ltoz\u00f3 k\u00f6zvetlen el\u00e9r\u00e9s\u00e9re nem szeretn\u00e9nk semmilyen kieg\u00e9sz\u00edt\u0151 logik\u00e1val ell\u00e1tni a getter \u00e9s setter met\u00f3dusokat Erre n\u00e9zz\u00fcnk a k\u00f6vetkez\u0151kben p\u00e9ld\u00e1t. Eg\u00e9sz\u00edts\u00fck ki a Person oszt\u00e1lyunkat egy ilyen, \u00fan. \u201eautoimplement\u00e1lt\u201d tulajdons\u00e1ggal (auto-implemented property) . Sz\u00farjuk be a k\u00f6vetkez\u0151 sort k\u00f6zvetlen\u00fcl az Age tulajdons\u00e1g z\u00e1r\u00f3 kapcsos z\u00e1r\u00f3jel\u00e9t k\u00f6vet\u0151en: public string Name { get ; set ; } Autoimplemet\u00e1lt tulajdons\u00e1g eset\u00e9n a ford\u00edt\u00f3 egy rejtett, k\u00f3db\u00f3l nem el\u00e9rhet\u0151 v\u00e1ltoz\u00f3t gener\u00e1l az oszt\u00e1lyba, mely a tulajdons\u00e1g aktu\u00e1lis \u00e9rt\u00e9k\u00e9nek t\u00e1rol\u00e1s\u00e1ra szolg\u00e1l. Most ellen\u0151rizz\u00fck a m\u0171k\u00f6d\u00e9s\u00e9t a Main f\u00fcggv\u00e9ny kieg\u00e9sz\u00edt\u00e9s\u00e9vel. static void Main ( string [] args ) { \u2026 p . Name = \"Luke\" ; \u2026 Console . WriteLine ( p . Name ); } Note A tov\u00e1bbi feladatok \u00e9p\u00edteni fognak az el\u0151z\u0151 feladatok v\u00e9geredm\u00e9nyeire. Ha programod nem fordul le, vagy nem megfelel\u0151en m\u0171k\u00f6dik, jelezd ezt a gyakorlatvezet\u0151dnek a feladatok v\u00e9g\u00e9n, \u00e9s seg\u00edt elh\u00e1r\u00edtani a hib\u00e1t.","title":"1. Feladat \u2013 Tulajdons\u00e1g (property)"},{"location":"labor/2-nyelvi-eszkozok/#2-feladat-delegat-delegate-metodusreferencia","text":"A deleg\u00e1tok t\u00edpusos met\u00f3dusreferenci\u00e1kat jelentenek .NET-ben, a C/C++ f\u00fcggv\u00e9nypointerek modern megfelel\u0151i. Egy deleg\u00e1t defini\u00e1l\u00e1s\u00e1val egy olyan v\u00e1ltoz\u00f3t defini\u00e1lunk, amellyel r\u00e1mutathatunk egy olyan met\u00f3dusra, amely t\u00edpusa (param\u00e9terlist\u00e1ja \u00e9s visszat\u00e9r\u00e9si \u00e9rt\u00e9ke) megfelel a deleg\u00e1t t\u00edpus\u00e1nak. A deleg\u00e1t megh\u00edv\u00e1s\u00e1val az \u00e9rt\u00e9k\u00fcl adott (beregisztr\u00e1lt) met\u00f3dus automatikusan megh\u00edv\u00f3dik. A deleg\u00e1tok haszn\u00e1lat\u00e1nak egyik el\u0151nye az, hogy fut\u00e1si id\u0151ben d\u00f6nthetj\u00fck el, hogy t\u00f6bb met\u00f3dus k\u00f6z\u00fcl \u00e9ppen melyiket szeretn\u00e9nk megh\u00edvni. N\u00e9h\u00e1ny p\u00e9lda deleg\u00e1tok haszn\u00e1lat\u00e1ra: egy univerz\u00e1lis sorrendez\u0151 f\u00fcggv\u00e9nynek param\u00e9terk\u00e9nt az elemek \u00f6sszehasonl\u00edt\u00e1s\u00e1t v\u00e9gz\u0151 f\u00fcggv\u00e9ny \u00e1tad\u00e1sa, egy \u00e1ltal\u00e1nos gy\u0171jtem\u00e9nyen univerz\u00e1lis sz\u0171r\u00e9si logika megval\u00f3s\u00edt\u00e1sa, melynek param\u00e9terben egy deleg\u00e1t form\u00e1j\u00e1ban adjuk \u00e1t azt a f\u00fcggv\u00e9nyt, amely eld\u00f6nti, hogy egy elemet bele kell-e venni a sz\u0171rt list\u00e1ba, a publish-subscribe minta megval\u00f3s\u00edt\u00e1sa, amikor bizonyos objektumok m\u00e1s objektumokat \u00e9rtes\u00edtenek bizonyos magukkal kapcsolatos esem\u00e9nyek bek\u00f6vetkez\u00e9s\u00e9r\u0151l. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1nkban lehet\u0151v\u00e9 tessz\u00fck, hogy a kor\u00e1bban l\u00e9trehozott Person oszt\u00e1ly objektumai szabadon \u00e9rtes\u00edthess\u00e9k m\u00e1s oszt\u00e1lyok objektumait arr\u00f3l, ha egy szem\u00e9ly \u00e9letkora megv\u00e1ltozott. Ennek \u00e9rdek\u00e9ben bevezet\u00fcnk egy deleg\u00e1t t\u00edpust ( AgeChangingDelegate ), mely param\u00e9terlist\u00e1j\u00e1ban \u00e1t tudja adni az ember\u00fcnk \u00e9letkor\u00e1nak aktu\u00e1lis, illetve \u00faj \u00e9rt\u00e9k\u00e9t. Ezt k\u00f6vet\u0151en l\u00e9trehozunk egy publikus AgeChangingDelegate t\u00edpus\u00fa mez\u0151t a Person oszt\u00e1lyban, mely lehet\u0151v\u00e9 teszi, hogy egy k\u00fcls\u0151 f\u00e9l megadhassa azt a f\u00fcggv\u00e9nyt, amelyen kereszt\u00fcl az adott Person p\u00e9ld\u00e1ny v\u00e1ltoz\u00e1sair\u00f3l \u00e9rtes\u00edt\u00e9st k\u00e9r. Hozzunk l\u00e9tre egy \u00faj deleg\u00e1t t\u00edpust , mely void visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171, \u00e9s k\u00e9t darab int param\u00e9tert elv\u00e1r\u00f3 f\u00fcggv\u00e9nyre tud hivatkozni. Figyelj\u00fcnk r\u00e1, hogy az \u00faj t\u00edpust a Program oszt\u00e1ly el\u0151tt, k\u00f6zvetlen\u00fcl a n\u00e9vt\u00e9r scope-j\u00e1ban defini\u00e1ljuk! namespace PropertyDemo { public delegate void AgeChangingDelegate ( int oldAge , int newAge ); class Program { \u2026 Az AgeChangingDelegate egy t\u00edpus, mely b\u00e1rhol szerepelhet, ahol t\u00edpus \u00e1llhat (pl. lehet l\u00e9trehozni ez alapj\u00e1n tagv\u00e1ltoz\u00f3t, lok\u00e1lis v\u00e1ltoz\u00f3t, f\u00fcggv\u00e9ny param\u00e9tert stb.). Tegy\u00fck lehet\u0151v\u00e9, hogy a Person objektumai r\u00e1mutathassanak tetsz\u0151leges, a fenti szignat\u00far\u00e1nak megfelel\u0151 f\u00fcggv\u00e9nyre. Ehhez hozzunk l\u00e9tre egy AgeChangingDelegate t\u00edpus\u00fa mez\u0151t a Person oszt\u00e1lyban! class Person { public AgeChangingDelegate AgeChanging ; \u2026 Note Megjegyz\u00e9s: a publikus mez\u0151k\u00e9nt l\u00e9trehozott met\u00f3dusreferencia val\u00f3j\u00e1ban (egyel\u0151re) s\u00e9rti az OO elveket. Erre k\u00e9s\u0151bb visszat\u00e9r\u00fcnk m\u00e9g. H\u00edvjuk meg a f\u00fcggv\u00e9nyt minden alkalommal, amikor az ember\u00fcnk kora megv\u00e1ltozik. Ehhez eg\u00e9sz\u00edts\u00fck ki az Age tulajdons\u00e1g setter\u00e9t a k\u00f6vetkez\u0151kkel. public int Age { get { return age ; } set { if ( value < 0 ) throw new Exception ( \"\u00c9rv\u00e9nytelen \u00e9letkor!\" ); if ( AgeChanging != null ) AgeChanging ( age , value ); age = value ; } } A fenti k\u00f3dr\u00e9szlet sz\u00e1mos fontos szab\u00e1lyt demonstr\u00e1l: A valid\u00e1ci\u00f3s logika \u00e1ltal\u00e1ban megel\u0151zi az \u00e9rtes\u00edt\u00e9si logik\u00e1t. Az \u00e9rtes\u00edt\u00e9si logika jelleg\u00e9t\u0151l f\u00fcgg, hogy az \u00e9rt\u00e9kad\u00e1s el\u0151tt, vagy ut\u00e1n futtatjuk le (ebben az esetben, mivel a \u201echanging\u201d sz\u00f3 egy.folyamatban l\u00e9v\u0151 dologra utal, az \u00e9rtes\u00edt\u00e9s megel\u0151zi az \u00e9rt\u00e9kad\u00e1st) Fel kell k\u00e9sz\u00fcln\u00fcnk r\u00e1, hogy a delegate t\u00edpus\u00fa mez\u0151nkh\u00f6z m\u00e9g senki nem rendelt \u00e9rt\u00e9ket (nincs egy subscriber/el\u0151fizet\u0151 sem). Ilyen esetekben a megh\u00edv\u00e1suk kiv\u00e9telt okozna, ez\u00e9rt megh\u00edv\u00e1s el\u0151tt mindig ellen\u0151rizni kell, hogy a mez\u0151 \u00e9rt\u00e9ke null-e. Az esem\u00e9ny els\u00fct\u00e9sekor a null vizsg\u00e1latot \u00e9s az esem\u00e9ny els\u00fct\u00e9st eleg\u00e1nsabb, t\u00f6m\u00f6rebb form\u00e1ban is meg tudjuk tenni a \u201e ?. \u201d null-conditional oper\u00e1torral: if ( AgeChanging != null ) AgeChanging ( age , value ); helyett AgeChanging ?. Invoke ( age , value ); Ez csak akkor s\u00fcti el az esem\u00e9nyt, ha nem null, egy\u00e9bk\u00e9nt semmit nem csin\u00e1l. Ez C# 6-t\u00f3l kezdve haszn\u00e1lhat\u00f3, de ma m\u00e1r ez a javasolt technika. Ha szigor\u00faan n\u00e9zz\u00fck, akkor csak akkor kellene els\u00fctni az esem\u00e9nyt, ha a kor val\u00f3ban v\u00e1ltozik is, vagyis a property set \u00e1g\u00e1ban meg kellene vizsg\u00e1lni, az \u00faj \u00e9rt\u00e9k egyezik-e a r\u00e9givel. Megold\u00e1s lehet, ha a setter els\u0151 sor\u00e1ban azonnal visszat\u00e9r\u00fcnk, ha az \u00faj \u00e9rt\u00e9k egyezik a r\u00e9givel: if ( age == value ) return ; \u2026 K\u00e9sz vagyunk a Person oszt\u00e1ly k\u00f3dj\u00e1val. T\u00e9rj\u00fcnk \u00e1t az el\u0151fizet\u0151re! Ehhez mindenek el\u0151tt a Program oszt\u00e1lyt kell kieg\u00e9sz\u00edten\u00fcnk egy \u00fajabb f\u00fcggv\u00e9nnyel. class Program { \u2026 static void PersonAgeChanging ( int oldAge , int newAge ) { Console . WriteLine ( oldAge + \" => \" + newAge ); } \u2026 } Tipp: Fokozottan \u00fcgyelj\u00fcnk r\u00e1, hogy az \u00faj f\u00fcggv\u00e9ny a megfelel\u0151 scope-ba ker\u00fclj\u00f6n! V\u00e9gezet\u00fcl iratkozzunk fel a v\u00e1ltoz\u00e1sk\u00f6vet\u00e9sre a Main f\u00fcggv\u00e9nyben! static void Main ( string [] args ) { Person p = new Person (); p . AgeChanging = new AgeChangingDelegate ( PersonAgeChanging ); \u2026 Futtassuk a programot! Figyelj\u00fck meg, hogy az esem\u00e9ny minden egyes setter fut\u00e1skor, \u00edgy az els\u0151 \u00e9rt\u00e9kad\u00e1skor \u00e9s az inkrement\u00e1l\u00e1skor egyar\u00e1nt lefut. A megold\u00e1sunk azonban m\u00e9g fejleszthet\u0151. Eg\u00e9sz\u00edts\u00fck ki a Main f\u00fcggv\u00e9nyt t\u00f6bbsz\u00f6ri feliratkoz\u00e1ssal, majd futtassuk a programot. p . AgeChanging = new AgeChangingDelegate ( PersonAgeChanging ); p . AgeChanging += new AgeChangingDelegate ( PersonAgeChanging ); p . AgeChanging += PersonAgeChanging ; // T\u00f6m\u00f6rebb szintaktika L\u00e1that\u00f3an minden egyes \u00e9rt\u00e9kv\u00e1ltoz\u00e1skor mind a h\u00e1rom beregisztr\u00e1lt/\u201efeliratkozott\u201d f\u00fcggv\u00e9ny lefut. Ez az\u00e9rt lehets\u00e9ges, mert a delegate t\u00edpus\u00fa mez\u0151k val\u00f3j\u00e1ban nem csup\u00e1n egy f\u00fcggv\u00e9ny-referenci\u00e1t, hanem egy f\u00fcggv\u00e9ny-referencia list\u00e1t tartalmaznak (\u00e9s tartanak karban). Figyelj\u00fck meg a fenti harmadik sorban, hogy a f\u00fcggv\u00e9nyreferenci\u00e1kat az el\u0151sz\u00f6r l\u00e1tottn\u00e1l t\u00f6m\u00f6rebb szintaxissal is le\u00edrhatjuk: csak a f\u00fcggv\u00e9ny nev\u00e9t adjuk meg a += oper\u00e1tor ut\u00e1n, a new AgeChangingDelegate(...) n\u00e9lk\u00fcl. Ett\u0151l f\u00fcggetlen\u00fcl ekkor is egy AgeChangingDelegate objektum fogja becsomagolni a PersonAgeChanging f\u00fcggv\u00e9nyeket a sz\u00ednfalak m\u00f6g\u00f6tt. Pr\u00f3b\u00e1ljuk ki a leiratkoz\u00e1st is (szabadon v\u00e1lasztott ponton), majd futtassuk a programot. p . AgeChanging -= PersonAgeChanging ;","title":"2. Feladat \u2013 Deleg\u00e1t (delegate, met\u00f3dusreferencia)"},{"location":"labor/2-nyelvi-eszkozok/#3-feladat-esemeny-event","text":"Ahogyan a tulajdons\u00e1gok a getter \u00e9s setter met\u00f3dusoknak, addig a fent l\u00e1tott delegate mechanizmus a Java-b\u00f3l ismert Event Listener-eknek k\u00edn\u00e1lj\u00e1k egy a szintaktika tekintet\u00e9ben letisztultabb alternat\u00edv\u00e1j\u00e1t. A fenti megold\u00e1sunk azonban egyel\u0151re m\u00e9g s\u00falyosan s\u00e9rt p\u00e1r OO elvet (egys\u00e9gbez\u00e1r\u00e1s, inform\u00e1ci\u00f3rejt\u00e9s). Ezt az al\u00e1bbi k\u00e9t p\u00e9ld\u00e1val tudjuk demonstr\u00e1lni. Az esem\u00e9nyt val\u00f3j\u00e1ban k\u00edv\u00fclr\u0151l (m\u00e1s oszt\u00e1lyok m\u0171veletib\u0151l) is ki tudjuk v\u00e1ltani. Ez szerencs\u00e9tlen, hisz \u00edgy az esem\u00e9nyre feliratkozott f\u00fcggv\u00e9nyeken kereszt\u00fcl az oszt\u00e1ly nev\u00e9ben hamis adatokat k\u00f6z\u00f6lhet\u00fcnk. Ennek demonstr\u00e1l\u00e1s\u00e1ra sz\u00farjuk be a k\u00f6vetkez\u0151 sort a Main f\u00fcggv\u00e9ny v\u00e9g\u00e9re. p . AgeChanging ( 67 , 12 ); Itt a p szem\u00e9ly objektum vonatkoz\u00e1s\u00e1ban egy \"kamu\" \u00e9letkorv\u00e1ltoz\u00e1s esem\u00e9nyt v\u00e1ltottunk ki a Person , becsapva minden el\u0151fizet\u0151t. A j\u00f3 megold\u00e1s az lenne, ha az esem\u00e9nyt csak a Person oszt\u00e1ly m\u0171veletei tudn\u00e1k kiv\u00e1ltani. B\u00e1r a += \u00e9s a -= tekintettel vannak a list\u00e1ba feliratkozott t\u00f6bbi f\u00fcggv\u00e9nyre, val\u00f3j\u00e1ban az = oper\u00e1torral b\u00e1rmikor fel\u00fcl\u00edrhatjuk (kit\u00f6r\u00f6lhetj\u00fck) m\u00e1sok feliratkoz\u00e1sait. Pr\u00f3b\u00e1ljuk ki ezt is, a k\u00f6vetkez\u0151 sor besz\u00far\u00e1s\u00e1val (k\u00f6zvetlen\u00fcl a fel \u00e9s leiratkoz\u00e1sok ut\u00e1n sz\u00farjuk be). p . AgeChanging = null ; L\u00e1ssuk el az event kulcssz\u00f3val az AgeChanging mez\u0151t Person.cs -ben! class Person { public event AgeChangingDelegate AgeChanging ; \u2026 Az event kulcssz\u00f3 feladata val\u00f3j\u00e1ban az, hogy a fenti k\u00e9t jelens\u00e9get megtiltva visszak\u00e9nyszer\u00edtse programunkat az objektumorient\u00e1lt mederbe. Pr\u00f3b\u00e1ljuk meg leford\u00edtani a programot. L\u00e1tni fogjuk, hogy a ford\u00edt\u00f3 a kor\u00e1bbi kih\u00e1g\u00e1sainkat most m\u00e1r ford\u00edt\u00e1si hibak\u00e9nt kezeli. T\u00e1vol\u00edtsuk el a h\u00e1rom hib\u00e1s k\u00f3dsort (figyelj\u00fck meg, hogy m\u00e1r az els\u0151 k\u00f6zvetlen \u00e9rt\u00e9kad\u00e1s is hib\u00e1nak min\u0151s\u00fcl), majd ford\u00edtsuk le \u00e9s futtassuk az alkalmaz\u00e1sunkat!","title":"3. Feladat \u2013 Esem\u00e9ny (event)"},{"location":"labor/2-nyelvi-eszkozok/#4-feladat-attributumok","text":"A z attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel deklarat\u00edv m\u00f3don metaadatokkal l\u00e1thatjuk el forr\u00e1sk\u00f3dunkat . Az attrib\u00fatum is tulajdonk\u00e9ppen egy oszt\u00e1ly, melyet hozz\u00e1k\u00f6t\u00fcnk a program egy megadott elem\u00e9hez (t\u00edpushoz, oszt\u00e1lyhoz, interf\u00e9szhez, met\u00f3dushoz, \u2026). Ezeket a metainform\u00e1ci\u00f3kat a program fut\u00e1sa k\u00f6zben b\u00e1rki (ak\u00e1r mi magunk is) kiolvashatja az \u00fagynevezett reflection mechanizmus seg\u00edts\u00e9g\u00e9vel. Az attrib\u00fatumok a Java annot\u00e1ci\u00f3k .NET-beli megfelel\u0151inek is tekinthet\u0151k. A NET sz\u00e1mos be\u00e9p\u00edtett attrib\u00fatumot defini\u00e1l, melyek funkci\u00f3ja a legk\u00fcl\u00f6nb\u00f6z\u0151bb f\u00e9le lehet. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban haszn\u00e1lt attrib\u00fatumok p\u00e9ld\u00e1ul az XML soros\u00edt\u00f3val (serializer k\u00f6z\u00f6lnek k\u00fcl\u00f6nb\u00f6z\u0151 metainform\u00e1ci\u00f3kat. Sz\u00farjuk be a Main f\u00fcggv\u00e9ny v\u00e9g\u00e9re a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletet, majd futtassuk a programunkat! XmlSerializer serializer = new XmlSerializer ( typeof ( Person )); FileStream stream = new FileStream ( \"person.txt\" , FileMode . Create ); serializer . Serialize ( stream , p ); stream . Close (); // Process.Start(\"person.txt\"); A fenti p\u00e9ld\u00e1b\u00f3l az utols\u00f3 sor nem a soros\u00edt\u00f3 logika r\u00e9sze, csup\u00e1n egy frapp\u00e1ns megold\u00e1s arra, hogy a Windows alap\u00e9rtelmezett sz\u00f6vegf\u00e1jl n\u00e9zeget\u0151j\u00e9vel megnyissuk a keletkezett adat\u00e1llom\u00e1nyt. Ezt kipr\u00f3b\u00e1lhatjuk, de a haszn\u00e1lt .NET runtime-t\u00f3l \u00e9s az oper\u00e1ci\u00f3s rendszer\u00fcnkt\u0151l f\u00fcgg, t\u00e1mogatott-e. Ha nem, fut\u00e1s k\u00f6zben hib\u00e1t kapunk. Ez esetben hagyjuk kikommentezve, \u00e9s a person.txt f\u00e1jlt a f\u00e1jlrendszerben megkeresve k\u00e9zzel nyissuk meg (a Visual Studio mapp\u00e1nkban a \\bin\\Debug\\ alatt tal\u00e1lhat\u00f3 az .exe alkalmaz\u00e1sunk mellett. N\u00e9zz\u00fck meg a keletkezett f\u00e1jl szerkezet\u00e9t. Figyelj\u00fck meg, hogy minden tulajdons\u00e1g a nev\u00e9nek megfelel\u0151 XML elemre lett lek\u00e9pezve. .NET attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel olyan metaadatokkal l\u00e1thatjuk el a Person oszt\u00e1lyunkat, melyek k\u00f6zvetlen\u00fcl m\u00f3dos\u00edtj\u00e1k a soros\u00edt\u00f3 viselked\u00e9s\u00e9t. Az XmlRoot attrib\u00fatum lehet\u0151s\u00e9get k\u00edn\u00e1l a gy\u00f6k\u00e9relem \u00e1tnevez\u00e9s\u00e9re. Helyezz\u00fck el a Person oszt\u00e1ly f\u00f6l\u00e9! [XmlRoot(\"Szem\u00e9ly\")] public class Person { ... } Az XmlAttribute attrib\u00fatum jelzi a soros\u00edt\u00f3 sz\u00e1m\u00e1ra, hogy a jel\u00f6lt tulajdons\u00e1got ne xml elemre, hanem xml attrib\u00fatumra k\u00e9pezze le. L\u00e1ssuk el ezzel az Age tulajdons\u00e1got! [XmlAttribute(\"Kor\")] public int Age Az XmlIgnore attrib\u00fatum jelzi a soros\u00edt\u00f3nak, hogy a jel\u00f6lt tulajdons\u00e1g teljesen elhagyand\u00f3 az eredm\u00e9nyb\u0151l. Pr\u00f3b\u00e1ljuk ki a Name tulajdons\u00e1g f\u00f6l\u00f6tt. [XmlIgnore] public string Name { get ; set ; } Futtassuk az alkalmaz\u00e1sunkat! Hasonl\u00edtsuk \u00f6ssze az eredm\u00e9nyt a kor\u00e1bbiakkal.","title":"4. Feladat \u2013 Attrib\u00fatumok"},{"location":"labor/2-nyelvi-eszkozok/#5-feladat-delegat-2","text":"A 2. \u00e9s 3. feladatokban a deleg\u00e1tokkal esem\u00e9ny alap\u00fa \u00fczenetk\u00fcld\u00e9st val\u00f3s\u00edtottunk meg. A deleg\u00e1tok haszn\u00e1lat\u00e1nak m\u00e1sik tipikus eset\u00e9ben a f\u00fcggv\u00e9nyreferenci\u00e1kat arra haszn\u00e1ljuk, hogy egy algoritmus vagy \u00f6sszetettebb m\u0171velet sz\u00e1m\u00e1ra egy el\u0151re nem defini\u00e1lt l\u00e9p\u00e9s implement\u00e1ci\u00f3j\u00e1t \u00e1tadjuk . A generikus lista oszt\u00e1ly ( List<T> ) FindAll f\u00fcggv\u00e9nye p\u00e9ld\u00e1ul k\u00e9pes arra, hogy visszaadjon egy \u00faj list\u00e1ban minden olyan elemet, mely egy adott felt\u00e9telnek eleget tesz. A konkr\u00e9t sz\u0171r\u00e9si felt\u00e9telt egy f\u00fcggv\u00e9ny form\u00e1j\u00e1ban adhatjuk meg param\u00e9terben (melyet a FindAll minden elemre megh\u00edv), mely igazat ad minden olyan elemre, amit az eredm\u00e9nylist\u00e1ban szeretn\u00e9nk l\u00e1tni. A f\u00fcggv\u00e9ny t\u00edpusa a k\u00f6vetkez\u0151 el\u0151re defini\u00e1lt delegate t\u00edpus: public delegate bool Predicate < T >( T obj ) Vagyis bemenetk\u00e9nt egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t v\u00e1r, mint a listaelemek t\u00edpusa, kimenetk\u00e9nt pedig egy logikai \u00e9rt\u00e9ket. A fentiek demonstr\u00e1l\u00e1s\u00e1ra kieg\u00e9sz\u00edtj\u00fck a kor\u00e1bbi programunkat egy sz\u0171r\u00e9ssel, mely a list\u00e1b\u00f3l csak a p\u00e1ratlan elemeket fogja megtartani. Val\u00f3s\u00edtsunk meg egy olyan sz\u0171r\u0151f\u00fcggv\u00e9nyt az alkalmaz\u00e1sunkban, amely a p\u00e1ratlan sz\u00e1mokat adja vissza: static bool MyFilter ( int n ) { return n % 2 == 1 ; } Eg\u00e9sz\u00edts\u00fck ki a kor\u00e1bban \u00edrt k\u00f3dunkat a sz\u0171r\u0151 f\u00fcggv\u00e9ny\u00fcnk haszn\u00e1lat\u00e1val: List < int > list = new List < int >(); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); list = list . FindAll ( MyFilter ); foreach ( int n in list ) { Console . WriteLine ( $\"Value: {n}\" ); } Futtassuk az alkalmaz\u00e1sunkat. Figyelj\u00fck meg, hogy a konzolon val\u00f3ban csak a p\u00e1ratlan sz\u00e1mok jelennek meg. \u00c9rdekess\u00e9gk\u00e9nt elhelyezhet\u00fcnk egy t\u00f6r\u00e9spontot (breakpoint) a MyFilter f\u00fcggv\u00e9ny\u00fcnk belsej\u00e9ben \u00e9s megfigyelhetj\u00fck, hogy a f\u00fcggv\u00e9ny val\u00f3ban minden egyes listaelemre k\u00fcl\u00f6n-k\u00fcl\u00f6n megh\u00edv\u00f3dik.","title":"5. Feladat \u2013 Deleg\u00e1t 2."},{"location":"labor/2-nyelvi-eszkozok/#6-feladat-lambda-kifejezesek","text":"Az \u00e9rintett t\u00e9mak\u00f6r\u00f6k az el\u0151ad\u00e1sanyagban r\u00e9szletesen szerepelnek, itt nem ism\u00e9telj\u00fck meg \u0151ket L\u00e1sd \u201eEl\u0151ad\u00e1s 02 - Modern nyelvi eszk\u00f6z\u00f6k.pdf\u201d dokumentum \u201eLambda expression (lambda kifejez\u00e9s)\u201d fejezete. A kulcselem a => (lambda oper\u00e1tor) seg\u00edts\u00e9g\u00e9vel lambda kifejez\u00e9sek , vagyis n\u00e9vtelen f\u00fcggv\u00e9nyek defini\u00e1l\u00e1sa. Note A .NET be\u00e9p\u00edtett Func \u00e9s Action generikus delegate t\u00edpusokra itt id\u0151 hi\u00e1ny\u00e1\u00e9ban nem t\u00e9r\u00fcnk ki. Az el\u0151z\u0151, 5. feladatot oldjuk meg a k\u00f6vetkez\u0151k\u00e9ppen: ne adjunk meg k\u00fcl\u00f6n sz\u0171r\u0151f\u00fcggv\u00e9nyt, hanem a sz\u0171r\u00e9si logik\u00e1t egy lambda kifejez\u00e9s form\u00e1j\u00e1ban adjuk meg a FindAll m\u0171veletnek. Ehhez mind\u00f6ssze egy sort kell megv\u00e1ltoztatni: list = list . FindAll ( ( int n ) => { return n % 2 == 1 ; } ); Egy n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyt defini\u00e1ltunk \u00e9s adtunk \u00e1t a FindAll m\u0171veletnek: Ez egy lambda kifejez\u00e9s A => bal oldal\u00e1n megadtuk a m\u0171velet param\u00e9tereket (itt csak egy volt) A => jobb oldal\u00e1n a m\u0171velet t\u00f6rzs\u00e9t (ugyanaz, mint a kor\u00e1bbi MyFilter t\u00f6rzse) A fenti sort j\u00f3val egyszer\u0171bb \u00e9s \u00e1ttekinthet\u0151bb form\u00e1ba is \u00edrhatjuk: list = list . FindAll ( n => n % 2 == 1 ); A k\u00f6vetkez\u0151 egyszer\u0171s\u00edt\u00e9seket eszk\u00f6z\u00f6lt\u00fck: A param\u00e9ter t\u00edpus\u00e1t nem \u00edrtuk ki (a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni a FindAll delegate param\u00e9ter t\u00edpus\u00e1b\u00f3l) A param\u00e9ter k\u00f6r\u00fcli z\u00e1r\u00f3jelet elhagyhattuk ( mert csak egy param\u00e9ter van) A => jobb oldal\u00e1n elhagyhattuk a {} z\u00e1r\u00f3jeleket \u00e9s a return -t (mert egyetlen kifejez\u00e9sb\u0151l \u00e1llt a f\u00fcggv\u00e9ny t\u00f6rzse, mellyel a f\u00fcggv\u00e9ny visszat\u00e9r)","title":"6. Feladat \u2013 Lambda kifejez\u00e9sek"},{"location":"labor/2-nyelvi-eszkozok/#7-feladat-generikus-osztalyok","text":"Megjegyz\u00e9s: erre a feladatra j\u00f3 es\u00e9llyel nem marad id\u0151. Ez esetben c\u00e9lszer\u0171 a feladatot gyakorl\u00e1sk\u00e9ppen otthon elv\u00e9gezni. A .NET generikus oszt\u00e1lyai megfelelnek a C++ nyelv template oszt\u00e1lyainak (noha vannak jelent\u0151sebb k\u00fcl\u00f6nbs\u00e9gek a m\u0171k\u00f6d\u00e9s\u00fckben). A seg\u00edts\u00e9g\u00fckkel \u00e1ltal\u00e1nos (t\u00f6bb t\u00edpusra is m\u0171k\u00f6d\u0151), de ugyanakkor t\u00edpusbiztos oszt\u00e1lyokat hozhatunk l\u00e9tre. Generikus oszt\u00e1lyok n\u00e9lk\u00fcl, ha \u00e1ltal\u00e1nosan szeretn\u00e9nk kezelni egy probl\u00e9m\u00e1t, akkor object t\u00edpus\u00fa adatokat haszn\u00e1lunk (mert .NET-ben minden oszt\u00e1ly az object oszt\u00e1lyb\u00f3l sz\u00e1rmazik). Ez a helyzet p\u00e9ld\u00e1ul az ArrayList -tel is, ami egy \u00e1ltal\u00e1nos c\u00e9l\u00fa gy\u0171jtem\u00e9ny, tetsz\u0151leges, object t\u00edpus\u00fa elemek t\u00e1rol\u00e1s\u00e1ra alkalmas. L\u00e1ssunk egy p\u00e9ld\u00e1t az ArrayList haszn\u00e1lat\u00e1ra: ArrayList list = new ArrayList (); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); for ( int n = 0 ; n < list . Count ; n ++) { // Castolni kell, k\u00fcl\u00f6nben nem fordul int i = ( int ) list [ n ]; Console . WriteLine ( $\"Value: {i}\" ); } A fenti megold\u00e1ssal a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k ad\u00f3dnak: Az ArrayList minden egyes elemet object -k\u00e9nt t\u00e1rol. Amikor hozz\u00e1 szeretn\u00e9nk f\u00e9rni a lista egy elem\u00e9hez, mindig a megfelel\u0151 t\u00edpus\u00fav\u00e1 kell cast-olni. Nem t\u00edpusbiztos. A fenti p\u00e9ld\u00e1ban semmi nem akad\u00e1lyoz meg abban (\u00e9s semmilyen hiba\u00fczenet sem jelzi), hogy az int t\u00edpus\u00fa adatok mell\u00e9 besz\u00farjunk a list\u00e1ba egy m\u00e1sik t\u00edpus\u00fa objektumot. Ilyenkor csak a lista bej\u00e1r\u00e1sa sor\u00e1n kapn\u00e1nk hib\u00e1t, amikor a nem int t\u00edpust int t\u00edpus\u00fara pr\u00f3b\u00e1lunk castolni. Generikus gy\u0171jtem\u00e9nyek haszn\u00e1latakor az ilyen hib\u00e1k m\u00e1r a ford\u00edt\u00e1s sor\u00e1n kider\u00fclnek. \u00c9rt\u00e9k t\u00edpus\u00fa adatok t\u00e1rol\u00e1sakor a lista lassabban m\u0171k\u00f6dik, mert az \u00e9rt\u00e9k t\u00edpust el\u0151sz\u00f6r be kell dobozolni (boxing), hogy az object -k\u00e9nt (azaz referencia t\u00edpusk\u00e9nt) t\u00e1rolhat\u00f3 legyen. A fenti probl\u00e9ma megold\u00e1sa egy generikus lista haszn\u00e1lat\u00e1val a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki (a gyakorlat sor\u00e1n csak a kiemelt sort m\u00f3dos\u00edtsuk a kor\u00e1bban beg\u00e9pelt p\u00e9ld\u00e1ban): List < int > list = new List < int >(); list . Add ( 1 ); list . Add ( 2 ); list . Add ( 3 ); for ( int n = 0 ; n < list . Count ; n ++) { int i = list [ n ]; // Nem kell cast-olni Console . WriteLine ( $\"Value: {i}\" ); }","title":"7. Feladat \u2013 Generikus oszt\u00e1lyok"},{"location":"labor/3-felhasznaloi-felulet/","text":"3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa \u00b6 A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja egy l\u00e1tv\u00e1nyos, gyors alkalmaz\u00e1sfejleszt\u00e9s bemutat\u00e1sa, mely egyben megteremti a lehet\u0151s\u00e9get a Windows Forms fejleszt\u00e9s alapjainak elsaj\u00e1t\u00edt\u00e1s\u00e1ra. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt): Windows Forms alkalmaz\u00e1sfejleszt\u00e9s alapok Men\u00fck Dokkol\u00e1s \u00e9s horgonyz\u00e1s SplitView TreeView ListView Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: 3-4. el\u0151ad\u00e1s \u2013 Vastagkliens alkalmaz\u00e1sok fejleszt\u00e9se. El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) Bevezet\u0151 \u00b6 A Rapid Application Development (RAD) elve a fejleszt\u00e9si id\u0151 ler\u00f6vid\u00edt\u00e9s\u00e9t c\u00e9lozza meg az\u00e1ltal, hogy a fejleszt\u00e9s sor\u00e1n k\u00e9sz komponensekkel dolgozik, integr\u00e1lt fejleszt\u0151 k\u00f6rnyezetet (pl. Visual Studio) \u00e9s sok automatizmust alkalmaz. Fontos ugyanakkor, hogy az automatizmusok ne sz\u0171k\u00edts\u00e9k be t\u00falzottan a fejleszt\u0151 lehet\u0151s\u00e9geit \u00e9s kell\u0151 rugalmass\u00e1got adjanak neki a rendszerek testre szab\u00e1s\u00e1ban. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban l\u00e1tni fogjuk, mik\u00e9nt alkalmas mindezekre a Windows Forms k\u00f6rnyezet. A Window Forms alkalmaz\u00e1sok legfontosabb koncepci\u00f3it a t\u00e1rgy 3.-4. el\u0151ad\u00e1sa ismerteti. Egy Windows Forms alkalmaz\u00e1sban az alkalmaz\u00e1sunk minden ablak\u00e1nak egy saj\u00e1t oszt\u00e1lyt kell l\u00e9trehozni, mely a be\u00e9p\u00edtett Form oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Erre \u2013 tipikusan a Visual Studio designer\u00e9vel - vez\u00e9rl\u0151ket helyez\u00fcnk fel, melyek a Form oszt\u00e1lyunk tagv\u00e1ltoz\u00f3i lesznek. IntelliSense A k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban sz\u00e1mos gener\u00e1lt (\u00e9s emiatt hossz\u00fa) elnevez\u00e9ssel fogunk tal\u00e1lkozni. Programjaink megval\u00f3s\u00edt\u00e1sakor haszn\u00e1ljuk ki az automatikus k\u00f3dkieg\u00e9sz\u00edt\u00e9s (IntelliSense) ny\u00fajtotta lehet\u0151s\u00e9geket \u00e9s ne k\u00e9zzel g\u00e9pelj\u00fck be az egyes elnevez\u00e9seket. 1. Feladat \u2013 \u201eHello world\u201d Windows Forms technol\u00f3gi\u00e1val \u00b6 A feladat sor\u00e1n egy olyan Windows Forms alkalmaz\u00e1st k\u00e9sz\u00edt\u00fcnk el, amely egy egyszer\u0171 ablakban ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget. Ind\u00edtsuk el a Visual Studio 2022-t Hozzunk l\u00e9tre egy C# nyelv\u0171, Windows Forms t\u00edpus\u00fa alkalmaz\u00e1st, m\u00e9gpedig .NET 6 platformra. Ehhez a VS ind\u00edt\u00f3ablak\u00e1ban jobb oldalt a Create new project gombon kell kattintani, majd a projekt l\u00e9trehoz\u00f3 var\u00e1zsl\u00f3ban a Windows Forms App sablont kell kiv\u00e1lasztani. L\u00e9nyeges, hogy NE a Windows Forms App (.NETFramework) legyen! A sablon kikeres\u00e9s\u00e9hez haszn\u00e1ljuk az ablak keres\u0151/sz\u0171r\u0151mez\u0151it, amennyiben sz\u00fcks\u00e9ges. Kattintsunk a Next gombra. A megjelen\u0151 oldalon A Projekt name \u00e9s Solution name legyen HelloWorldWF Az \u00fatvonal a laborg\u00e9peken: C:\\Work\\ alatt egy mappa, mely a saj\u00e1t nev\u00fcnk vagy Neptun k\u00f3dunk szerint van nevezve. Next gombbal k\u00f6vetkez\u0151 oldalra v\u00e1lt\u00e1s A Framework mez\u0151ben v\u00e1lasszuk ki a .NET 6.0 (Long term support) -ot. Futtassuk a kiindul\u00f3 projektet, hogy l\u00e1ssuk, mit biztos\u00edt a kiindul\u00f3 alkalmaz\u00e1skeret (nem sokat, van egy egyszer\u0171 ablak). \u00c1ll\u00edtsuk le a fut\u00f3 alkalmaz\u00e1st. Kattintsunk dupl\u00e1n a Form1.cs f\u00e1jlra! Ezt k\u00f6vet\u0151en a fel\u00fcleten megjelenik egy sz\u00fcrke ablak. Amennyiben a Solution Explorerben a Form1.cs f\u00e1jl elemet kibontjuk, l\u00e1tni fogjuk, hogy egy Form1.designer.cs nev\u0171 f\u00e1jl is tartozik hozz\u00e1. A fenti egyszer\u0171 program fel\u00e9p\u00edt\u00e9s\u00e9t k\u00f6nnyen v\u00e9gig k\u00f6vethetj\u00fck kor\u00e1bbi ismereteink alapj\u00e1n. A program bel\u00e9p\u00e9si pontja itt is a Program.cs f\u00e1jlban tal\u00e1lhat\u00f3 Main f\u00fcggv\u00e9ny. A f\u00fcggv\u00e9ny l\u00e9trehoz egy p\u00e9ld\u00e1nyt a Form1 oszt\u00e1lyb\u00f3l, majd az Application.Run f\u00fcggv\u00e9ny seg\u00edts\u00e9g\u00e9vel elind\u00edtja az \u00fczenetkezel\u0151 ciklust \u00e9s megjelen\u00edti az ablakot (a Windows Forms vil\u00e1g\u00e1ban \u201eForm\u201d-nak h\u00edvjuk az ablakokat). A Form1 oszt\u00e1ly k\u00f3dja k\u00e9t f\u00e1jlban van defini\u00e1lva (ezt a C# partial kulcsszava teszi lehet\u0151v\u00e9). A Form1.cs a felhaszn\u00e1l\u00f3 \u00e1ltal kezelt k\u00f3dr\u00e9szleteket, m\u00edg a Form1.designer.cs a grafikus Form designer \u00e1ltal gener\u00e1lt k\u00f3dot tartalmazza. Ez ut\u00f3bbi mindig teljes szinkronban van a design n\u00e9zettel, k\u00f6zvetlen m\u00f3dos\u00edt\u00e1s\u00e1ra ugyan van lehet\u0151s\u00e9g, de a speci\u00e1lis hibaelh\u00e1r\u00edt\u00e1si eseteket lesz\u00e1m\u00edtva felesleges \u00e9s ker\u00fclend\u0151. Figyelj\u00fck meg, hogy a k\u00e9t f\u00e1jl k\u00f6z\u00f6tt m\u00e1r a gener\u00e1lt k\u00f3d alapj\u00e1n is kapcsolat van, hiszen a Form1 konstruktora \u00e1th\u00edv a m\u00e1sik f\u00e1jlban defini\u00e1lt InitializeComponent() f\u00fcggv\u00e9nybe. Designer n\u00e9zet \u00e9s k\u00f3d k\u00f6z\u00f6tt v\u00e1lt\u00e1s Amennyiben a Form1.cs f\u00e1jlra dupl\u00e1n kattintunk, alap\u00e9rtelmez\u00e9sben nem a forr\u00e1sk\u00f3d, hanem a tervez\u0151 n\u00e9zet (Form designer) jelenik meg. Innen a forr\u00e1sk\u00f3d n\u00e9zetre a fel\u00fcleten jobb kattintva, a View Code men\u00fcponttal, vagy az F7 billenty\u0171 megnyom\u00e1s\u00e1val juthatunk. Elk\u00e9pzelhet\u0151, hogy megjelenik egy tov\u00e1bbi, Form1.resx nev\u0171 f\u00e1jl is. Ez az ablakhoz tartoz\u00f3 er\u0151forr\u00e1sokat (tipikusan k\u00e9pek, sz\u00f6vegek) tartalmazhatja, de a mi eset\u00fcnkben most nincs jelent\u0151s\u00e9ge. Kattintsunk dupl\u00e1n a Form1.cs f\u00e1jlra! Ez alap\u00e9rtelmez\u00e9sben a tervez\u0151 n\u00e9zetet nyitja meg. Kattintsunk az \u0171rlap h\u00e1tter\u00e9n, hogy az \u0171rlap legyen kiv\u00e1lasztva. A Visual Studio Properties ablak\u00e1ban l\u00e1thatjuk az \u0171rlapunk aktu\u00e1lis tulajdons\u00e1gait. Amennyiben a Properties ablak nem l\u00e1that\u00f3, az F4 billenty\u0171vel tudjuk el\u0151csalni (vagy View men\u00fc / Properties). A Properties ablakban keress\u00fck meg a Text tulajdons\u00e1got, \u00e9s \u00edrjuk \u00e1t \u201eHello World\u201d -re. Ez az \u0171rlapunk fejl\u00e9c\u00e9nek a sz\u00f6veg\u00e9t \u00e1ll\u00edtja be. Mint l\u00e1that\u00f3, az \u0171rlapunk sz\u00e1mos tulajdons\u00e1ggal rendelkezik, ezek mindegyik\u00e9t a Properties ablakban be tudjuk \u00e1ll\u00edtani az aktu\u00e1lis ig\u00e9nyeknek megfelel\u0151en. Nyissuk ki a Toolbox-ot ( View men\u00fc / Toolbox ). H\u00fazzunk r\u00e1 a formra egy TextBox \u00e9s egy Button (gomb) vez\u00e9rl\u0151t tetsz\u0151leges helyre! (Ezeket a vez\u00e9rl\u0151ket a Toolbox Common Windows Forms csoportj\u00e1ban tal\u00e1ljuk). Kattintsunk egyszer a gomb vez\u00e9rl\u0151n, hogy biztosan az legyen kiv\u00e1lasztva a designerben. Ekkor a Properties ablakban a gombunk tulajdons\u00e1gai jelennek meg. \u00c1ll\u00edtsuk be a Text tulajdons\u00e1g\u00e1t \u201eBe\u00e1ll\u00edt\u201d-ra, ez a gombunk sz\u00f6veg\u00e9t fogja ennek megfelel\u0151en be\u00e1ll\u00edtani. Ugyanitt a Properties ablakban \u00e1ll\u00edtsuk be gombunk referenci\u00e1j\u00e1t tartalmaz\u00f3 oszt\u00e1lyv\u00e1ltoz\u00f3 nev\u00e9t, vagyis a Name tulajdons\u00e1g\u00e1t button1 -r\u0151l bUpdateText -re. L\u00e9nyeges, hogy a vez\u00e9rl\u0151inket a funkci\u00f3juknak megfelel\u0151 nevekkel l\u00e1ssuk el, ez nagyban seg\u00edti a k\u00f3dunk olvashat\u00f3s\u00e1g\u00e1t. A b prefix a vez\u00e9rl\u0151 Button t\u00edpus\u00e1ra utal. Hungarian Notation A fenti prefixelt elnevez\u00e9si konvenci\u00f3t Hungarian Notation nek h\u00edvj\u00e1k, mert Charles Simonyi (Simonyi K\u00e1roly fia) tal\u00e1lta ki, amikor az Excel csapatban dolgozott a Micorosftn\u00e1l. A koncepci\u00f3 els\u0151sorban C++-hoz k\u00e9sz\u00fclt, olyan id\u0151kben, amikor m\u00e9g nem voltak gazdag funkcionalit\u00e1s\u00fa fejelszt\u0151k\u00f6rnyezetek, \u00e9s egy egyszer\u0171 sz\u00f6vegszerkeszt\u0151vel is r\u00e1n\u00e9z\u00e9sre meg kellett tudni mondani, hogy a v\u00e1ltoz\u00f3 milyen t\u00edpus\u00fa. Ez manaps\u00e1g m\u00e1r nem relev\u00e1ns, mert a Visual Studio is pl. az eg\u00e9rkurzor seg\u00edts\u00e9g\u00e9vel visszajelz\u00e9st ad a v\u00e1ltoz\u00f3 t\u00edpus\u00e1r\u00f3l. Az el\u0151z\u0151 l\u00e9p\u00e9s mint\u00e1j\u00e1ra nevezz\u00fck \u00e1t a TextBox vez\u00e9rl\u0151nket tbDemoText -re. A tb prefix a vez\u00e9rl\u0151 TextBox t\u00edpus\u00e1ra utal. Az \u0171rlapunk neve jelenleg Form1 , mely szint\u00e9n el\u00e9g semmitmond\u00f3. Nevezz\u00fck \u00e1t MainForm -ra, az al\u00e1bbi l\u00e9p\u00e9seket k\u00f6vetve. Az \u00e1tnevez\u00e9st a Solution Explorerben tudjuk megtenni, itt t\u00f6bb technik\u00e1t is haszn\u00e1lhatunk. V\u00e1lasszuk ki a Form1 elemet, majd m\u00e9g egyszer kattintsunk rajta bal gombbal: ekkor a n\u00e9v szerkeszthet\u0151v\u00e9 v\u00e1lik (pont \u00fagy dolgozunk, ahogy egy f\u00e1jlt is \u00e1tnevez\u00fcnk Windows F\u00e1jlkezel\u0151ben/File Explorerben). Vagy egyszer\u0171en csak megnyomjuk az F2 billenty\u0171t az \u00e1tnevez\u00e9s elind\u00edt\u00e1s\u00e1hoz. Vagy ak\u00e1r haszn\u00e1lhatjuk a jobb gombos men\u00fc Rename funkci\u00f3j\u00e1t. Ak\u00e1rhogy is indultunk, \u00edrjuk be \u00faj n\u00e9vnek a MainForm.cs -t, majd nyomjuk meg az Enter billenty\u0171t. Ekkor a Visual Studio r\u00e1k\u00e9rdez egy felugr\u00f3 ablakban, hogy minden kapcsol\u00f3d\u00f3 elemet nevezzen-e \u00e1t ennek megfelel\u0151en: itt mindenk\u00e9ppen Yes -t v\u00e1lasszunk: Hiba \u00e1tnevez\u00e9s ut\u00e1n Ekkor a VS2022 hajlamos egy hiba\u00fczenetet megjelen\u00edteni az \u0171rlapunk hely\u00e9n, amennyiben meg volt nyitva a designerben. Ne ijedj\u00fcnk meg t\u0151le, z\u00e1rjuk be az \u0171rlap tabf\u00fcl\u00e9t (vagy valamennyi megnyitott f\u00e1jl tabf\u00fcl\u00e9t), \u00e9s nyissuk meg \u00fajra a Solution Explorerben az \u0171rlapot: ekkor a hiba elt\u0171nik. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a gombkattint\u00e1s esem\u00e9nyt fogjuk lekezelni: ennek hat\u00e1s\u00e1ra a tbDemoText TextBox vez\u00e9rl\u0151be be\u00edrjuk a \u201eHello\u201d sz\u00f6veget. Egy \u0171rlap/vez\u00e9rl\u0151 esem\u00e9nyeinek megjelen\u00edt\u00e9s\u00e9re is a Properties ablak szolg\u00e1l, csak \u00e1t kell v\u00e1ltsunk az esem\u00e9nymegjelen\u00edt\u0151 n\u00e9zet\u00e9re. Ehhez a Properties ablak fels\u0151 r\u00e9sz\u00e9n tal\u00e1lhat\u00f3 vill\u00e1m ikonon kell kattintanunk: Tulajdons\u00e1gok A tulajdons\u00e1gok megjelen\u00edt\u00e9s\u00e9re \u00fagy tudunk a k\u00e9s\u0151bbiekben majd visszav\u00e1ltani, ha a vill\u00e1m ikont\u00f3l balra elhelyezked\u0151 vill\u00e1skulcs ikonra kattintunk (ezt egyel\u0151re ne tegy\u00fck meg). Az esem\u00e9nylist\u00e1ban l\u00e1that\u00f3, hogy a Button oszt\u00e1lynak sz\u00e1mos esem\u00e9nye van. Sz\u00e1munkra most a Click esem\u00e9ny az \u00e9rdekes. Erre k\u00e9tf\u00e9lek\u00e9ppen tudunk feliratkozni: Az esem\u00e9nylist\u00e1ban a Click elemen dupl\u00e1n kattintunk. A designer fel\u00fcleten a gombon dupl\u00e1n kattintva. A designer fel\u00fcleten a dupl\u00e1n kattint\u00e1s mindig a vez\u00e9rl\u0151 - a vez\u00e9rl\u0151 t\u00edpus\u00e1t\u00f3l f\u00fcgg\u0151 - alap\u00e9rtelmezett esem\u00e9ny\u00e9re iratkozik fel. Mivel a Click esem\u00e9ny a Button oszt\u00e1ly alap\u00e9rtelemezett esem\u00e9nye, ez nek\u00fcnk most pont meg is felel. V\u00e1lasszuk most a m\u00e1sodik lehet\u0151s\u00e9get, kattintsunk dupl\u00e1n a gomb vez\u00e9rl\u0151n. Ez l\u00e9trehoz egy esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt, mely akkor kiv\u00f3dik fut\u00e1s k\u00f6zben, amikor a felhaszn\u00e1l\u00f3 kattint a gombon (ak\u00e1r eg\u00e9rrel, ak\u00e1r a Tab billenty\u0171vel r\u00e1navig\u00e1lva a Space billenty\u0171 lenyom\u00e1s\u00e1val). A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben a tbDemoText objektum Text tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be \"Hell\u00f3\"-ra. private void bUpdateText_Click ( object sender , EventArgs e ) { tbDemoText . Text = \"Hello\" ; } Esem\u00e9nykezel\u0151k fejl\u00e9ce Ha nem tetszik a dupla klikkes gener\u00e1lt n\u00e9v (a hungarian notation miatt kisbet\u0171vel kezd\u0151dik, ami nem t\u00fal C#-os), akkor egyszer\u0171en kezdj\u00fck el beg\u00e9pelni a Properties ablak k\u00edv\u00e1nt esem\u00e9ny\u00e9hez a f\u00fcggv\u00e9ny nev\u00e9t, majd nyomjunk Entert. Az esem\u00e9nykezel\u0151ket tipikusan \u00fagy szoktuk elnevezni, hogy utaljon a vez\u00e9rl\u0151re (alap\u00e9rtelmezetten a neve) majd alulvon\u00e1s ut\u00e1n az esem\u00e9ny neve k\u00f6vetkezik. A Windows Forms vez\u00e9rl\u0151inek esem\u00e9nykezel\u0151iben szinte mindig k\u00e9t param\u00e9tert kapunk: object sender : A kiv\u00e1lt\u00f3 objektum (sajnos nem er\u0151sen t\u00edpusosan) EventArgs e : Az esem\u00e9nyhez tartoz\u00f3 param\u00e9tereket tartalmazza. T\u00edpusa EventArgs , vagy annak lesz\u00e1rmazottja. Az EventArgs itt egy \u00fcres param\u00e9tert reprezent\u00e1l, mert a gombkattint\u00e1shoz nem tartozik semmi extra adat. EventArgs lesz\u00e1rmazott olyan esem\u00e9nyek eset\u00e9n haszn\u00e1lt, melyekhez valamilyen plusz adat is tartozik (pl. billenty\u0171 lenyom\u00e1sn\u00e1l a lenyomott billenty\u0171 k\u00f3dja). Futtassuk az alkalmaz\u00e1st (F5)! Nyomjuk meg a gombot! N\u00e9zz\u00fcnk bele \u00fajra a MainForm.Designer.cs -be. Megtal\u00e1ljuk az \u00fajonnan gener\u00e1lt k\u00f3dot: az \u0171rlapon elhelyezett vez\u00e9rl\u0151kb\u0151l tagv\u00e1ltoz\u00f3k lesznek, melyek az InitializeComponent f\u00fcggv\u00e9nyben ker\u00fclnek inicializ\u00e1l\u00e1sra, itt tal\u00e1ljuk a tulajdons\u00e1gaik be\u00e1ll\u00edt\u00e1s\u00e1t, valamint az esem\u00e9nyekre val\u00f3 feliratkoz\u00e1st. Figyelj\u00fck meg azt is, hogy a gomb lenyom\u00e1s\u00e1ra tulajdonk\u00e9ppen egy C# esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt regisztr\u00e1ltunk be a m\u00e1r ismert += oper\u00e1tor alkalmaz\u00e1s\u00e1val. L\u00e1thatjuk, hogy a designer csak olyan k\u00f3dot gener\u00e1l, melyet ak\u00e1r mi is meg tudn\u00e1nk \u00edrni, de persze \u00edgy egyszer\u0171bb azt elk\u00e9sz\u00edteni. N\u00e9h\u00e1ny alapfogalom \u00e1ttekint\u00e9se \u00b6 Form - fel\u00fclettervez\u00e9s \u00b6 A Form oszt\u00e1ly az ablakot reprezent\u00e1lja, \u00e9s egyben a kont\u00e9ner-vez\u00e9rl\u0151 kapcsolatban a legfels\u0151 szint\u0171 kont\u00e9ner (tartalmaz\u00f3). A fel\u00fclet kialak\u00edt\u00e1sa szempontj\u00e1b\u00f3l az alkalmaz\u00e1sunk lehet: Dial\u00f3gus alap\u00fa: Kiz\u00e1r\u00f3lag vez\u00e9rl\u0151ket helyez\u00fcnk el az \u0171rlapon, mintha egy dial\u00f3gus ablak lenne. Ha sz\u00fcks\u00e9ges, \u00faj ablakot nyitunk az egyes funkci\u00f3knak. Pl. sokszor ilyenek az \u00fczleti/v\u00e1llalati alkalmaz\u00e1sok. SDI, vagy MDI: Dokumentum alap\u00fa alkalmaz\u00e1s, mely esetben az \u0171rlap a dokumentum megjelen\u00edt\u0151je \u00e9s esetleg szerkeszt\u0151je. Az egy\u00e9b vez\u00e9rl\u0151ket/funkci\u00f3kat a men\u00fcbe \u00e9s a toolbarra (eszk\u00f6zs\u00e1v) tessz\u00fck. Az SDI (Single Document Interface) egy dokumentumot kezel egy id\u0151ben, az MDI (Multiple Document Interface) pedig t\u00f6bbet. Pl. ilyenek sz\u00f6vegszerkeszt\u0151k, vagy maga a Visual Studio is. Vegyes: Az ilyen jelleg\u0171 alkalmaz\u00e1sokban a dokumentum szerkeszt\u00e9se a c\u00e9l csak\u00fagy, mint az SDI/MDI v\u00e1ltozatokban, azonban az ablak egy r\u00e9sze fenn van tartva vez\u00e9rl\u0151k sz\u00e1m\u00e1ra, ahol k\u00f6nnyen el\u00e9rhetj\u00fck a funkci\u00f3kat. Pl. ilyenek a CAD alkalmaz\u00e1sok. Kont\u00e9ner-vez\u00e9rl\u0151 tartalmaz\u00e1si hierarchia \u00b6 Egy ablak/\u0171rlap hierarchikus (fa) fel\u00e9p\u00edt\u00e9s\u0171, amelyben a gy\u00f6k\u00e9robjektum maga a Form . L\u00e9nyeges, hogy itt nem sz\u00e1rmaztat\u00e1si, hanem tartalmaz\u00e1si hierarchi\u00e1r\u00f3l van sz\u00f3 . Alatta \u00fajabb kont\u00e9nerek lehetnek egym\u00e1sba \u00e1gyazva, vagy csak egym\u00e1s mellett. A hierarchia alj\u00e1n vannak az egyszer\u0171 vez\u00e9rl\u0151k, de lehetnek vez\u00e9rl\u0151 n\u00e9lk\u00fcli kont\u00e9nerek is. Az egym\u00e1sba \u00e1gyaz\u00e1s az\u00e9rt sz\u00fcks\u00e9ges, hogy egys\u00e9gk\u00e9nt lehessen kezelni a kont\u00e9nereket \u00e9s a gyerekeiket, \u00edgy p\u00e9ld\u00e1ul od\u00e9bb h\u00fazva a kont\u00e9nert vele mozognak az \u00e1ltala tartalmazott vez\u00e9rl\u0151k is. A m\u00e1sik fontos ok a tulajdons\u00e1g\u00f6r\u00f6kl\u00e9s, amely lehet\u0151v\u00e9 teszi, hogy ha megv\u00e1ltoztatjuk valamelyik kont\u00e9ner \u00f6r\u00f6k\u00f6lhet\u0151 tulajdons\u00e1g\u00e1t (pl. Font ), akkor azt a gyerekei is meg\u00f6r\u00f6k\u00f6lj\u00e9k. Ez nem a szok\u00e1sos objektum-orient\u00e1lt \u00f6r\u00f6kl\u00e9s, de a sz\u00fcl\u0151-gyermek viszony azonos elvre \u00e9p\u00fcl. \u00dczenetkezel\u00e9s \u00b6 A Windows Forms alap\u00fa alkalmaz\u00e1sok \u00fczenetkezel\u00e9sre \u00e9p\u00fclnek, amelynek a h\u00e1tter\u00e9ben az oper\u00e1ci\u00f3s rendszer \u00fczenetkezel\u0151 mechanizmusa \u00e1ll. Az \u00fczenetkezel\u0151 ciklus a Main f\u00fcggv\u00e9nyben van ( Application.Run ), amely csak akkor l\u00e9p ki, ha bez\u00e1rjuk az alkalmaz\u00e1sunkat. Visual Studio Designer \u00b6 A designer a felhaszn\u00e1l\u00f3i fel\u00fclet szerkeszt\u0151je, amelyben lehet\u0151s\u00e9g\u00fcnk van \u00faj elemeket felvenni, illetve a megl\u00e9v\u0151ket m\u00f3dos\u00edtani \u00e9s t\u00f6r\u00f6lni. A designer fontosabb elemei/kell\u00e9kei: Toolbox : Err\u0151l lehet a kont\u00e9nereket \u00e9s vez\u00e9rl\u0151ket r\u00e1h\u00fazni az \u0171rlapra. Properties ablak/Property Editor : A kijel\u00f6lt vez\u00e9rl\u0151 tulajdons\u00e1gait \u00e9s esem\u00e9nyeit mutatja, illetve itt lehet ezeket m\u00f3dos\u00edtani is. Az F4 billenty\u0171vel is el\u00e9rhet\u0151. Smart tag : A legt\u00f6bb vez\u00e9rl\u0151 t\u00edpus eset\u00e9n t\u00e1mogatott. A vez\u00e9rl\u0151t kiv\u00e1lasztva annak jobb fels\u0151 sark\u00e1ban megjelenik egy kis ny\u00edl, amelyre kattintva megjelenik. Ebben n\u00e9h\u00e1ny kiemelt tulajdons\u00e1g \u00e9s k\u00e9nyelmi funkci\u00f3 \u00e9rhet\u0151 el. Document outline ablak : A kont\u00e9ner-vez\u00e9rl\u0151 hierarchi\u00e1t mutatja. Itt ki lehet jel\u00f6lni az egyes vez\u00e9rl\u0151ket, illetve mozgatni is lehet \u0151ket a hierarchi\u00e1ban, mely \u00e9rv\u00e9nyes\u00fcl az \u0171rlapon is. 2. Feladat - Men\u00fck, Horgonyz\u00e1s, Dokkol\u00e1s \u00b6 Men\u00fck \u00b6 A fel\u00fclettervez\u00e9s k\u00f6vetkez\u0151 feladata a men\u00fck megszerkeszt\u00e9se. Ehhez v\u00e9gezz\u00fck el a k\u00f6vetkez\u0151 l\u00e9p\u00e9ssorozatot. A Toolboxr\u00f3l h\u00fazzunk r\u00e1 a Form -ra egy MenuStrip -et ( Menus & Toolbars kateg\u00f3ri\u00e1ban van). A MenuStrip smart tag-j\u00e9t kinyitva (kicsi ny\u00edl a jobb fels\u0151 sark\u00e1ban) kattintsunk az Insert Standard Items -re. Ism\u00e9telj\u00fck az els\u0151 k\u00e9t l\u00e9p\u00e9st a ToolStrip vez\u00e9rl\u0151vel is. Majd helyezz\u00fcnk fel alulra egy StatusStrip vez\u00e9rl\u0151t is. Tesztelj\u00fck az alkalmaz\u00e1st, vegy\u00fck \u00e9szre, hogy a ToolStrip -nek van kis foganty\u00faja, azonban azt hi\u00e1ba fogjuk meg, nem mozog. Ekkor j\u00f6n seg\u00edts\u00e9g\u00fcnkre a ToolStripContainer . A ToolStripContainer egy olyan kont\u00e9ner vez\u00e9rl\u0151, mely \u00f6t panelt tartalmaz: egy Top, Bottom, Left, Right \u00e9s egy k\u00f6z\u00e9pen elhelyezked\u0151 Content panelt. A men\u00fc smart tag-\u00e9ben v\u00e1lasszuk ki az Embed In ToolStripContainer parancsot, amely feltesz egy ToolStripContainer -t, \u00e9s a men\u00fct \u00e1thelyezi ennek fels\u0151 panelj\u00e9be. Az \u0171rlapunk megjelen\u00e9se kaotikuss\u00e1 v\u00e1lik, mivel a t\u00f6bbi strip egyel\u0151re nem ker\u00fclt a ToolStripContainer -be. A ToolStripContainer smart tag-j\u00e9n v\u00e1lasszuk a Dock Fill in Form funkci\u00f3t. Akkor l\u00e1tsz\u00f3lag minden a hely\u00e9re ker\u00fcl, lesz\u00e1m\u00edtva, hogy a men\u00fc \u00e9s a toolbar fel vannak cser\u00e9lve. Kiv\u00e1laszt\u00e1s a designerben A ToolStripContainer kijel\u00f6l\u00e9se kicsit tr\u00fckk\u00f6s a takar\u00e1si viszonyok miatt. Ehhez haszn\u00e1ljuk a Document Outline ablakot, vagy haszn\u00e1ljuk a context men\u00fc Select men\u00fcpontj\u00e1t. Rendezz\u00fck a kont\u00e9ner-vez\u00e9rl\u0151 hierarchi\u00e1t! Nyissuk meg a Document Outline ablakot ( View / Other Windows / Document Outline ) \u00e9s korrig\u00e1ljuk a hierarchi\u00e1t: H\u00fazzuk \u00e1t a ToolStrip -et \u00e9s a StatusStrip -et a ToolStripContainer fels\u0151, illetve als\u00f3 panelj\u00e9be, tov\u00e1bb\u00e1 a TextBox \u00e9s Button vez\u00e9rl\u0151ket ContentPanel -re. A v\u00e9geredm\u00e9ny \u00edgy n\u00e9z ki: A MenuStrip smart tag-j\u00e9ben \u00e1ll\u00edtsuk \u00e1t a Grip Style -t Visible -re, ekkor m\u00e1r a men\u00fc is mozgathat\u00f3. Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, a ToolStrip \u00e9s a MenuStrip mozgathat\u00f3 lett (oldalra \u00e9s alulra is). P\u00e9ldak\u00e9nt adjunk esem\u00e9nykezel\u0151t a File/Exit men\u00fcelemhez: dupl\u00e1n klikkelj\u00fcnk a men\u00fcelemen, majd a k\u00f3dban adjuk ki a Close() parancsot, mely bez\u00e1rja az ablakot \u00e9s ezzel le\u00e1ll\u00edtja az alkalmaz\u00e1st. private void exitToolStripMenuItem_Click ( object sender , EventArgs e ) { Close (); } Futtassuk \u00e9s tesztelj\u00fck az alkalmaz\u00e1st. Horgonyz\u00e1s (anchor) \u00b6 Horgonyz\u00e1s, dokkol\u00e1s dem\u00f3k A horgonyz\u00e1shoz \u00e9s dokkol\u00e1shoz GitHub-on a t\u00e1rgy alatt tal\u00e1lhat\u00f3 szeml\u00e9letes dem\u00f3. Forr\u00e1sk\u00f3d a k\u00f6vetkez\u0151 utas\u00edt\u00e1ssal parancssorb\u00f3l egyszer\u0171en let\u00f6lthet\u0151: git clone https://github.com/bmeviauab00/AnchorAndDockDemo Futtathat\u00f3 verzi\u00f3 a download gombbal t\u00f6lthet\u0151 le. Anchor : A horgonyz\u00e1s seg\u00edts\u00e9g\u00e9vel el\u00e9rhet\u0151, hogy a vez\u00e9rl\u0151 adott oldala \u00e1lland\u00f3 t\u00e1vols\u00e1got tartson a sz\u00fcl\u0151 kont\u00e9ner ugyanazon oldal\u00e1t\u00f3l. Egy vez\u00e9rl\u0151re egym\u00e1st\u00f3l f\u00fcggetlen\u00fcl be\u00e1ll\u00edthat\u00f3 a fel\u00fclre, alulra, balra \u00e9s jobbra horgonyz\u00e1s. Ha pl. a jobbra horgonyz\u00e1s be van \u00e1ll\u00edtva egy vez\u00e9rl\u0151re, akkor a jobb oldala fix t\u00e1vols\u00e1got tart a kont\u00e9ner\u00e9nek jobb oldal\u00e1t\u00f3l. Ez a kont\u00e9ner \u00e1tm\u00e9retez\u00e9sekor v\u00e1lik l\u00e1that\u00f3v\u00e1: amikor a kont\u00e9ner jobb oldala fut\u00e1s k\u00f6zben az \u00e1tm\u00e9retez\u00e9s sor\u00e1n elmozdul, akkor a tartalmazott vez\u00e9rl\u0151 jobb oldala ezt automatikusan lek\u00f6veti, a t\u00e1vols\u00e1g a kett\u0151 k\u00f6z\u00f6tt \u00e1lland\u00f3 marad. Ugyanez \u00e1ll fent a jobbra, fel\u00fclre \u00e9s alulra horgonyz\u00e1s eset\u00e9n is (\u00e9rtelemszer\u0171en a jobb, fels\u0151 \u00e9s als\u00f3 oldalakra vonatkoztatva). Alap\u00e9rtelmez\u00e9sben a vez\u00e9rl\u0151k bal oldala \u00e9s teteje van lehorgonyozva. Ha k\u00e9t ellent\u00e9tes oldal is le van horgonyozva (p\u00e9ld\u00e1ul a bal \u00e9s a jobb oldal), akkor a sz\u00fcl\u0151 v\u00edzszintes \u00e1tm\u00e9retez\u00e9sekor a vez\u00e9rl\u0151 n\u0151ni vagy zsugorodni fog, hogy a k\u00e9t sz\u00e9le megtartsa a t\u00e1vols\u00e1got a sz\u00fcl\u0151 sz\u00e9leit\u0151l. T\u00e9rj\u00fcnk vissza az alkalmaz\u00e1sunkhoz: H\u00fazzuk be az els\u0151 feladatban l\u00e9trehozott gombot a form k\u00f6zep\u00e9re (de egy \u00fajat is feldobhatunk). A Property Editor -ban keress\u00fck ki \u00e9s nyissuk le az Anchor tulajdons\u00e1got. A tulajdons\u00e1g \u00e9rt\u00e9ke val\u00f3j\u00e1ban egyszer\u0171 enum, melyhez a Visual Studio az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt egy grafikus n\u00e9zetet ad. Figyelj\u00fck meg, hogy jelenleg a vez\u00e9rl\u0151 bal oldala \u00e9s teteje van a sz\u00fcl\u0151j\u00e9hez k\u00f6tve. Az Anchor szerkeszt\u0151j\u00e9ben kattintsunk a jobb oldali horgonyra is. \u00cdgy m\u00e1r h\u00e1rom oldal\u00e1t r\u00f6gz\u00edtett\u00fck a gombnak. Tesztelj\u00fck a v\u00e1ltoztat\u00e1s hat\u00e1s\u00e1t! Mivel a horgonyok m\u00e1r tervez\u00e9si id\u0151ben is m\u0171k\u00f6dnek, ehhez az alkalmaz\u00e1st sem kell elind\u00edtani. El\u00e9g a tervez\u00e9si n\u00e9zetben \u00e1tm\u00e9retezni a formot. Figyelj\u00fck meg, hogy imm\u00e1r a gomb jobb oldala egy\u00fctt mozog a form jobb sz\u00e9l\u00e9vel! M\u00f3dos\u00edtsuk a horgonyt \u00fagy, hogy a jobb \u00e9s az als\u00f3 oldala legyen r\u00f6gz\u00edtve a gombnak, a teteje \u00e9s a bal oldala nem. Tesztelj\u00fck a megold\u00e1st! Ut\u00f3bbi megold\u00e1s haszn\u00e1lhat\u00f3 p\u00e9ld\u00e1ul arra, hogy egy dial\u00f3gusablak bez\u00e1r\u00f3 gombj\u00e1t mindig a jobb als\u00f3 sarokban tartsuk. A gombra a tov\u00e1bbiakban nem lesz sz\u00fcks\u00e9g\u00fcnk, t\u00f6r\u00f6lj\u00fck a fel\u00fcletr\u0151l. Dokkol\u00e1s (dock) \u00b6 Dock : A dokkol\u00e1s (szok\u00e1s m\u00e9g csatol\u00e1snak vagy ragaszt\u00e1snak is nevezni) seg\u00edts\u00e9g\u00e9vel egy vez\u00e9rl\u0151 hozz\u00e1csatolhat\u00f3 az \u0151t tartalmaz\u00f3 kont\u00e9ner valamelyik sz\u00e9l\u00e9hez, vagy be\u00e1ll\u00edthat\u00f3, hogy t\u00f6ltse ki a rendelkez\u00e9sre \u00e1ll\u00f3 helyet. Lehets\u00e9ges \u00e9rt\u00e9kei: None , Top , Left , Right , Bottom \u00e9s Fill . Egy fel\u00fclre vagy alulra dokkolt vez\u00e9rl\u0151 a sz\u00fcl\u0151 \u00e1tm\u00e9retez\u00e9sekor megtartja a magass\u00e1g\u00e1t, a sz\u00e9less\u00e9gv\u00e1ltoz\u00e1st pedig lek\u00f6veti (pl. egy men\u00fc vagy st\u00e1tuszs\u00e1v tipikusan \u00edgy viselkedik). Ahhoz, hogy egy vez\u00e9rl\u0151 kit\u00f6ltse a teljes marad\u00f3 teret, a dokkol\u00e1st Fill -re kell \u00e1ll\u00edtani. Itt is \u00e9rdemes a GitHub dem\u00f3t futtatva, az \u0171rlapot \u00e1tm\u00e9retezve kipr\u00f3b\u00e1lni, \u00edme a k\u00e9p az \u0171rlap \u00e1tm\u00e9retez\u00e9se el\u0151tt \u00e9s ut\u00e1n: \u00c1tm\u00e9retez\u00e9s ut\u00e1n (sz\u00e9lesebbre \u00e9s alacsonyabbra m\u00e9retezve az ablakot): 3. Feladat - MiniExplorer \u00b6 MiniExplorer layout \u00b6 A feladat sor\u00e1n egy Windows Forms alap\u00fa f\u00e1jlrendszer b\u00f6ng\u00e9sz\u0151 (MiniExplorer) alkalmaz\u00e1st kell elk\u00e9sz\u00edteni. A program kin\u00e9zet\u00e9t a k\u00f6vetkez\u0151 \u00e1bra szeml\u00e9lteti. Az ablak h\u00e1rom r\u00e9szb\u0151l \u00e1lljon: c\u00edmsor az ablak tetej\u00e9n ( TextBox ) TreeView a c\u00edmsor alatt bal oldalon ListView a c\u00edmsor alatt jobb oldalon A c\u00edmsorban mindig az aktu\u00e1lisan kiv\u00e1lasztott mappa teljes el\u00e9r\u00e9si \u00fatvonal\u00e1t l\u00e1thatjuk. Kezdetben legyenek a csom\u00f3pontok \u00f6sszecsukott \u00e1llapotban (\u201e+\u201d ikon mellett\u00fck a f\u00e1ban), lenyitva \u0151ket jelenjenek meg a gyerek csom\u00f3pontok, ha van mappa az adott mapp\u00e1n bel\u00fcl. Elfogadhat\u00f3, hogy el\u0151sz\u00f6r minden csom\u00f3pont lenyithat\u00f3, \u00e9s csak akkor t\u0171nik el a lenyit\u00e1sra/\u00f6sszecsuk\u00e1sra szolg\u00e1l\u00f3 ikon, ha a felhaszn\u00e1l\u00f3 megpr\u00f3b\u00e1lta lenyitni \u00e9s nincs benne mappa. Ha a felhaszn\u00e1l\u00f3 kiv\u00e1laszt egy mapp\u00e1t a TreeView -ban (itt nem a lenyit/\u00f6sszecsuk m\u0171veletre kell gondolni), akkor a ListView -ban jelenjenek meg a mapp\u00e1ban tal\u00e1lhat\u00f3 f\u00e1jlok. A ListView h\u00e1rom oszlopban jelen\u00edtse meg a f\u00e1jlok nev\u00e9t, m\u00e9ret\u00e9t \u00e9s az utols\u00f3 m\u00f3dos\u00edt\u00e1s d\u00e1tum\u00e1t. V\u00e1lasszuk ki a formon l\u00e9v\u0151 TextBox -ot (melyet az els\u0151 p\u00e9ld\u00e1ban raktunk ki), \u00e9s \u00e1ll\u00edtsuk a Dock tulajdons\u00e1g\u00e1t Top -ra. Ezzel a c\u00edmsort az ablak tetej\u00e9hez igaz\u00edtottuk. Tegy\u00fcnk a formra egy SplitContainer -t (ToolBox / Containers). SplitContainer SplitContainer : Figyelj\u00fck meg, hogy ez egy speci\u00e1lis vez\u00e9rl\u0151, mely k\u00e9t egym\u00e1s mell\u00e9 rendezett panelb\u0151l \u00e1ll \u00e9s lehet\u0151s\u00e9get ad a panelok k\u00f6zti ar\u00e1ny v\u00e1ltoztat\u00e1s\u00e1ra. Ez egy olyan kont\u00e9ner t\u00edpus\u00fa vez\u00e9rl\u0151, mely az \u0151t tartalmaz\u00f3 kont\u00e9nert k\u00e9t panelre osztja f\u00fcgg\u0151leges vagy v\u00edzszintes ir\u00e1nyban. A k\u00e9t panel k\u00f6z\u00e9 egy splittert helyez el, mellyel ak\u00e1r fut\u00e1sid\u0151ben is \u00e1tm\u00e9retezhet\u0151 a k\u00e9t panel. A splitter mozgat\u00e1sa letilthat\u00f3, \u00e9s a k\u00e9t panel k\u00f6z\u00fcl az egyikre be\u00e1ll\u00edthat\u00f3, hogy a sz\u00fcl\u0151 kont\u00e9ner m\u00e9retez\u00e9sekor a megadott panel m\u00e9rete ne v\u00e1ltozzon. (Fixed nev\u0171 tulajdons\u00e1gokn\u00e1l \u00e9rdemes keresni.) A SplitContainer elvileg m\u00e1r Fill Dock m\u00f3don ker\u00fclt fel az el\u0151z\u0151 l\u00e9p\u00e9sben (kit\u00f6lti a teret). Ha m\u00e9gsem \u00edgy lenne: v\u00e1lasszuk ki a Dock in parent container opci\u00f3t a SplitPanel smart tag-j\u00e9ben! A bal oldali panel-re rakjunk r\u00e1 egy TreeView vez\u00e9rl\u0151t. A smart tag-j\u00e9ben v\u00e1lasszuk a Dock in parent container funkci\u00f3t. A jobb oldali panelre rakjunk egy ListView vez\u00e9rl\u0151t. A smart tag-j\u00e9ben v\u00e1lasszuk itt is a Dock in parent container funkci\u00f3t. Ezzel el is k\u00e9sz\u00fclt a MiniExplorer, legal\u00e1bbis a fel\u00fclete. MiniExplorer logika \u00b6 Mivel k\u00e9szen van a fel\u00fclet, a k\u00f6vetkez\u0151 feladat azt kit\u00f6lteni. Dupl\u00e1n klikkelj\u00fcnk a form fejl\u00e9c\u00e9n, ezzel tudjuk implement\u00e1lni a Form.Load esem\u00e9ny\u00e9t. Itt fogjuk inicializ\u00e1lni a f\u00e1t: private void MainForm_Load ( object sender , EventArgs e ) { var root = treeView1 . Nodes . Add ( \"Local Disk (C:)\" ); root . Tag = new DirectoryInfo ( @\"C:\\\" ); root . Nodes . Add ( \"\" ); } A TreeView vez\u00e9rl\u0151 TreeNode objektumokat tud megjelen\u00edteni (ezek a fa csom\u00f3pontjait jelk\u00e9pezik). A t\u00e9nyleges inform\u00e1ci\u00f3t (vagyis, hogy melyik k\u00f6nyvt\u00e1r tartozik hozz\u00e1) a TreeNode Tag tulajdons\u00e1gban t\u00e1roljuk el. Ez egy object t\u00edpus\u00fa tulajdons\u00e1g, amivel a legt\u00f6bb vez\u00e9rl\u0151 rendelkezik, \u00e9s pont azt a c\u00e9lt szolg\u00e1lja, hogy a fejleszt\u0151k tetsz\u0151leges, sz\u00e1mukra relev\u00e1ns \u00e9s az adott vez\u00e9rl\u0151h\u00f6z k\u00f6t\u0151d\u0151 inform\u00e1ci\u00f3t t\u00e1roljanak benne. A megold\u00e1sunkban a csom\u00f3ponthoz tartoz\u00f3 k\u00f6nyvt\u00e1r inform\u00e1ci\u00f3t t\u00e1roljuk el benne egy DirectoryInfo objektum form\u00e1j\u00e1ban. R\u00f6videsen megl\u00e1tjuk, mi\u00e9rt van erre sz\u00fcks\u00e9g. A f\u00fcggv\u00e9ny utols\u00f3 sor\u00e1ban l\u00e9trehozunk egy \u201e\u00fcres\u201d gyerek csom\u00f3pontot. Ennek k\u00f6sz\u00f6nhet\u0151en a sz\u00fcl\u0151 mellett meg fog jelenni a kibont\u00e1s jele (+). A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a csom\u00f3pontok kibont\u00e1s\u00e1t val\u00f3s\u00edtjuk meg: amikor a felhaszn\u00e1l\u00f3 kibont (expand) egy csom\u00f3pontot, le kell k\u00e9rdezz\u00fck a csom\u00f3pont \u00e1ltal reprezent\u00e1lt k\u00f6nyvt\u00e1rban tal\u00e1lhat\u00f3 alk\u00f6nyvt\u00e1rakat, \u00e9s a lenyitott TreeNode csom\u00f3ponthoz tartoz\u00f3 k\u00f6nyvt\u00e1r minden alk\u00f6nyvt\u00e1rhoz egy gyerek TreeNode csom\u00f3pontot kell felvegy\u00fcnk. Egy csom\u00f3pont kibont\u00e1s\u00e1r\u00f3l a TreeView vez\u00e9rl\u0151 a BeforeExpand \u00e9s AfterExpand esem\u00e9nyekben \u00e9rtes\u00edt. Sz\u00e1munkra most a BeforeExpand a megfelel\u0151 v\u00e1laszt\u00e1s. Azt, hogy melyik csom\u00f3pont ker\u00fclt kibont\u00e1sra, az esem\u00e9nykezel\u0151 param\u00e9ter\u00e9ben kapjuk meg. Azt pedig, hogy melyik k\u00f6nyvt\u00e1r tartozik egy csom\u00f3ponthoz, a TreeNode Tag tulajdons\u00e1g\u00e1ban mi magunk t\u00e1roljuk el! Menj\u00fcnk vissza a designer-be, v\u00e1lasszuk ki a TreeView -t, majd a Properties ablakban v\u00e1ltsunk esem\u00e9ny n\u00e9zetre (vill\u00e1m ikon). Dupl\u00e1n klikkelj\u00fcnk a BeforeExpand esem\u00e9nyen, hogy implement\u00e1lhassuk: private void treeView1_BeforeExpand ( object sender , TreeViewCancelEventArgs e ) { var parentDI = e . Node ?. Tag as DirectoryInfo ; if ( parentDI == null ) return ; e . Node ?. Nodes . Clear (); try { foreach ( var di in parentDI . GetDirectories ()) { var node = new TreeNode ( di . Name ); node . Tag = di ; node . Nodes . Add ( \"\" ); e . Node ?. Nodes . Add ( node ); } } catch { // lenyelj\u00fck a hib\u00e1t, \u00edgy \u00fagy fog t\u0171nni, mintha \u00fcres lenne a mappa } } A ?. oper\u00e1tor A ?. , vagyis a null-conditional oper\u00e1tor m\u0171k\u00f6d\u00e9se hasonl\u00f3 a klasszikus . , vagyis taghozz\u00e1f\u00e9r\u00e9s oper\u00e1torhoz, de a taghozz\u00e1f\u00e9r\u00e9s csak akkor t\u00f6rt\u00e9nik meg, ha a kifejez\u00e9s bal oldala nem null (egy\u00e9bk\u00e9nt pedig a kifejez\u00e9s \u00e9rt\u00e9ke null lesz). Tulajdonk\u00e9ppen ezt haszn\u00e1ltuk kor\u00e1bban a C# esem\u00e9nyek felt\u00e9teles els\u00fct\u00e9sekor az <esem\u00e9ny>?.Invoke() sor\u00e1n is. Tesztelj\u00fck az alkalmaz\u00e1st. K\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t a jobboldali panel megval\u00f3s\u00edt\u00e1s\u00e1ra. Itt akkor kell a tartalmat friss\u00edteni, amikor (pontosabban miut\u00e1n) a baloldali TreeView -ban a felhaszn\u00e1l\u00f3 kiv\u00e1lasztott egy csom\u00f3pontot. Err\u0151l a TreeView az AfterSelect esem\u00e9ny\u00e9ben k\u00fcld \u00e9rtes\u00edt\u00e9st. A kor\u00e1bbihoz hasonl\u00f3an a kiv\u00e1lasztott TreeNode csom\u00f3pontot az esem\u00e9nykezel\u0151 param\u00e9ter\u00e9ben kapjuk meg. private void treeView1_AfterSelect ( object sender , TreeViewEventArgs e ) { var parentDI = e . Node ?. Tag as DirectoryInfo ; if ( parentDI == null ) return ; listView1 . Items . Clear (); try { foreach ( FileInfo fi in parentDI . GetFiles ()) { listView1 . Items . Add ( fi . Name ); } } catch { // lenyelj\u00fck a hib\u00e1t, \u00edgy \u00fagy fog t\u0171nni, mintha \u00fcres lenne a mappa } } Hibakezel\u00e9s Vegy\u00fck \u00e9szre, hogy a fenti k\u00e9t f\u00fcggv\u00e9nyben mindk\u00e9t esetben egy try-catch blokkot haszn\u00e1ltunk. Ez az\u00e9rt van, mert a laborg\u00e9peken \u00e1tlagos felhaszn\u00e1l\u00f3k\u00e9nt sokszor nincs jogunk egyes mapp\u00e1k/f\u00e1jlok el\u00e9r\u00e9s\u00e9re, ami a list\u00e1z\u00f3 f\u00fcggv\u00e9nyek eset\u00e9ben kiv\u00e9telt v\u00e1lt ki. Egy val\u00f3s alkalmaz\u00e1sban semmik\u00e9ppen nem hagyn\u00e1nk \u00fcresen a catch blokkot, mindenk\u00e9ppen napl\u00f3zn\u00e1nk, vagy a felhaszn\u00e1l\u00f3 tudom\u00e1s\u00e1ra hozn\u00e1nk a hib\u00e1t. A legegyszer\u0171bb MessageBox alap\u00fa megold\u00e1s ez lenne: catch ( UnatuhorizedAccessExceotion ex ) { MessageBox . Show ( ex . Message , \"Error\" , MessageBoxButtons . OK , MessageBoxIcon . Error )) } Ugyanitt ki tudjuk t\u00f6lteni az Address r\u00e9szt is: tbDemoText . Text = parentDI . FullName ; K\u00f6vetkez\u0151 l\u00e9p\u00e9sben val\u00f3s\u00edtsuk meg a t\u00f6bboszlopos n\u00e9zetet a jobboldali panelen. A k\u00f3dot m\u00f3dos\u00edtsuk \u00fagy, hogy ne csak a nev\u00e9t adja meg a f\u00e1jlnak, hanem egy\u00e9b param\u00e9tereit is. Az Add f\u00fcggv\u00e9nyt param\u00e9terezz\u00fck \u00edgy: listView1 . Items . Add ( new ListViewItem ( new string [] { fi . Name , fi . Length . ToString (), fi . LastWriteTime . ToString (), fi . FullName })); Az adatok teh\u00e1t m\u00e1r megvannak, de m\u00e9g nem jelennek meg. Ehhez a ListView -t m\u00f3dos\u00edtani kell a designer-ben, hogy mutassa a r\u00e9szleteket is. Hozzuk el\u0151 a smart tag-j\u00e9t, \u00e9s \u00e1ll\u00edtsuk \u00e1t rajta a View -t Details -re. Az oszlopokat nek\u00fcnk kell l\u00e9trehoznunk, amihez a smart tag-j\u00e9ben v\u00e1lasszuk az Edit Columns funkci\u00f3t, majd a megjelen\u0151 list\u00e1t t\u00f6lts\u00fck fel 3 \u00faj elemmel, amelyeknek a Text tulajdons\u00e1ga legyen: Name , Size , Modified . Rendezz\u00fck el sz\u00e9pen az oszlopok sz\u00e9less\u00e9g\u00e9t olyan m\u00f3don, hogy minden kif\u00e9rjen majd a felt\u00f6lt\u00e9s ut\u00e1n is. Ezekben az oszlopokban az adatok pont olyan sorrendben fognak megjelenni, mint ahogy a 6. pontban a listaelemhez hozz\u00e1rendelt\u00fck azokat. ListView oszlopok Sajnos a ListView be\u00e9p\u00edtetten el\u00e9g t\u00f6r\u00e9keny megold\u00e1st ny\u00fajt csak az oszlopok \u00e9s azok \u00e9rt\u00e9keinek \u00f6sszerendel\u00e9s\u00e9re. A modernebb UI keretrendszerek (pl.: WPF, WinUI, .NET MAUI) az adatk\u00f6t\u00e9s mechanizmus\u00e1n kereszt\u00fcl egy k\u00e9nyelmesebb, deklarat\u00edvabb \u00e9s robusztusabb megold\u00e1st ny\u00fajtanak erre. Futtat\u00e1s \u00b6 Utols\u00f3 \u00e9rdekess\u00e9gk\u00e9nt megoldhatjuk, hogy a jobb oldali n\u00e9zetben egy f\u00e1jlon dupl\u00e1n kattintva a rendszer megnyissa/v\u00e9grehajtsa azt. Ehhez iratkozzunk fel a ListView DoubleClick esem\u00e9ny\u00e9re \u00e9s val\u00f3s\u00edtsuk meg a k\u00f6vetkez\u0151k\u00e9ppen: private void listView1_DoubleClick ( object sender , EventArgs e ) { if ( listView1 . SelectedItems . Count != 1 ) return ; var fullName = listView1 . SelectedItems [ 0 ]. SubItems [ 3 ]. Text ; if ( fullName != null ) { Process . Start ( new ProcessStartInfo ( fullName ) { UseShellExecute = true }); } } Windows st\u00edlusok (nem tanagyag) \u00b6 Ha zavar minket, hogy nem a rendszer st\u00edlus\u00e1t haszn\u00e1lj\u00e1k a TreeView \u00e9s a ListView vez\u00e9rl\u0151k, akkor a SetWindowTheme Win32 API f\u00fcggv\u00e9nyt megh\u00edvva ki tudjuk k\u00e9nyszer\u00edteni, hogy a File Explorer/F\u00e1jlkezel\u0151 alkalmaz\u00e1sban megszokott st\u00edlusban jelenjenek meg. [DllImport(\"uxtheme.dll\", ExactSpelling = true, CharSet = CharSet.Unicode)] private static extern int SetWindowTheme ( IntPtr hwnd , string pszSubAppName , string? pszSubIdList ); private void MainForm_Load ( object sender , EventArgs e ) { var root = treeView1 . Nodes . Add ( \"Local Disk (C:)\" ); root . Tag = new DirectoryInfo ( @\"C:\\\" ); root . Nodes . Add ( \"\" ); SetWindowTheme ( treeView1 . Handle , \"explorer\" , null ); SetWindowTheme ( listView1 . Handle , \"explorer\" , null ); // Elt\u00fcnteti a csom\u00f3pontokat \u00f6sszek\u00f6t\u0151 vonalakat treeView1 . ShowLines = false ; } A megold\u00e1sunkban a .NET platform \u00fan. P/Invoke (Platform Invoke) mechanizmus\u00e1t vetj\u00fck be. Ez lehet\u0151v\u00e9 teszi, hogy a DllImport attrib\u00fatummal nat\u00edv DLL-ekb\u0151l f\u00fcggv\u00e9nyeket hivatkozzunk be, megfelel\u0151 param\u00e9terez\u00e9s\u0171 statikus C# f\u00fcggv\u00e9nydeklar\u00e1ci\u00f3khoz rendelj\u00fck, majd ezek seg\u00edts\u00e9g\u00e9vel a nat\u00edv f\u00fcggv\u00e9nyeket megh\u00edvjuk. A SetWindowTheme f\u00fcggv\u00e9ny els\u0151 param\u00e9terek\u00e9nt a vez\u00e9rl\u0151 Handle -j\u00e9t kell \u00e1tadni, m\u00e1sodik param\u00e9terek\u00e9nt pedig a process nev\u00e9t, amelyr\u0151l m\u00e1solni akarjuk a st\u00edlusokat. A fenti k\u00f3d utols\u00f3 sor\u00e1ban a treeView1.ShowLines false -ra \u00e1ll\u00edt\u00e1s\u00e1val kikapcsoljuk a fastrukt\u00far\u00e1ban az \u00f6sszek\u00f6t\u0151 vonalak alkalmaz\u00e1s\u00e1t. \u00cdme a v\u00e9geredm\u00e9ny:","title":"3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa"},{"location":"labor/3-felhasznaloi-felulet/#3-a-felhasznaloi-felulet-kialakitasa","text":"","title":"3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa"},{"location":"labor/3-felhasznaloi-felulet/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja egy l\u00e1tv\u00e1nyos, gyors alkalmaz\u00e1sfejleszt\u00e9s bemutat\u00e1sa, mely egyben megteremti a lehet\u0151s\u00e9get a Windows Forms fejleszt\u00e9s alapjainak elsaj\u00e1t\u00edt\u00e1s\u00e1ra. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt): Windows Forms alkalmaz\u00e1sfejleszt\u00e9s alapok Men\u00fck Dokkol\u00e1s \u00e9s horgonyz\u00e1s SplitView TreeView ListView Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: 3-4. el\u0151ad\u00e1s \u2013 Vastagkliens alkalmaz\u00e1sok fejleszt\u00e9se.","title":"A gyakorlat c\u00e9lja"},{"location":"labor/3-felhasznaloi-felulet/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)","title":"El\u0151felt\u00e9telek"},{"location":"labor/3-felhasznaloi-felulet/#bevezeto","text":"A Rapid Application Development (RAD) elve a fejleszt\u00e9si id\u0151 ler\u00f6vid\u00edt\u00e9s\u00e9t c\u00e9lozza meg az\u00e1ltal, hogy a fejleszt\u00e9s sor\u00e1n k\u00e9sz komponensekkel dolgozik, integr\u00e1lt fejleszt\u0151 k\u00f6rnyezetet (pl. Visual Studio) \u00e9s sok automatizmust alkalmaz. Fontos ugyanakkor, hogy az automatizmusok ne sz\u0171k\u00edts\u00e9k be t\u00falzottan a fejleszt\u0151 lehet\u0151s\u00e9geit \u00e9s kell\u0151 rugalmass\u00e1got adjanak neki a rendszerek testre szab\u00e1s\u00e1ban. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban l\u00e1tni fogjuk, mik\u00e9nt alkalmas mindezekre a Windows Forms k\u00f6rnyezet. A Window Forms alkalmaz\u00e1sok legfontosabb koncepci\u00f3it a t\u00e1rgy 3.-4. el\u0151ad\u00e1sa ismerteti. Egy Windows Forms alkalmaz\u00e1sban az alkalmaz\u00e1sunk minden ablak\u00e1nak egy saj\u00e1t oszt\u00e1lyt kell l\u00e9trehozni, mely a be\u00e9p\u00edtett Form oszt\u00e1lyb\u00f3l sz\u00e1rmazik. Erre \u2013 tipikusan a Visual Studio designer\u00e9vel - vez\u00e9rl\u0151ket helyez\u00fcnk fel, melyek a Form oszt\u00e1lyunk tagv\u00e1ltoz\u00f3i lesznek. IntelliSense A k\u00f6vetkez\u0151 p\u00e9ld\u00e1kban sz\u00e1mos gener\u00e1lt (\u00e9s emiatt hossz\u00fa) elnevez\u00e9ssel fogunk tal\u00e1lkozni. Programjaink megval\u00f3s\u00edt\u00e1sakor haszn\u00e1ljuk ki az automatikus k\u00f3dkieg\u00e9sz\u00edt\u00e9s (IntelliSense) ny\u00fajtotta lehet\u0151s\u00e9geket \u00e9s ne k\u00e9zzel g\u00e9pelj\u00fck be az egyes elnevez\u00e9seket.","title":"Bevezet\u0151"},{"location":"labor/3-felhasznaloi-felulet/#1-feladat-hello-world-windows-forms-technologiaval","text":"A feladat sor\u00e1n egy olyan Windows Forms alkalmaz\u00e1st k\u00e9sz\u00edt\u00fcnk el, amely egy egyszer\u0171 ablakban ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget. Ind\u00edtsuk el a Visual Studio 2022-t Hozzunk l\u00e9tre egy C# nyelv\u0171, Windows Forms t\u00edpus\u00fa alkalmaz\u00e1st, m\u00e9gpedig .NET 6 platformra. Ehhez a VS ind\u00edt\u00f3ablak\u00e1ban jobb oldalt a Create new project gombon kell kattintani, majd a projekt l\u00e9trehoz\u00f3 var\u00e1zsl\u00f3ban a Windows Forms App sablont kell kiv\u00e1lasztani. L\u00e9nyeges, hogy NE a Windows Forms App (.NETFramework) legyen! A sablon kikeres\u00e9s\u00e9hez haszn\u00e1ljuk az ablak keres\u0151/sz\u0171r\u0151mez\u0151it, amennyiben sz\u00fcks\u00e9ges. Kattintsunk a Next gombra. A megjelen\u0151 oldalon A Projekt name \u00e9s Solution name legyen HelloWorldWF Az \u00fatvonal a laborg\u00e9peken: C:\\Work\\ alatt egy mappa, mely a saj\u00e1t nev\u00fcnk vagy Neptun k\u00f3dunk szerint van nevezve. Next gombbal k\u00f6vetkez\u0151 oldalra v\u00e1lt\u00e1s A Framework mez\u0151ben v\u00e1lasszuk ki a .NET 6.0 (Long term support) -ot. Futtassuk a kiindul\u00f3 projektet, hogy l\u00e1ssuk, mit biztos\u00edt a kiindul\u00f3 alkalmaz\u00e1skeret (nem sokat, van egy egyszer\u0171 ablak). \u00c1ll\u00edtsuk le a fut\u00f3 alkalmaz\u00e1st. Kattintsunk dupl\u00e1n a Form1.cs f\u00e1jlra! Ezt k\u00f6vet\u0151en a fel\u00fcleten megjelenik egy sz\u00fcrke ablak. Amennyiben a Solution Explorerben a Form1.cs f\u00e1jl elemet kibontjuk, l\u00e1tni fogjuk, hogy egy Form1.designer.cs nev\u0171 f\u00e1jl is tartozik hozz\u00e1. A fenti egyszer\u0171 program fel\u00e9p\u00edt\u00e9s\u00e9t k\u00f6nnyen v\u00e9gig k\u00f6vethetj\u00fck kor\u00e1bbi ismereteink alapj\u00e1n. A program bel\u00e9p\u00e9si pontja itt is a Program.cs f\u00e1jlban tal\u00e1lhat\u00f3 Main f\u00fcggv\u00e9ny. A f\u00fcggv\u00e9ny l\u00e9trehoz egy p\u00e9ld\u00e1nyt a Form1 oszt\u00e1lyb\u00f3l, majd az Application.Run f\u00fcggv\u00e9ny seg\u00edts\u00e9g\u00e9vel elind\u00edtja az \u00fczenetkezel\u0151 ciklust \u00e9s megjelen\u00edti az ablakot (a Windows Forms vil\u00e1g\u00e1ban \u201eForm\u201d-nak h\u00edvjuk az ablakokat). A Form1 oszt\u00e1ly k\u00f3dja k\u00e9t f\u00e1jlban van defini\u00e1lva (ezt a C# partial kulcsszava teszi lehet\u0151v\u00e9). A Form1.cs a felhaszn\u00e1l\u00f3 \u00e1ltal kezelt k\u00f3dr\u00e9szleteket, m\u00edg a Form1.designer.cs a grafikus Form designer \u00e1ltal gener\u00e1lt k\u00f3dot tartalmazza. Ez ut\u00f3bbi mindig teljes szinkronban van a design n\u00e9zettel, k\u00f6zvetlen m\u00f3dos\u00edt\u00e1s\u00e1ra ugyan van lehet\u0151s\u00e9g, de a speci\u00e1lis hibaelh\u00e1r\u00edt\u00e1si eseteket lesz\u00e1m\u00edtva felesleges \u00e9s ker\u00fclend\u0151. Figyelj\u00fck meg, hogy a k\u00e9t f\u00e1jl k\u00f6z\u00f6tt m\u00e1r a gener\u00e1lt k\u00f3d alapj\u00e1n is kapcsolat van, hiszen a Form1 konstruktora \u00e1th\u00edv a m\u00e1sik f\u00e1jlban defini\u00e1lt InitializeComponent() f\u00fcggv\u00e9nybe. Designer n\u00e9zet \u00e9s k\u00f3d k\u00f6z\u00f6tt v\u00e1lt\u00e1s Amennyiben a Form1.cs f\u00e1jlra dupl\u00e1n kattintunk, alap\u00e9rtelmez\u00e9sben nem a forr\u00e1sk\u00f3d, hanem a tervez\u0151 n\u00e9zet (Form designer) jelenik meg. Innen a forr\u00e1sk\u00f3d n\u00e9zetre a fel\u00fcleten jobb kattintva, a View Code men\u00fcponttal, vagy az F7 billenty\u0171 megnyom\u00e1s\u00e1val juthatunk. Elk\u00e9pzelhet\u0151, hogy megjelenik egy tov\u00e1bbi, Form1.resx nev\u0171 f\u00e1jl is. Ez az ablakhoz tartoz\u00f3 er\u0151forr\u00e1sokat (tipikusan k\u00e9pek, sz\u00f6vegek) tartalmazhatja, de a mi eset\u00fcnkben most nincs jelent\u0151s\u00e9ge. Kattintsunk dupl\u00e1n a Form1.cs f\u00e1jlra! Ez alap\u00e9rtelmez\u00e9sben a tervez\u0151 n\u00e9zetet nyitja meg. Kattintsunk az \u0171rlap h\u00e1tter\u00e9n, hogy az \u0171rlap legyen kiv\u00e1lasztva. A Visual Studio Properties ablak\u00e1ban l\u00e1thatjuk az \u0171rlapunk aktu\u00e1lis tulajdons\u00e1gait. Amennyiben a Properties ablak nem l\u00e1that\u00f3, az F4 billenty\u0171vel tudjuk el\u0151csalni (vagy View men\u00fc / Properties). A Properties ablakban keress\u00fck meg a Text tulajdons\u00e1got, \u00e9s \u00edrjuk \u00e1t \u201eHello World\u201d -re. Ez az \u0171rlapunk fejl\u00e9c\u00e9nek a sz\u00f6veg\u00e9t \u00e1ll\u00edtja be. Mint l\u00e1that\u00f3, az \u0171rlapunk sz\u00e1mos tulajdons\u00e1ggal rendelkezik, ezek mindegyik\u00e9t a Properties ablakban be tudjuk \u00e1ll\u00edtani az aktu\u00e1lis ig\u00e9nyeknek megfelel\u0151en. Nyissuk ki a Toolbox-ot ( View men\u00fc / Toolbox ). H\u00fazzunk r\u00e1 a formra egy TextBox \u00e9s egy Button (gomb) vez\u00e9rl\u0151t tetsz\u0151leges helyre! (Ezeket a vez\u00e9rl\u0151ket a Toolbox Common Windows Forms csoportj\u00e1ban tal\u00e1ljuk). Kattintsunk egyszer a gomb vez\u00e9rl\u0151n, hogy biztosan az legyen kiv\u00e1lasztva a designerben. Ekkor a Properties ablakban a gombunk tulajdons\u00e1gai jelennek meg. \u00c1ll\u00edtsuk be a Text tulajdons\u00e1g\u00e1t \u201eBe\u00e1ll\u00edt\u201d-ra, ez a gombunk sz\u00f6veg\u00e9t fogja ennek megfelel\u0151en be\u00e1ll\u00edtani. Ugyanitt a Properties ablakban \u00e1ll\u00edtsuk be gombunk referenci\u00e1j\u00e1t tartalmaz\u00f3 oszt\u00e1lyv\u00e1ltoz\u00f3 nev\u00e9t, vagyis a Name tulajdons\u00e1g\u00e1t button1 -r\u0151l bUpdateText -re. L\u00e9nyeges, hogy a vez\u00e9rl\u0151inket a funkci\u00f3juknak megfelel\u0151 nevekkel l\u00e1ssuk el, ez nagyban seg\u00edti a k\u00f3dunk olvashat\u00f3s\u00e1g\u00e1t. A b prefix a vez\u00e9rl\u0151 Button t\u00edpus\u00e1ra utal. Hungarian Notation A fenti prefixelt elnevez\u00e9si konvenci\u00f3t Hungarian Notation nek h\u00edvj\u00e1k, mert Charles Simonyi (Simonyi K\u00e1roly fia) tal\u00e1lta ki, amikor az Excel csapatban dolgozott a Micorosftn\u00e1l. A koncepci\u00f3 els\u0151sorban C++-hoz k\u00e9sz\u00fclt, olyan id\u0151kben, amikor m\u00e9g nem voltak gazdag funkcionalit\u00e1s\u00fa fejelszt\u0151k\u00f6rnyezetek, \u00e9s egy egyszer\u0171 sz\u00f6vegszerkeszt\u0151vel is r\u00e1n\u00e9z\u00e9sre meg kellett tudni mondani, hogy a v\u00e1ltoz\u00f3 milyen t\u00edpus\u00fa. Ez manaps\u00e1g m\u00e1r nem relev\u00e1ns, mert a Visual Studio is pl. az eg\u00e9rkurzor seg\u00edts\u00e9g\u00e9vel visszajelz\u00e9st ad a v\u00e1ltoz\u00f3 t\u00edpus\u00e1r\u00f3l. Az el\u0151z\u0151 l\u00e9p\u00e9s mint\u00e1j\u00e1ra nevezz\u00fck \u00e1t a TextBox vez\u00e9rl\u0151nket tbDemoText -re. A tb prefix a vez\u00e9rl\u0151 TextBox t\u00edpus\u00e1ra utal. Az \u0171rlapunk neve jelenleg Form1 , mely szint\u00e9n el\u00e9g semmitmond\u00f3. Nevezz\u00fck \u00e1t MainForm -ra, az al\u00e1bbi l\u00e9p\u00e9seket k\u00f6vetve. Az \u00e1tnevez\u00e9st a Solution Explorerben tudjuk megtenni, itt t\u00f6bb technik\u00e1t is haszn\u00e1lhatunk. V\u00e1lasszuk ki a Form1 elemet, majd m\u00e9g egyszer kattintsunk rajta bal gombbal: ekkor a n\u00e9v szerkeszthet\u0151v\u00e9 v\u00e1lik (pont \u00fagy dolgozunk, ahogy egy f\u00e1jlt is \u00e1tnevez\u00fcnk Windows F\u00e1jlkezel\u0151ben/File Explorerben). Vagy egyszer\u0171en csak megnyomjuk az F2 billenty\u0171t az \u00e1tnevez\u00e9s elind\u00edt\u00e1s\u00e1hoz. Vagy ak\u00e1r haszn\u00e1lhatjuk a jobb gombos men\u00fc Rename funkci\u00f3j\u00e1t. Ak\u00e1rhogy is indultunk, \u00edrjuk be \u00faj n\u00e9vnek a MainForm.cs -t, majd nyomjuk meg az Enter billenty\u0171t. Ekkor a Visual Studio r\u00e1k\u00e9rdez egy felugr\u00f3 ablakban, hogy minden kapcsol\u00f3d\u00f3 elemet nevezzen-e \u00e1t ennek megfelel\u0151en: itt mindenk\u00e9ppen Yes -t v\u00e1lasszunk: Hiba \u00e1tnevez\u00e9s ut\u00e1n Ekkor a VS2022 hajlamos egy hiba\u00fczenetet megjelen\u00edteni az \u0171rlapunk hely\u00e9n, amennyiben meg volt nyitva a designerben. Ne ijedj\u00fcnk meg t\u0151le, z\u00e1rjuk be az \u0171rlap tabf\u00fcl\u00e9t (vagy valamennyi megnyitott f\u00e1jl tabf\u00fcl\u00e9t), \u00e9s nyissuk meg \u00fajra a Solution Explorerben az \u0171rlapot: ekkor a hiba elt\u0171nik. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a gombkattint\u00e1s esem\u00e9nyt fogjuk lekezelni: ennek hat\u00e1s\u00e1ra a tbDemoText TextBox vez\u00e9rl\u0151be be\u00edrjuk a \u201eHello\u201d sz\u00f6veget. Egy \u0171rlap/vez\u00e9rl\u0151 esem\u00e9nyeinek megjelen\u00edt\u00e9s\u00e9re is a Properties ablak szolg\u00e1l, csak \u00e1t kell v\u00e1ltsunk az esem\u00e9nymegjelen\u00edt\u0151 n\u00e9zet\u00e9re. Ehhez a Properties ablak fels\u0151 r\u00e9sz\u00e9n tal\u00e1lhat\u00f3 vill\u00e1m ikonon kell kattintanunk: Tulajdons\u00e1gok A tulajdons\u00e1gok megjelen\u00edt\u00e9s\u00e9re \u00fagy tudunk a k\u00e9s\u0151bbiekben majd visszav\u00e1ltani, ha a vill\u00e1m ikont\u00f3l balra elhelyezked\u0151 vill\u00e1skulcs ikonra kattintunk (ezt egyel\u0151re ne tegy\u00fck meg). Az esem\u00e9nylist\u00e1ban l\u00e1that\u00f3, hogy a Button oszt\u00e1lynak sz\u00e1mos esem\u00e9nye van. Sz\u00e1munkra most a Click esem\u00e9ny az \u00e9rdekes. Erre k\u00e9tf\u00e9lek\u00e9ppen tudunk feliratkozni: Az esem\u00e9nylist\u00e1ban a Click elemen dupl\u00e1n kattintunk. A designer fel\u00fcleten a gombon dupl\u00e1n kattintva. A designer fel\u00fcleten a dupl\u00e1n kattint\u00e1s mindig a vez\u00e9rl\u0151 - a vez\u00e9rl\u0151 t\u00edpus\u00e1t\u00f3l f\u00fcgg\u0151 - alap\u00e9rtelmezett esem\u00e9ny\u00e9re iratkozik fel. Mivel a Click esem\u00e9ny a Button oszt\u00e1ly alap\u00e9rtelemezett esem\u00e9nye, ez nek\u00fcnk most pont meg is felel. V\u00e1lasszuk most a m\u00e1sodik lehet\u0151s\u00e9get, kattintsunk dupl\u00e1n a gomb vez\u00e9rl\u0151n. Ez l\u00e9trehoz egy esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt, mely akkor kiv\u00f3dik fut\u00e1s k\u00f6zben, amikor a felhaszn\u00e1l\u00f3 kattint a gombon (ak\u00e1r eg\u00e9rrel, ak\u00e1r a Tab billenty\u0171vel r\u00e1navig\u00e1lva a Space billenty\u0171 lenyom\u00e1s\u00e1val). A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben a tbDemoText objektum Text tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be \"Hell\u00f3\"-ra. private void bUpdateText_Click ( object sender , EventArgs e ) { tbDemoText . Text = \"Hello\" ; } Esem\u00e9nykezel\u0151k fejl\u00e9ce Ha nem tetszik a dupla klikkes gener\u00e1lt n\u00e9v (a hungarian notation miatt kisbet\u0171vel kezd\u0151dik, ami nem t\u00fal C#-os), akkor egyszer\u0171en kezdj\u00fck el beg\u00e9pelni a Properties ablak k\u00edv\u00e1nt esem\u00e9ny\u00e9hez a f\u00fcggv\u00e9ny nev\u00e9t, majd nyomjunk Entert. Az esem\u00e9nykezel\u0151ket tipikusan \u00fagy szoktuk elnevezni, hogy utaljon a vez\u00e9rl\u0151re (alap\u00e9rtelmezetten a neve) majd alulvon\u00e1s ut\u00e1n az esem\u00e9ny neve k\u00f6vetkezik. A Windows Forms vez\u00e9rl\u0151inek esem\u00e9nykezel\u0151iben szinte mindig k\u00e9t param\u00e9tert kapunk: object sender : A kiv\u00e1lt\u00f3 objektum (sajnos nem er\u0151sen t\u00edpusosan) EventArgs e : Az esem\u00e9nyhez tartoz\u00f3 param\u00e9tereket tartalmazza. T\u00edpusa EventArgs , vagy annak lesz\u00e1rmazottja. Az EventArgs itt egy \u00fcres param\u00e9tert reprezent\u00e1l, mert a gombkattint\u00e1shoz nem tartozik semmi extra adat. EventArgs lesz\u00e1rmazott olyan esem\u00e9nyek eset\u00e9n haszn\u00e1lt, melyekhez valamilyen plusz adat is tartozik (pl. billenty\u0171 lenyom\u00e1sn\u00e1l a lenyomott billenty\u0171 k\u00f3dja). Futtassuk az alkalmaz\u00e1st (F5)! Nyomjuk meg a gombot! N\u00e9zz\u00fcnk bele \u00fajra a MainForm.Designer.cs -be. Megtal\u00e1ljuk az \u00fajonnan gener\u00e1lt k\u00f3dot: az \u0171rlapon elhelyezett vez\u00e9rl\u0151kb\u0151l tagv\u00e1ltoz\u00f3k lesznek, melyek az InitializeComponent f\u00fcggv\u00e9nyben ker\u00fclnek inicializ\u00e1l\u00e1sra, itt tal\u00e1ljuk a tulajdons\u00e1gaik be\u00e1ll\u00edt\u00e1s\u00e1t, valamint az esem\u00e9nyekre val\u00f3 feliratkoz\u00e1st. Figyelj\u00fck meg azt is, hogy a gomb lenyom\u00e1s\u00e1ra tulajdonk\u00e9ppen egy C# esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt regisztr\u00e1ltunk be a m\u00e1r ismert += oper\u00e1tor alkalmaz\u00e1s\u00e1val. L\u00e1thatjuk, hogy a designer csak olyan k\u00f3dot gener\u00e1l, melyet ak\u00e1r mi is meg tudn\u00e1nk \u00edrni, de persze \u00edgy egyszer\u0171bb azt elk\u00e9sz\u00edteni.","title":"1. Feladat \u2013 \u201eHello world\u201d Windows Forms technol\u00f3gi\u00e1val"},{"location":"labor/3-felhasznaloi-felulet/#nehany-alapfogalom-attekintese","text":"","title":"N\u00e9h\u00e1ny alapfogalom \u00e1ttekint\u00e9se"},{"location":"labor/3-felhasznaloi-felulet/#form-felulettervezes","text":"A Form oszt\u00e1ly az ablakot reprezent\u00e1lja, \u00e9s egyben a kont\u00e9ner-vez\u00e9rl\u0151 kapcsolatban a legfels\u0151 szint\u0171 kont\u00e9ner (tartalmaz\u00f3). A fel\u00fclet kialak\u00edt\u00e1sa szempontj\u00e1b\u00f3l az alkalmaz\u00e1sunk lehet: Dial\u00f3gus alap\u00fa: Kiz\u00e1r\u00f3lag vez\u00e9rl\u0151ket helyez\u00fcnk el az \u0171rlapon, mintha egy dial\u00f3gus ablak lenne. Ha sz\u00fcks\u00e9ges, \u00faj ablakot nyitunk az egyes funkci\u00f3knak. Pl. sokszor ilyenek az \u00fczleti/v\u00e1llalati alkalmaz\u00e1sok. SDI, vagy MDI: Dokumentum alap\u00fa alkalmaz\u00e1s, mely esetben az \u0171rlap a dokumentum megjelen\u00edt\u0151je \u00e9s esetleg szerkeszt\u0151je. Az egy\u00e9b vez\u00e9rl\u0151ket/funkci\u00f3kat a men\u00fcbe \u00e9s a toolbarra (eszk\u00f6zs\u00e1v) tessz\u00fck. Az SDI (Single Document Interface) egy dokumentumot kezel egy id\u0151ben, az MDI (Multiple Document Interface) pedig t\u00f6bbet. Pl. ilyenek sz\u00f6vegszerkeszt\u0151k, vagy maga a Visual Studio is. Vegyes: Az ilyen jelleg\u0171 alkalmaz\u00e1sokban a dokumentum szerkeszt\u00e9se a c\u00e9l csak\u00fagy, mint az SDI/MDI v\u00e1ltozatokban, azonban az ablak egy r\u00e9sze fenn van tartva vez\u00e9rl\u0151k sz\u00e1m\u00e1ra, ahol k\u00f6nnyen el\u00e9rhetj\u00fck a funkci\u00f3kat. Pl. ilyenek a CAD alkalmaz\u00e1sok.","title":"Form - fel\u00fclettervez\u00e9s"},{"location":"labor/3-felhasznaloi-felulet/#kontener-vezerlo-tartalmazasi-hierarchia","text":"Egy ablak/\u0171rlap hierarchikus (fa) fel\u00e9p\u00edt\u00e9s\u0171, amelyben a gy\u00f6k\u00e9robjektum maga a Form . L\u00e9nyeges, hogy itt nem sz\u00e1rmaztat\u00e1si, hanem tartalmaz\u00e1si hierarchi\u00e1r\u00f3l van sz\u00f3 . Alatta \u00fajabb kont\u00e9nerek lehetnek egym\u00e1sba \u00e1gyazva, vagy csak egym\u00e1s mellett. A hierarchia alj\u00e1n vannak az egyszer\u0171 vez\u00e9rl\u0151k, de lehetnek vez\u00e9rl\u0151 n\u00e9lk\u00fcli kont\u00e9nerek is. Az egym\u00e1sba \u00e1gyaz\u00e1s az\u00e9rt sz\u00fcks\u00e9ges, hogy egys\u00e9gk\u00e9nt lehessen kezelni a kont\u00e9nereket \u00e9s a gyerekeiket, \u00edgy p\u00e9ld\u00e1ul od\u00e9bb h\u00fazva a kont\u00e9nert vele mozognak az \u00e1ltala tartalmazott vez\u00e9rl\u0151k is. A m\u00e1sik fontos ok a tulajdons\u00e1g\u00f6r\u00f6kl\u00e9s, amely lehet\u0151v\u00e9 teszi, hogy ha megv\u00e1ltoztatjuk valamelyik kont\u00e9ner \u00f6r\u00f6k\u00f6lhet\u0151 tulajdons\u00e1g\u00e1t (pl. Font ), akkor azt a gyerekei is meg\u00f6r\u00f6k\u00f6lj\u00e9k. Ez nem a szok\u00e1sos objektum-orient\u00e1lt \u00f6r\u00f6kl\u00e9s, de a sz\u00fcl\u0151-gyermek viszony azonos elvre \u00e9p\u00fcl.","title":"Kont\u00e9ner-vez\u00e9rl\u0151 tartalmaz\u00e1si hierarchia"},{"location":"labor/3-felhasznaloi-felulet/#uzenetkezeles","text":"A Windows Forms alap\u00fa alkalmaz\u00e1sok \u00fczenetkezel\u00e9sre \u00e9p\u00fclnek, amelynek a h\u00e1tter\u00e9ben az oper\u00e1ci\u00f3s rendszer \u00fczenetkezel\u0151 mechanizmusa \u00e1ll. Az \u00fczenetkezel\u0151 ciklus a Main f\u00fcggv\u00e9nyben van ( Application.Run ), amely csak akkor l\u00e9p ki, ha bez\u00e1rjuk az alkalmaz\u00e1sunkat.","title":"\u00dczenetkezel\u00e9s"},{"location":"labor/3-felhasznaloi-felulet/#visual-studio-designer","text":"A designer a felhaszn\u00e1l\u00f3i fel\u00fclet szerkeszt\u0151je, amelyben lehet\u0151s\u00e9g\u00fcnk van \u00faj elemeket felvenni, illetve a megl\u00e9v\u0151ket m\u00f3dos\u00edtani \u00e9s t\u00f6r\u00f6lni. A designer fontosabb elemei/kell\u00e9kei: Toolbox : Err\u0151l lehet a kont\u00e9nereket \u00e9s vez\u00e9rl\u0151ket r\u00e1h\u00fazni az \u0171rlapra. Properties ablak/Property Editor : A kijel\u00f6lt vez\u00e9rl\u0151 tulajdons\u00e1gait \u00e9s esem\u00e9nyeit mutatja, illetve itt lehet ezeket m\u00f3dos\u00edtani is. Az F4 billenty\u0171vel is el\u00e9rhet\u0151. Smart tag : A legt\u00f6bb vez\u00e9rl\u0151 t\u00edpus eset\u00e9n t\u00e1mogatott. A vez\u00e9rl\u0151t kiv\u00e1lasztva annak jobb fels\u0151 sark\u00e1ban megjelenik egy kis ny\u00edl, amelyre kattintva megjelenik. Ebben n\u00e9h\u00e1ny kiemelt tulajdons\u00e1g \u00e9s k\u00e9nyelmi funkci\u00f3 \u00e9rhet\u0151 el. Document outline ablak : A kont\u00e9ner-vez\u00e9rl\u0151 hierarchi\u00e1t mutatja. Itt ki lehet jel\u00f6lni az egyes vez\u00e9rl\u0151ket, illetve mozgatni is lehet \u0151ket a hierarchi\u00e1ban, mely \u00e9rv\u00e9nyes\u00fcl az \u0171rlapon is.","title":"Visual Studio Designer"},{"location":"labor/3-felhasznaloi-felulet/#2-feladat-menuk-horgonyzas-dokkolas","text":"","title":"2. Feladat - Men\u00fck, Horgonyz\u00e1s, Dokkol\u00e1s"},{"location":"labor/3-felhasznaloi-felulet/#menuk","text":"A fel\u00fclettervez\u00e9s k\u00f6vetkez\u0151 feladata a men\u00fck megszerkeszt\u00e9se. Ehhez v\u00e9gezz\u00fck el a k\u00f6vetkez\u0151 l\u00e9p\u00e9ssorozatot. A Toolboxr\u00f3l h\u00fazzunk r\u00e1 a Form -ra egy MenuStrip -et ( Menus & Toolbars kateg\u00f3ri\u00e1ban van). A MenuStrip smart tag-j\u00e9t kinyitva (kicsi ny\u00edl a jobb fels\u0151 sark\u00e1ban) kattintsunk az Insert Standard Items -re. Ism\u00e9telj\u00fck az els\u0151 k\u00e9t l\u00e9p\u00e9st a ToolStrip vez\u00e9rl\u0151vel is. Majd helyezz\u00fcnk fel alulra egy StatusStrip vez\u00e9rl\u0151t is. Tesztelj\u00fck az alkalmaz\u00e1st, vegy\u00fck \u00e9szre, hogy a ToolStrip -nek van kis foganty\u00faja, azonban azt hi\u00e1ba fogjuk meg, nem mozog. Ekkor j\u00f6n seg\u00edts\u00e9g\u00fcnkre a ToolStripContainer . A ToolStripContainer egy olyan kont\u00e9ner vez\u00e9rl\u0151, mely \u00f6t panelt tartalmaz: egy Top, Bottom, Left, Right \u00e9s egy k\u00f6z\u00e9pen elhelyezked\u0151 Content panelt. A men\u00fc smart tag-\u00e9ben v\u00e1lasszuk ki az Embed In ToolStripContainer parancsot, amely feltesz egy ToolStripContainer -t, \u00e9s a men\u00fct \u00e1thelyezi ennek fels\u0151 panelj\u00e9be. Az \u0171rlapunk megjelen\u00e9se kaotikuss\u00e1 v\u00e1lik, mivel a t\u00f6bbi strip egyel\u0151re nem ker\u00fclt a ToolStripContainer -be. A ToolStripContainer smart tag-j\u00e9n v\u00e1lasszuk a Dock Fill in Form funkci\u00f3t. Akkor l\u00e1tsz\u00f3lag minden a hely\u00e9re ker\u00fcl, lesz\u00e1m\u00edtva, hogy a men\u00fc \u00e9s a toolbar fel vannak cser\u00e9lve. Kiv\u00e1laszt\u00e1s a designerben A ToolStripContainer kijel\u00f6l\u00e9se kicsit tr\u00fckk\u00f6s a takar\u00e1si viszonyok miatt. Ehhez haszn\u00e1ljuk a Document Outline ablakot, vagy haszn\u00e1ljuk a context men\u00fc Select men\u00fcpontj\u00e1t. Rendezz\u00fck a kont\u00e9ner-vez\u00e9rl\u0151 hierarchi\u00e1t! Nyissuk meg a Document Outline ablakot ( View / Other Windows / Document Outline ) \u00e9s korrig\u00e1ljuk a hierarchi\u00e1t: H\u00fazzuk \u00e1t a ToolStrip -et \u00e9s a StatusStrip -et a ToolStripContainer fels\u0151, illetve als\u00f3 panelj\u00e9be, tov\u00e1bb\u00e1 a TextBox \u00e9s Button vez\u00e9rl\u0151ket ContentPanel -re. A v\u00e9geredm\u00e9ny \u00edgy n\u00e9z ki: A MenuStrip smart tag-j\u00e9ben \u00e1ll\u00edtsuk \u00e1t a Grip Style -t Visible -re, ekkor m\u00e1r a men\u00fc is mozgathat\u00f3. Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, a ToolStrip \u00e9s a MenuStrip mozgathat\u00f3 lett (oldalra \u00e9s alulra is). P\u00e9ldak\u00e9nt adjunk esem\u00e9nykezel\u0151t a File/Exit men\u00fcelemhez: dupl\u00e1n klikkelj\u00fcnk a men\u00fcelemen, majd a k\u00f3dban adjuk ki a Close() parancsot, mely bez\u00e1rja az ablakot \u00e9s ezzel le\u00e1ll\u00edtja az alkalmaz\u00e1st. private void exitToolStripMenuItem_Click ( object sender , EventArgs e ) { Close (); } Futtassuk \u00e9s tesztelj\u00fck az alkalmaz\u00e1st.","title":"Men\u00fck"},{"location":"labor/3-felhasznaloi-felulet/#horgonyzas-anchor","text":"Horgonyz\u00e1s, dokkol\u00e1s dem\u00f3k A horgonyz\u00e1shoz \u00e9s dokkol\u00e1shoz GitHub-on a t\u00e1rgy alatt tal\u00e1lhat\u00f3 szeml\u00e9letes dem\u00f3. Forr\u00e1sk\u00f3d a k\u00f6vetkez\u0151 utas\u00edt\u00e1ssal parancssorb\u00f3l egyszer\u0171en let\u00f6lthet\u0151: git clone https://github.com/bmeviauab00/AnchorAndDockDemo Futtathat\u00f3 verzi\u00f3 a download gombbal t\u00f6lthet\u0151 le. Anchor : A horgonyz\u00e1s seg\u00edts\u00e9g\u00e9vel el\u00e9rhet\u0151, hogy a vez\u00e9rl\u0151 adott oldala \u00e1lland\u00f3 t\u00e1vols\u00e1got tartson a sz\u00fcl\u0151 kont\u00e9ner ugyanazon oldal\u00e1t\u00f3l. Egy vez\u00e9rl\u0151re egym\u00e1st\u00f3l f\u00fcggetlen\u00fcl be\u00e1ll\u00edthat\u00f3 a fel\u00fclre, alulra, balra \u00e9s jobbra horgonyz\u00e1s. Ha pl. a jobbra horgonyz\u00e1s be van \u00e1ll\u00edtva egy vez\u00e9rl\u0151re, akkor a jobb oldala fix t\u00e1vols\u00e1got tart a kont\u00e9ner\u00e9nek jobb oldal\u00e1t\u00f3l. Ez a kont\u00e9ner \u00e1tm\u00e9retez\u00e9sekor v\u00e1lik l\u00e1that\u00f3v\u00e1: amikor a kont\u00e9ner jobb oldala fut\u00e1s k\u00f6zben az \u00e1tm\u00e9retez\u00e9s sor\u00e1n elmozdul, akkor a tartalmazott vez\u00e9rl\u0151 jobb oldala ezt automatikusan lek\u00f6veti, a t\u00e1vols\u00e1g a kett\u0151 k\u00f6z\u00f6tt \u00e1lland\u00f3 marad. Ugyanez \u00e1ll fent a jobbra, fel\u00fclre \u00e9s alulra horgonyz\u00e1s eset\u00e9n is (\u00e9rtelemszer\u0171en a jobb, fels\u0151 \u00e9s als\u00f3 oldalakra vonatkoztatva). Alap\u00e9rtelmez\u00e9sben a vez\u00e9rl\u0151k bal oldala \u00e9s teteje van lehorgonyozva. Ha k\u00e9t ellent\u00e9tes oldal is le van horgonyozva (p\u00e9ld\u00e1ul a bal \u00e9s a jobb oldal), akkor a sz\u00fcl\u0151 v\u00edzszintes \u00e1tm\u00e9retez\u00e9sekor a vez\u00e9rl\u0151 n\u0151ni vagy zsugorodni fog, hogy a k\u00e9t sz\u00e9le megtartsa a t\u00e1vols\u00e1got a sz\u00fcl\u0151 sz\u00e9leit\u0151l. T\u00e9rj\u00fcnk vissza az alkalmaz\u00e1sunkhoz: H\u00fazzuk be az els\u0151 feladatban l\u00e9trehozott gombot a form k\u00f6zep\u00e9re (de egy \u00fajat is feldobhatunk). A Property Editor -ban keress\u00fck ki \u00e9s nyissuk le az Anchor tulajdons\u00e1got. A tulajdons\u00e1g \u00e9rt\u00e9ke val\u00f3j\u00e1ban egyszer\u0171 enum, melyhez a Visual Studio az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt egy grafikus n\u00e9zetet ad. Figyelj\u00fck meg, hogy jelenleg a vez\u00e9rl\u0151 bal oldala \u00e9s teteje van a sz\u00fcl\u0151j\u00e9hez k\u00f6tve. Az Anchor szerkeszt\u0151j\u00e9ben kattintsunk a jobb oldali horgonyra is. \u00cdgy m\u00e1r h\u00e1rom oldal\u00e1t r\u00f6gz\u00edtett\u00fck a gombnak. Tesztelj\u00fck a v\u00e1ltoztat\u00e1s hat\u00e1s\u00e1t! Mivel a horgonyok m\u00e1r tervez\u00e9si id\u0151ben is m\u0171k\u00f6dnek, ehhez az alkalmaz\u00e1st sem kell elind\u00edtani. El\u00e9g a tervez\u00e9si n\u00e9zetben \u00e1tm\u00e9retezni a formot. Figyelj\u00fck meg, hogy imm\u00e1r a gomb jobb oldala egy\u00fctt mozog a form jobb sz\u00e9l\u00e9vel! M\u00f3dos\u00edtsuk a horgonyt \u00fagy, hogy a jobb \u00e9s az als\u00f3 oldala legyen r\u00f6gz\u00edtve a gombnak, a teteje \u00e9s a bal oldala nem. Tesztelj\u00fck a megold\u00e1st! Ut\u00f3bbi megold\u00e1s haszn\u00e1lhat\u00f3 p\u00e9ld\u00e1ul arra, hogy egy dial\u00f3gusablak bez\u00e1r\u00f3 gombj\u00e1t mindig a jobb als\u00f3 sarokban tartsuk. A gombra a tov\u00e1bbiakban nem lesz sz\u00fcks\u00e9g\u00fcnk, t\u00f6r\u00f6lj\u00fck a fel\u00fcletr\u0151l.","title":"Horgonyz\u00e1s (anchor)"},{"location":"labor/3-felhasznaloi-felulet/#dokkolas-dock","text":"Dock : A dokkol\u00e1s (szok\u00e1s m\u00e9g csatol\u00e1snak vagy ragaszt\u00e1snak is nevezni) seg\u00edts\u00e9g\u00e9vel egy vez\u00e9rl\u0151 hozz\u00e1csatolhat\u00f3 az \u0151t tartalmaz\u00f3 kont\u00e9ner valamelyik sz\u00e9l\u00e9hez, vagy be\u00e1ll\u00edthat\u00f3, hogy t\u00f6ltse ki a rendelkez\u00e9sre \u00e1ll\u00f3 helyet. Lehets\u00e9ges \u00e9rt\u00e9kei: None , Top , Left , Right , Bottom \u00e9s Fill . Egy fel\u00fclre vagy alulra dokkolt vez\u00e9rl\u0151 a sz\u00fcl\u0151 \u00e1tm\u00e9retez\u00e9sekor megtartja a magass\u00e1g\u00e1t, a sz\u00e9less\u00e9gv\u00e1ltoz\u00e1st pedig lek\u00f6veti (pl. egy men\u00fc vagy st\u00e1tuszs\u00e1v tipikusan \u00edgy viselkedik). Ahhoz, hogy egy vez\u00e9rl\u0151 kit\u00f6ltse a teljes marad\u00f3 teret, a dokkol\u00e1st Fill -re kell \u00e1ll\u00edtani. Itt is \u00e9rdemes a GitHub dem\u00f3t futtatva, az \u0171rlapot \u00e1tm\u00e9retezve kipr\u00f3b\u00e1lni, \u00edme a k\u00e9p az \u0171rlap \u00e1tm\u00e9retez\u00e9se el\u0151tt \u00e9s ut\u00e1n: \u00c1tm\u00e9retez\u00e9s ut\u00e1n (sz\u00e9lesebbre \u00e9s alacsonyabbra m\u00e9retezve az ablakot):","title":"Dokkol\u00e1s (dock)"},{"location":"labor/3-felhasznaloi-felulet/#3-feladat-miniexplorer","text":"","title":"3. Feladat - MiniExplorer"},{"location":"labor/3-felhasznaloi-felulet/#miniexplorer-layout","text":"A feladat sor\u00e1n egy Windows Forms alap\u00fa f\u00e1jlrendszer b\u00f6ng\u00e9sz\u0151 (MiniExplorer) alkalmaz\u00e1st kell elk\u00e9sz\u00edteni. A program kin\u00e9zet\u00e9t a k\u00f6vetkez\u0151 \u00e1bra szeml\u00e9lteti. Az ablak h\u00e1rom r\u00e9szb\u0151l \u00e1lljon: c\u00edmsor az ablak tetej\u00e9n ( TextBox ) TreeView a c\u00edmsor alatt bal oldalon ListView a c\u00edmsor alatt jobb oldalon A c\u00edmsorban mindig az aktu\u00e1lisan kiv\u00e1lasztott mappa teljes el\u00e9r\u00e9si \u00fatvonal\u00e1t l\u00e1thatjuk. Kezdetben legyenek a csom\u00f3pontok \u00f6sszecsukott \u00e1llapotban (\u201e+\u201d ikon mellett\u00fck a f\u00e1ban), lenyitva \u0151ket jelenjenek meg a gyerek csom\u00f3pontok, ha van mappa az adott mapp\u00e1n bel\u00fcl. Elfogadhat\u00f3, hogy el\u0151sz\u00f6r minden csom\u00f3pont lenyithat\u00f3, \u00e9s csak akkor t\u0171nik el a lenyit\u00e1sra/\u00f6sszecsuk\u00e1sra szolg\u00e1l\u00f3 ikon, ha a felhaszn\u00e1l\u00f3 megpr\u00f3b\u00e1lta lenyitni \u00e9s nincs benne mappa. Ha a felhaszn\u00e1l\u00f3 kiv\u00e1laszt egy mapp\u00e1t a TreeView -ban (itt nem a lenyit/\u00f6sszecsuk m\u0171veletre kell gondolni), akkor a ListView -ban jelenjenek meg a mapp\u00e1ban tal\u00e1lhat\u00f3 f\u00e1jlok. A ListView h\u00e1rom oszlopban jelen\u00edtse meg a f\u00e1jlok nev\u00e9t, m\u00e9ret\u00e9t \u00e9s az utols\u00f3 m\u00f3dos\u00edt\u00e1s d\u00e1tum\u00e1t. V\u00e1lasszuk ki a formon l\u00e9v\u0151 TextBox -ot (melyet az els\u0151 p\u00e9ld\u00e1ban raktunk ki), \u00e9s \u00e1ll\u00edtsuk a Dock tulajdons\u00e1g\u00e1t Top -ra. Ezzel a c\u00edmsort az ablak tetej\u00e9hez igaz\u00edtottuk. Tegy\u00fcnk a formra egy SplitContainer -t (ToolBox / Containers). SplitContainer SplitContainer : Figyelj\u00fck meg, hogy ez egy speci\u00e1lis vez\u00e9rl\u0151, mely k\u00e9t egym\u00e1s mell\u00e9 rendezett panelb\u0151l \u00e1ll \u00e9s lehet\u0151s\u00e9get ad a panelok k\u00f6zti ar\u00e1ny v\u00e1ltoztat\u00e1s\u00e1ra. Ez egy olyan kont\u00e9ner t\u00edpus\u00fa vez\u00e9rl\u0151, mely az \u0151t tartalmaz\u00f3 kont\u00e9nert k\u00e9t panelre osztja f\u00fcgg\u0151leges vagy v\u00edzszintes ir\u00e1nyban. A k\u00e9t panel k\u00f6z\u00e9 egy splittert helyez el, mellyel ak\u00e1r fut\u00e1sid\u0151ben is \u00e1tm\u00e9retezhet\u0151 a k\u00e9t panel. A splitter mozgat\u00e1sa letilthat\u00f3, \u00e9s a k\u00e9t panel k\u00f6z\u00fcl az egyikre be\u00e1ll\u00edthat\u00f3, hogy a sz\u00fcl\u0151 kont\u00e9ner m\u00e9retez\u00e9sekor a megadott panel m\u00e9rete ne v\u00e1ltozzon. (Fixed nev\u0171 tulajdons\u00e1gokn\u00e1l \u00e9rdemes keresni.) A SplitContainer elvileg m\u00e1r Fill Dock m\u00f3don ker\u00fclt fel az el\u0151z\u0151 l\u00e9p\u00e9sben (kit\u00f6lti a teret). Ha m\u00e9gsem \u00edgy lenne: v\u00e1lasszuk ki a Dock in parent container opci\u00f3t a SplitPanel smart tag-j\u00e9ben! A bal oldali panel-re rakjunk r\u00e1 egy TreeView vez\u00e9rl\u0151t. A smart tag-j\u00e9ben v\u00e1lasszuk a Dock in parent container funkci\u00f3t. A jobb oldali panelre rakjunk egy ListView vez\u00e9rl\u0151t. A smart tag-j\u00e9ben v\u00e1lasszuk itt is a Dock in parent container funkci\u00f3t. Ezzel el is k\u00e9sz\u00fclt a MiniExplorer, legal\u00e1bbis a fel\u00fclete.","title":"MiniExplorer layout"},{"location":"labor/3-felhasznaloi-felulet/#miniexplorer-logika","text":"Mivel k\u00e9szen van a fel\u00fclet, a k\u00f6vetkez\u0151 feladat azt kit\u00f6lteni. Dupl\u00e1n klikkelj\u00fcnk a form fejl\u00e9c\u00e9n, ezzel tudjuk implement\u00e1lni a Form.Load esem\u00e9ny\u00e9t. Itt fogjuk inicializ\u00e1lni a f\u00e1t: private void MainForm_Load ( object sender , EventArgs e ) { var root = treeView1 . Nodes . Add ( \"Local Disk (C:)\" ); root . Tag = new DirectoryInfo ( @\"C:\\\" ); root . Nodes . Add ( \"\" ); } A TreeView vez\u00e9rl\u0151 TreeNode objektumokat tud megjelen\u00edteni (ezek a fa csom\u00f3pontjait jelk\u00e9pezik). A t\u00e9nyleges inform\u00e1ci\u00f3t (vagyis, hogy melyik k\u00f6nyvt\u00e1r tartozik hozz\u00e1) a TreeNode Tag tulajdons\u00e1gban t\u00e1roljuk el. Ez egy object t\u00edpus\u00fa tulajdons\u00e1g, amivel a legt\u00f6bb vez\u00e9rl\u0151 rendelkezik, \u00e9s pont azt a c\u00e9lt szolg\u00e1lja, hogy a fejleszt\u0151k tetsz\u0151leges, sz\u00e1mukra relev\u00e1ns \u00e9s az adott vez\u00e9rl\u0151h\u00f6z k\u00f6t\u0151d\u0151 inform\u00e1ci\u00f3t t\u00e1roljanak benne. A megold\u00e1sunkban a csom\u00f3ponthoz tartoz\u00f3 k\u00f6nyvt\u00e1r inform\u00e1ci\u00f3t t\u00e1roljuk el benne egy DirectoryInfo objektum form\u00e1j\u00e1ban. R\u00f6videsen megl\u00e1tjuk, mi\u00e9rt van erre sz\u00fcks\u00e9g. A f\u00fcggv\u00e9ny utols\u00f3 sor\u00e1ban l\u00e9trehozunk egy \u201e\u00fcres\u201d gyerek csom\u00f3pontot. Ennek k\u00f6sz\u00f6nhet\u0151en a sz\u00fcl\u0151 mellett meg fog jelenni a kibont\u00e1s jele (+). A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a csom\u00f3pontok kibont\u00e1s\u00e1t val\u00f3s\u00edtjuk meg: amikor a felhaszn\u00e1l\u00f3 kibont (expand) egy csom\u00f3pontot, le kell k\u00e9rdezz\u00fck a csom\u00f3pont \u00e1ltal reprezent\u00e1lt k\u00f6nyvt\u00e1rban tal\u00e1lhat\u00f3 alk\u00f6nyvt\u00e1rakat, \u00e9s a lenyitott TreeNode csom\u00f3ponthoz tartoz\u00f3 k\u00f6nyvt\u00e1r minden alk\u00f6nyvt\u00e1rhoz egy gyerek TreeNode csom\u00f3pontot kell felvegy\u00fcnk. Egy csom\u00f3pont kibont\u00e1s\u00e1r\u00f3l a TreeView vez\u00e9rl\u0151 a BeforeExpand \u00e9s AfterExpand esem\u00e9nyekben \u00e9rtes\u00edt. Sz\u00e1munkra most a BeforeExpand a megfelel\u0151 v\u00e1laszt\u00e1s. Azt, hogy melyik csom\u00f3pont ker\u00fclt kibont\u00e1sra, az esem\u00e9nykezel\u0151 param\u00e9ter\u00e9ben kapjuk meg. Azt pedig, hogy melyik k\u00f6nyvt\u00e1r tartozik egy csom\u00f3ponthoz, a TreeNode Tag tulajdons\u00e1g\u00e1ban mi magunk t\u00e1roljuk el! Menj\u00fcnk vissza a designer-be, v\u00e1lasszuk ki a TreeView -t, majd a Properties ablakban v\u00e1ltsunk esem\u00e9ny n\u00e9zetre (vill\u00e1m ikon). Dupl\u00e1n klikkelj\u00fcnk a BeforeExpand esem\u00e9nyen, hogy implement\u00e1lhassuk: private void treeView1_BeforeExpand ( object sender , TreeViewCancelEventArgs e ) { var parentDI = e . Node ?. Tag as DirectoryInfo ; if ( parentDI == null ) return ; e . Node ?. Nodes . Clear (); try { foreach ( var di in parentDI . GetDirectories ()) { var node = new TreeNode ( di . Name ); node . Tag = di ; node . Nodes . Add ( \"\" ); e . Node ?. Nodes . Add ( node ); } } catch { // lenyelj\u00fck a hib\u00e1t, \u00edgy \u00fagy fog t\u0171nni, mintha \u00fcres lenne a mappa } } A ?. oper\u00e1tor A ?. , vagyis a null-conditional oper\u00e1tor m\u0171k\u00f6d\u00e9se hasonl\u00f3 a klasszikus . , vagyis taghozz\u00e1f\u00e9r\u00e9s oper\u00e1torhoz, de a taghozz\u00e1f\u00e9r\u00e9s csak akkor t\u00f6rt\u00e9nik meg, ha a kifejez\u00e9s bal oldala nem null (egy\u00e9bk\u00e9nt pedig a kifejez\u00e9s \u00e9rt\u00e9ke null lesz). Tulajdonk\u00e9ppen ezt haszn\u00e1ltuk kor\u00e1bban a C# esem\u00e9nyek felt\u00e9teles els\u00fct\u00e9sekor az <esem\u00e9ny>?.Invoke() sor\u00e1n is. Tesztelj\u00fck az alkalmaz\u00e1st. K\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t a jobboldali panel megval\u00f3s\u00edt\u00e1s\u00e1ra. Itt akkor kell a tartalmat friss\u00edteni, amikor (pontosabban miut\u00e1n) a baloldali TreeView -ban a felhaszn\u00e1l\u00f3 kiv\u00e1lasztott egy csom\u00f3pontot. Err\u0151l a TreeView az AfterSelect esem\u00e9ny\u00e9ben k\u00fcld \u00e9rtes\u00edt\u00e9st. A kor\u00e1bbihoz hasonl\u00f3an a kiv\u00e1lasztott TreeNode csom\u00f3pontot az esem\u00e9nykezel\u0151 param\u00e9ter\u00e9ben kapjuk meg. private void treeView1_AfterSelect ( object sender , TreeViewEventArgs e ) { var parentDI = e . Node ?. Tag as DirectoryInfo ; if ( parentDI == null ) return ; listView1 . Items . Clear (); try { foreach ( FileInfo fi in parentDI . GetFiles ()) { listView1 . Items . Add ( fi . Name ); } } catch { // lenyelj\u00fck a hib\u00e1t, \u00edgy \u00fagy fog t\u0171nni, mintha \u00fcres lenne a mappa } } Hibakezel\u00e9s Vegy\u00fck \u00e9szre, hogy a fenti k\u00e9t f\u00fcggv\u00e9nyben mindk\u00e9t esetben egy try-catch blokkot haszn\u00e1ltunk. Ez az\u00e9rt van, mert a laborg\u00e9peken \u00e1tlagos felhaszn\u00e1l\u00f3k\u00e9nt sokszor nincs jogunk egyes mapp\u00e1k/f\u00e1jlok el\u00e9r\u00e9s\u00e9re, ami a list\u00e1z\u00f3 f\u00fcggv\u00e9nyek eset\u00e9ben kiv\u00e9telt v\u00e1lt ki. Egy val\u00f3s alkalmaz\u00e1sban semmik\u00e9ppen nem hagyn\u00e1nk \u00fcresen a catch blokkot, mindenk\u00e9ppen napl\u00f3zn\u00e1nk, vagy a felhaszn\u00e1l\u00f3 tudom\u00e1s\u00e1ra hozn\u00e1nk a hib\u00e1t. A legegyszer\u0171bb MessageBox alap\u00fa megold\u00e1s ez lenne: catch ( UnatuhorizedAccessExceotion ex ) { MessageBox . Show ( ex . Message , \"Error\" , MessageBoxButtons . OK , MessageBoxIcon . Error )) } Ugyanitt ki tudjuk t\u00f6lteni az Address r\u00e9szt is: tbDemoText . Text = parentDI . FullName ; K\u00f6vetkez\u0151 l\u00e9p\u00e9sben val\u00f3s\u00edtsuk meg a t\u00f6bboszlopos n\u00e9zetet a jobboldali panelen. A k\u00f3dot m\u00f3dos\u00edtsuk \u00fagy, hogy ne csak a nev\u00e9t adja meg a f\u00e1jlnak, hanem egy\u00e9b param\u00e9tereit is. Az Add f\u00fcggv\u00e9nyt param\u00e9terezz\u00fck \u00edgy: listView1 . Items . Add ( new ListViewItem ( new string [] { fi . Name , fi . Length . ToString (), fi . LastWriteTime . ToString (), fi . FullName })); Az adatok teh\u00e1t m\u00e1r megvannak, de m\u00e9g nem jelennek meg. Ehhez a ListView -t m\u00f3dos\u00edtani kell a designer-ben, hogy mutassa a r\u00e9szleteket is. Hozzuk el\u0151 a smart tag-j\u00e9t, \u00e9s \u00e1ll\u00edtsuk \u00e1t rajta a View -t Details -re. Az oszlopokat nek\u00fcnk kell l\u00e9trehoznunk, amihez a smart tag-j\u00e9ben v\u00e1lasszuk az Edit Columns funkci\u00f3t, majd a megjelen\u0151 list\u00e1t t\u00f6lts\u00fck fel 3 \u00faj elemmel, amelyeknek a Text tulajdons\u00e1ga legyen: Name , Size , Modified . Rendezz\u00fck el sz\u00e9pen az oszlopok sz\u00e9less\u00e9g\u00e9t olyan m\u00f3don, hogy minden kif\u00e9rjen majd a felt\u00f6lt\u00e9s ut\u00e1n is. Ezekben az oszlopokban az adatok pont olyan sorrendben fognak megjelenni, mint ahogy a 6. pontban a listaelemhez hozz\u00e1rendelt\u00fck azokat. ListView oszlopok Sajnos a ListView be\u00e9p\u00edtetten el\u00e9g t\u00f6r\u00e9keny megold\u00e1st ny\u00fajt csak az oszlopok \u00e9s azok \u00e9rt\u00e9keinek \u00f6sszerendel\u00e9s\u00e9re. A modernebb UI keretrendszerek (pl.: WPF, WinUI, .NET MAUI) az adatk\u00f6t\u00e9s mechanizmus\u00e1n kereszt\u00fcl egy k\u00e9nyelmesebb, deklarat\u00edvabb \u00e9s robusztusabb megold\u00e1st ny\u00fajtanak erre.","title":"MiniExplorer logika"},{"location":"labor/3-felhasznaloi-felulet/#futtatas","text":"Utols\u00f3 \u00e9rdekess\u00e9gk\u00e9nt megoldhatjuk, hogy a jobb oldali n\u00e9zetben egy f\u00e1jlon dupl\u00e1n kattintva a rendszer megnyissa/v\u00e9grehajtsa azt. Ehhez iratkozzunk fel a ListView DoubleClick esem\u00e9ny\u00e9re \u00e9s val\u00f3s\u00edtsuk meg a k\u00f6vetkez\u0151k\u00e9ppen: private void listView1_DoubleClick ( object sender , EventArgs e ) { if ( listView1 . SelectedItems . Count != 1 ) return ; var fullName = listView1 . SelectedItems [ 0 ]. SubItems [ 3 ]. Text ; if ( fullName != null ) { Process . Start ( new ProcessStartInfo ( fullName ) { UseShellExecute = true }); } }","title":"Futtat\u00e1s"},{"location":"labor/3-felhasznaloi-felulet/#windows-stilusok-nem-tanagyag","text":"Ha zavar minket, hogy nem a rendszer st\u00edlus\u00e1t haszn\u00e1lj\u00e1k a TreeView \u00e9s a ListView vez\u00e9rl\u0151k, akkor a SetWindowTheme Win32 API f\u00fcggv\u00e9nyt megh\u00edvva ki tudjuk k\u00e9nyszer\u00edteni, hogy a File Explorer/F\u00e1jlkezel\u0151 alkalmaz\u00e1sban megszokott st\u00edlusban jelenjenek meg. [DllImport(\"uxtheme.dll\", ExactSpelling = true, CharSet = CharSet.Unicode)] private static extern int SetWindowTheme ( IntPtr hwnd , string pszSubAppName , string? pszSubIdList ); private void MainForm_Load ( object sender , EventArgs e ) { var root = treeView1 . Nodes . Add ( \"Local Disk (C:)\" ); root . Tag = new DirectoryInfo ( @\"C:\\\" ); root . Nodes . Add ( \"\" ); SetWindowTheme ( treeView1 . Handle , \"explorer\" , null ); SetWindowTheme ( listView1 . Handle , \"explorer\" , null ); // Elt\u00fcnteti a csom\u00f3pontokat \u00f6sszek\u00f6t\u0151 vonalakat treeView1 . ShowLines = false ; } A megold\u00e1sunkban a .NET platform \u00fan. P/Invoke (Platform Invoke) mechanizmus\u00e1t vetj\u00fck be. Ez lehet\u0151v\u00e9 teszi, hogy a DllImport attrib\u00fatummal nat\u00edv DLL-ekb\u0151l f\u00fcggv\u00e9nyeket hivatkozzunk be, megfelel\u0151 param\u00e9terez\u00e9s\u0171 statikus C# f\u00fcggv\u00e9nydeklar\u00e1ci\u00f3khoz rendelj\u00fck, majd ezek seg\u00edts\u00e9g\u00e9vel a nat\u00edv f\u00fcggv\u00e9nyeket megh\u00edvjuk. A SetWindowTheme f\u00fcggv\u00e9ny els\u0151 param\u00e9terek\u00e9nt a vez\u00e9rl\u0151 Handle -j\u00e9t kell \u00e1tadni, m\u00e1sodik param\u00e9terek\u00e9nt pedig a process nev\u00e9t, amelyr\u0151l m\u00e1solni akarjuk a st\u00edlusokat. A fenti k\u00f3d utols\u00f3 sor\u00e1ban a treeView1.ShowLines false -ra \u00e1ll\u00edt\u00e1s\u00e1val kikapcsoljuk a fastrukt\u00far\u00e1ban az \u00f6sszek\u00f6t\u0151 vonalak alkalmaz\u00e1s\u00e1t. \u00cdme a v\u00e9geredm\u00e9ny:","title":"Windows st\u00edlusok (nem tanagyag)"},{"location":"labor/4-tobbszalu/","text":"4. T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se \u00b6 A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja, hogy megismertesse a hallgat\u00f3kat a t\u00f6bbsz\u00e1las programoz\u00e1s sor\u00e1n k\u00f6vetend\u0151 alapelvekkel. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt): Sz\u00e1lak ind\u00edt\u00e1sa ( Thread ) Sz\u00e1lak le\u00e1ll\u00edt\u00e1sa Sz\u00e1lbiztos (thread safe) oszt\u00e1lyok k\u00e9sz\u00edt\u00e9se a lock kulcssz\u00f3 alkalmaz\u00e1s\u00e1val ThreadPool haszn\u00e1lata Jelz\u00e9s \u00e9s jelz\u00e9sre v\u00e1rakoz\u00e1s sz\u00e1l szinkroniz\u00e1ci\u00f3 ManualResetEvent seg\u00edts\u00e9g\u00e9vel ( WaitHandle ) Windows Forms sz\u00e1lkezel\u00e9si saj\u00e1toss\u00e1gok ( Invoke ) Term\u00e9szetesen, mivel a t\u00e9mak\u00f6r hatalmas, csak alapszint\u0171 tud\u00e1st fogunk szerezni, de e tud\u00e1s birtok\u00e1ban m\u00e1r k\u00e9pesek lesz\u00fcnk \u00f6n\u00e1ll\u00f3an is elindulni a bonyolultabb feladatok megval\u00f3s\u00edt\u00e1s\u00e1ban. A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Konkurens (t\u00f6bbsz\u00e1l\u00fa) alkalmaz\u00e1sok fejleszt\u00e9se. El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) Bevezet\u0151 \u00b6 A p\u00e1rhuzamosan fut\u00f3 sz\u00e1lak kezel\u00e9se kiemelt fontoss\u00e1g\u00fa ter\u00fclet, melyet miden szoftverfejleszt\u0151nek legal\u00e1bb alapszinten ismernie kell. A gyakorlat sor\u00e1n alapszint\u0171, de kiemelt fontoss\u00e1g\u00fa probl\u00e9m\u00e1kat oldunk meg, ez\u00e9rt t\u00f6rekedn\u00fcnk kell arra, hogy ne csak a v\u00e9geredm\u00e9nyt, hanem az elv\u00e9gzett m\u00f3dos\u00edt\u00e1sok \u00e9rtelm\u00e9t \u00e9s indokait is meg\u00e9rts\u00fck. A feladat sor\u00e1n egyszer\u0171 Windows Forms alkalmaz\u00e1st fogunk felruh\u00e1zni t\u00f6bbsz\u00e1las k\u00e9pess\u00e9gekkel, egyre komplexebb feladatokat megoldva. Az alapprobl\u00e9ma a k\u00f6vetkez\u0151: van egy f\u00fcggv\u00e9ny\u00fcnk, mely hossz\u00fa ideig fut, s mint l\u00e1tni fogjuk, ennek \u201edirektben\u201d t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sa a fel\u00fcletr\u0151l kellemetlen k\u00f6vetkezm\u00e9nyekkel j\u00e1r. A megold\u00e1s sor\u00e1n egy megl\u00e9v\u0151 alkalmaz\u00e1st fogunk kieg\u00e9sz\u00edteni saj\u00e1t k\u00f3dr\u00e9szletekkel. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi. 0. Feladat - Ismerked\u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal, el\u0151k\u00e9sz\u00edt\u00e9s \u00b6 Kl\u00f3nozzuk le a 4. gyakorlathoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1st repositoryj\u00e1t . Nyissunk egy command prompt-ot Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN Adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo.git Nyissuk meg SuperCalculator.sln solutiont Visual Studio-ban. A feladatunk az, hogy egy bin\u00e1ris form\u00e1ban megkapott algoritmus futtat\u00e1s\u00e1hoz Windows Forms technol\u00f3gi\u00e1val felhaszn\u00e1l\u00f3i fel\u00fcletet k\u00e9sz\u00edts\u00fcnk. A bin\u00e1ris forma .NET eset\u00e9ben egy .dll kiterjeszt\u00e9s\u0171 f\u00e1jlt jelent, ami programoz\u00f3i szemmel egy oszt\u00e1lyk\u00f6nyvt\u00e1r. A f\u00e1jl neve eset\u00fcnkben Algorithms.dll , megtal\u00e1lhat\u00f3 a lekl\u00f3nozott Git repositoryban. A kiindul\u00f3 alkalmaz\u00e1sban a felhaszn\u00e1l\u00f3i fel\u00fclet el\u0151 is van k\u00e9sz\u00edtve. Futtassuk az alkalmaz\u00e1st: Az alkalmaz\u00e1s fel\u00fclet\u00e9n meg tudjuk adni az algoritmus bemen\u0151 param\u00e9tereit ( double sz\u00e1mok t\u00f6mbje): a p\u00e9ld\u00e1nkban mindig k\u00e9t double sz\u00e1m param\u00e9terrel h\u00edvjuk az algoritmust, ezt a k\u00e9t fels\u0151 sz\u00f6vegmez\u0151ben lehet megadni. A feladatunk az, hogy a Calculate Result gombra kattint\u00e1s sor\u00e1n futtassuk az algoritmust a megadott param\u00e9terekkel, majd, ha v\u00e9gzett, akkor a Result alatti list\u00e1z\u00f3 mez\u0151 \u00faj sor\u00e1ban jelen\u00edts\u00fck meg a kapott eredm\u00e9nyt a bemen\u0151 param\u00e9terekkel egy\u00fctt. K\u00f6vetkez\u0151 l\u00e9p\u00e9sben ismerkedj\u00fcnk meg a let\u00f6lt\u00f6tt Visual Studio solutionnel: N\u00e9zz\u00fck v\u00e9gig a MainForm oszt\u00e1lyt. Az l\u00e1tjuk, hogy a fel\u00fclet alapvet\u0151en k\u00e9sz, csak az algoritmus futtat\u00e1sa hi\u00e1nyzik. Az eredm\u00e9ny \u00e9s a param\u00e9terei napl\u00f3z\u00e1s\u00e1hoz is tal\u00e1lunk egy ShowResult nev\u0171 seg\u00e9df\u00fcggv\u00e9nyt. A DataFifo oszt\u00e1lyt egyel\u0151re hagyjuk ki, csak a gyakorlat m\u00e1sodik fel\u00e9ben fogjuk haszn\u00e1lni, majd k\u00e9s\u0151bb megismerked\u00fcnk vele. A DLL-ben lev\u0151 k\u00f3d felhaszn\u00e1l\u00e1sa \u00b6 A kiindul\u00f3 projektben megtal\u00e1ljuk a Algorithm.dll -t. Ebben leford\u00edtott form\u00e1ban egy Algorithms n\u00e9vt\u00e9rben lev\u0151 SuperAlgorithm nev\u0171 oszt\u00e1ly tal\u00e1lhat\u00f3, melynek egy Calculate nev\u0171 statikus m\u0171velete van. Ahhoz, hogy egy projektben fel tudjuk haszn\u00e1lni a DLL-ben lev\u0151 oszt\u00e1lyokat, a DLL-re a projekt\u00fcnkben egy \u00fan. referenci\u00e1t kell felvegy\u00fcnk. Solution Explorerben a projekt\u00fcnk Dependencies node-j\u00e1ra jobbklikkelve v\u00e1lasszuk az Add Project reference opci\u00f3t! K\u00fcls\u0151 referenci\u00e1k Itt val\u00f3j\u00e1ban nem egy m\u00e1sik Visual Studio projektre adunk referenci\u00e1t, de \u00edgy a legegyszer\u0171bb el\u0151hozni ezt az ablakot. Megeml\u00edtend\u0151 m\u00e9g, hogy k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1rak eset\u00e9ben m\u00e1r nem DLL-eket szoktunk refer\u00e1lni egy rendes projektben, hanem a .NET csomagkezel\u0151 rendeszer\u00e9b\u0151l a NuGet-r\u0151l szok\u00e1s a k\u00fcls\u0151 csomagokat beszerezni. Most az Algorithm.dll eset\u00fcnkben nincs NuGet-en publik\u00e1lva, ez\u00e9rt kell k\u00e9zzel felvegy\u00fck azt. Az el\u0151ugr\u00f3 ablak jobb als\u00f3 sarokban tal\u00e1lhat\u00f3 Browse gomb seg\u00edts\u00e9g\u00e9vel keress\u00fck meg \u00e9s v\u00e1lasszuk ki projekt External almapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 Algorithms.dll f\u00e1jlt, majd hagyjuk j\u00f3v\u00e1 a hozz\u00e1ad\u00e1st az OK gombbal! A Solution Explorerben egy projekt alatti Dependencies csom\u00f3pontot lenyitva l\u00e1thatjuk a hivatkozott k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket. Itt most m\u00e1r megjelenik az Assemblyk k\u00f6z\u00f6tt el\u0151bb felvett Algorithms referencia is. A Frameworks kateg\u00f3ri\u00e1ban a .NET keretrendszer csomagjait tal\u00e1ljuk. Az Analyzerek pedig statikus k\u00f3delemz\u0151 eszk\u00f6z\u00f6k ford\u00edt\u00e1s id\u0151ben. Illetve itt lenn\u00e9nek m\u00e9g a projekt vagy a NuGet referenci\u00e1k is. Kattintsunk Algorithms referenci\u00e1n jobb gombbal \u00e9s v\u00e1lasszuk a View in Object Browser funkci\u00f3t. Ekkor megny\u00edlik az Object Browser tabf\u00fcl, ahol megtekinthetj\u00fck, hogy az adott DLL-ben milyen n\u00e9vterek, oszt\u00e1lyok tal\u00e1lhat\u00f3k, illetve ezeknek milyen tagjaik (tagv\u00e1ltoz\u00f3, tagf\u00fcggv\u00e9ny, property, event) vannak. Ezeket a Visual Studio a DLL metaadataib\u00f3l az \u00fan. reflection mechanizmus seg\u00edts\u00e9g\u00e9vel olvassa ki (ilyen k\u00f3dot ak\u00e1r mi is \u00edrhatunk). Az al\u00e1bbi \u00e1br\u00e1nak megfelel\u0151en az Object Browserben baloldalt keress\u00fck ki az Algorithms csom\u00f3pontot, nyissuk le, \u00e9s l\u00e1that\u00f3v\u00e1 v\u00e1lik, hogy egy Algorithms n\u00e9vt\u00e9r van benne, abban pedig egy SuperAlgorithm oszt\u00e1ly. Ezt kiv\u00e1lasztva k\u00f6z\u00e9pen megjelennek az oszt\u00e1ly f\u00fcggv\u00e9nyei, itt egy f\u00fcggv\u00e9nyt kiv\u00e1lasztva pedig az adott f\u00fcggv\u00e9ny pontos szignat\u00far\u00e1ja: 1. Feladat \u2013 M\u0171velet futtat\u00e1sa a f\u0151sz\u00e1lon \u00b6 Most m\u00e1r r\u00e1t\u00e9rhet\u00fcnk az algoritmus futtat\u00e1s\u00e1ra. Els\u0151 l\u00e9p\u00e9sben ezt az alkalmaz\u00e1sunk f\u0151 sz\u00e1l\u00e1n tessz\u00fck meg. A f\u0151ablakon l\u00e9v\u0151 gomb Click esem\u00e9nykezel\u0151j\u00e9ben h\u00edvjuk meg a sz\u00e1mol\u00f3 f\u00fcggv\u00e9ny\u00fcnket. Ehhez kattintsunk a Solution Explorerben dupl\u00e1n a MainForm.cs f\u00e1jlra, majd a megjelen\u0151 Form Designer-ben a Calculate Result gombra. Eg\u00e9sz\u00edts\u00fck ki a k\u00f3dot az \u00fajonnan behivatkozott algoritmus megh\u00edv\u00e1s\u00e1val. private void buttonCalcResult_Click ( object sender , EventArgs e ) { if ( double . TryParse ( textBoxParam1 . Text , out var p1 ) && double . TryParse ( textBoxParam2 . Text , out var p2 )) { var parameters = new double [] { p1 , p2 }; var result = Algorithms . SuperAlgorithm . Calculate ( parameters ); ShowResult ( parameters , result ); } else { MessageBox . Show ( this , \"Invalid parameter!\" , \"Error\" ); } } Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az ablak a sz\u00e1mol\u00e1s ideje alatt nem reag\u00e1l a mozgat\u00e1sra, \u00e1tm\u00e9retez\u00e9sre, a fel\u00fclet gyakorlatilag befagy. Az alkalmaz\u00e1sunk esem\u00e9nyvez\u00e9relt, mint minden Windows alkalmaz\u00e1s. Az oper\u00e1ci\u00f3s rendszer a k\u00fcl\u00f6nb\u00f6z\u0151 interakci\u00f3kr\u00f3l (pl. mozgat\u00e1s, \u00e1tm\u00e9retez\u00e9s) \u00fczenetekben \u00e9rtes\u00edti az alkalmaz\u00e1sunkat. Mivel a gombnyom\u00e1st k\u00f6vet\u0151en az alkalmaz\u00e1sunk egyetlen sz\u00e1la a kalkul\u00e1ci\u00f3val van elfoglalva, nem tudja azonnal feldolgozni a tov\u00e1bbi felhaszn\u00e1l\u00f3i utas\u00edt\u00e1sokat. Amint a sz\u00e1m\u00edt\u00e1s lefutott (\u00e9s az eredm\u00e9nyek megjelennek a list\u00e1ban) a kor\u00e1bban kapott parancsok is v\u00e9grehajt\u00e1sra ker\u00fclnek. 2. Feladat \u2013 V\u00e9gezz\u00fck a sz\u00e1m\u00edt\u00e1st k\u00fcl\u00f6n sz\u00e1lban \u00b6 K\u00f6vetkez\u0151 l\u00e9p\u00e9sben a sz\u00e1m\u00edt\u00e1s elv\u00e9gz\u00e9s\u00e9re egy k\u00fcl\u00f6n sz\u00e1lat fogunk ind\u00edtani, hogy az ne blokkolja a felhaszn\u00e1l\u00f3i fel\u00fcletet. K\u00e9sz\u00edts\u00fcnk egy \u00faj f\u00fcggv\u00e9nyt a MainForm oszt\u00e1lyban, mely a feldolgoz\u00f3 sz\u00e1l bel\u00e9p\u00e9si pontja lesz. private void CalculatorThread ( object arg ) { var parameters = ( double []) arg ; var result = Algorithms . SuperAlgorithm . Calculate ( parameters ); ShowResult ( parameters , result ); } Ind\u00edtsuk el a sz\u00e1lat a gomb Click esem\u00e9nykezel\u0151j\u00e9ben. Ehhez cser\u00e9lj\u00fck le a kor\u00e1bban hozz\u00e1adott k\u00f3dot: private void buttonCalcResult_Click ( object sender , EventArgs e ) { if ( double . TryParse ( textBoxParam1 . Text , out var p1 ) && double . TryParse ( textBoxParam2 . Text , out var p2 )) { var parameters = new double [] { p1 , p2 }; var th = new Thread ( CalculatorThread ); th . Start ( parameters ); } else { MessageBox . Show ( this , \"Invalid parameter!\" , \"Error\" ); } } A Thread objektum Start m\u0171velet\u00e9ben \u00e1tadott param\u00e9tert kapja meg a CalculatorThread sz\u00e1lf\u00fcggv\u00e9ny\u00fcnk. Futtassuk az alkalmaz\u00e1st F5-tel (most fontos, hogy \u00edgy, a debuggerben futtassuk)! InvalidOperationException, Cross-thread operation not valid hiba\u00fczenetet kapunk a ShowResult met\u00f3dusban, ugyanis nem abb\u00f3l a sz\u00e1lb\u00f3l pr\u00f3b\u00e1lunk hozz\u00e1f\u00e9rni a UI elemhez / vez\u00e9rl\u0151h\u00f6z, amelyik l\u00e9trehozta (a vez\u00e9rl\u0151t). A k\u00f6vetkez\u0151 feladatban ezt a probl\u00e9m\u00e1t analiz\u00e1ljuk \u00e9s oldjuk meg. 3. Feladat \u2013 az Invoke \u00e9s InvokeRequired haszn\u00e1lata \u00b6 Az el\u0151z\u0151 pontban a probl\u00e9m\u00e1t a k\u00f6vetkez\u0151 okozza. Windows Forms alkalmaz\u00e1sokn\u00e1l \u00e9l az al\u00e1bbi szab\u00e1ly: az \u0171rlapok/vez\u00e9rl\u0151elemek alapvet\u0151en nem sz\u00e1lv\u00e9dett objektumok, \u00edgy egy \u0171rlaphoz/vez\u00e9rl\u0151h\u00f6z csak abb\u00f3l a sz\u00e1lb\u00f3l szabad hozz\u00e1f\u00e9rni (pl. propertyj\u00e9t olvasni, \u00e1ll\u00edtani, m\u0171velet\u00e9t megh\u00edvni), amelyik sz\u00e1l az adott \u0171rlapot/vez\u00e9rl\u0151t l\u00e9trehozta , m\u00e1sk\u00fcl\u00f6nben kiv\u00e9telt kapunk. Alkalmaz\u00e1sunkban az\u00e9rt kaptunk kiv\u00e9telt, mert a listViewResult vez\u00e9rl\u0151t a f\u0151 sz\u00e1lban hoztuk l\u00e9tre, a ShowResult met\u00f3dusban az eredm\u00e9ny megjelen\u00edt\u00e9sekor viszont egy m\u00e1sik sz\u00e1lb\u00f3l f\u00e9r\u00fcnk hozz\u00e1 ( listViewResult.Items.Add ). A fenti szab\u00e1ly al\u00f3l van p\u00e1r kiv\u00e9tel: ilyen pl. a Control oszt\u00e1lyban defini\u00e1lt InvokeRequired property \u00e9s Invoke met\u00f3dus, melyek b\u00e1rmely sz\u00e1lb\u00f3l biztons\u00e1gosan el\u00e9rhet\u0151k. Ezek pont abban ny\u00fajtanak seg\u00edts\u00e9get, hogy a vez\u00e9rl\u0151kh\u00f6z mindig a megfelel\u0151 sz\u00e1lb\u00f3l f\u00e9rj\u00fcnk hozz\u00e1: Ha az InvokeRequired tulajdons\u00e1g \u00e9rt\u00e9ke igaz, akkor a sz\u00e1l (mely az InvokeRequired -et h\u00edvja) a h\u00edv\u00e1s hely\u00e9n nem egyezik a vez\u00e9rl\u0151t l\u00e9trehoz\u00f3 sz\u00e1llal, \u00e9s ilyenkor csak az Invoke m\u0171velet seg\u00edts\u00e9g\u00e9vel \"ker\u00fcl\u0151 \u00faton\" f\u00e9rhet\u00fcnk vez\u00e9rl\u0151nkh\u00f6z. Vagyis egy vez\u00e9rl\u0151h\u00f6z val\u00f3 hozz\u00e1f\u00e9r\u00e9s sor\u00e1n ezzel tudjuk eld\u00f6nteni, k\u00f6zvetlen\u00fcl hozz\u00e1f\u00e9rhet\u00fcnk-e egy adott helyen a sz\u00e1lunkb\u00f3l, vagy csak az Invoke seg\u00edts\u00e9g\u00e9vel. Az Invoke met\u00f3dus a vez\u00e9rl\u0151elemet l\u00e9trehoz\u00f3 sz\u00e1lon futtatja le a sz\u00e1m\u00e1ra param\u00e9terk\u00e9nt megadott met\u00f3dust (melyb\u0151l m\u00e1r k\u00f6zvetlen\u00fcl hozz\u00e1f\u00e9rhet\u00fcnk a vez\u00e9rl\u0151h\u00f6z). Az InvokeRequired \u00e9s az Invoke felhaszn\u00e1l\u00e1s\u00e1val el tudjuk ker\u00fclni kor\u00e1bbi kiv\u00e9tel\u00fcnket (a vez\u00e9rl\u0151h\u00f6z, eset\u00fcnkben a listViewResult-hoz val\u00f3 hozz\u00e1f\u00e9r\u00e9st a megfelel\u0151 sz\u00e1lra tudjuk \"ir\u00e1ny\u00edtani\"). Ezt fogjuk a k\u00f6vetkez\u0151kben megtenni. Csak debuggerben futtatva j\u00f6n az InvalidOperationException ? Ha kipr\u00f3b\u00e1ln\u00e1nk, hogy debugger n\u00e9lk\u00fcl ind\u00edtjuk el az alkalmaz\u00e1st (VS-ben Start without debugging vagy mag\u00e1t az exe-t), akkor azt tapasztaln\u00e1nk, hogy nem j\u00f6n a fenti kiv\u00e9tel. Ennek az az oka, hogy, fejleszt\u00e9s id\u0151ben, debuggerrel vizsg\u00e1lva az alkalmaz\u00e1st, sokkal szigor\u00fabban figyeli a keretrendszer a UI sz\u00e1l s\u00e9rt\u00e9st, hogy m\u00e1r fejleszt\u00e9s id\u0151ben el\u0151j\u00f6jjenek olyan potenci\u00e1lis hib\u00e1k, melyek am\u00fagy m\u00e9g nem jelenten\u00e9k az alkalmaz\u00e1s \u00f6sszeoml\u00e1s\u00e1t. A fenti esetben a ListView Invoke n\u00e9lk\u00fcli manipul\u00e1l\u00e1s\u00e1t j\u00f3 es\u00e9llyel az esetek t\u00f6bbs\u00e9g\u00e9ben m\u00e9g t\u00fal\u00e9ln\u00e9 az app, de a keretrendszer a debuggeren kereszt\u00fcl futtat\u00e1s sor\u00e1n jelzi a hib\u00e1s gyakorlatot. M\u00f3dos\u00edtanunk kell a ShowResult met\u00f3dust annak \u00e9rdek\u00e9ben, hogy mell\u00e9ksz\u00e1lb\u00f3l t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1s eset\u00e9n se dobjon kiv\u00e9telt. private void ShowResult ( double [] parameters , double result ) { if ( InvokeRequired ) { Invoke ( ShowResult , new object [] { parameters , result }); } else if (! IsDisposed ) { var lvi = listViewResult . Items . Add ( $\"{parameters[0]} # {parameters[1]} = {result}\" ); listViewResult . EnsureVisible ( lvi . Index ); listViewResult . AutoResizeColumns ( ColumnHeaderAutoResizeStyle . ColumnContent ); } } Pr\u00f3b\u00e1ljuk ki! Ez a megold\u00e1s m\u00e1r m\u0171k\u00f6d\u0151k\u00e9pes. A Form oszt\u00e1ly InvokeRequired met\u00f3dusa igazat ad vissza, amennyiben nem az \u0151t l\u00e9trehoz\u00f3 sz\u00e1lb\u00f3l h\u00edvjuk meg. Ilyen esetekben a Form ot az Invoke met\u00f3dus\u00e1n kereszt\u00fcl tudjuk megk\u00e9rni, hogy egy adott m\u0171veletet a saj\u00e1t sz\u00e1l\u00e1n (amelyik a Form ot l\u00e9trehozta, ez a legt\u00f6bb alkalmaz\u00e1sban a f\u0151 sz\u00e1l) hajtson v\u00e9gre. A fenti p\u00e9ld\u00e1ban tulajdonk\u00e9ppen a ShowResult f\u00fcggv\u00e9ny \u00f6nmag\u00e1t h\u00edvja meg m\u00e9g egyszer, csak m\u00e1sodik esetben m\u00e1r a Form saj\u00e1t sz\u00e1l\u00e1n. Ez egy bevett minta a redund\u00e1ns k\u00f3dok elker\u00fcl\u00e9s\u00e9re. Tegy\u00fcnk t\u00f6r\u00e9spontot a ShowResult m\u0171velet els\u0151 sor\u00e1ra, \u00e9s az alkalmaz\u00e1st futtatva gy\u0151z\u0151dj\u00fcnk meg, hogy a ShowResult m\u0171velet \u2013 k\u00fcl\u00f6n\u00f6sen az Invoke tekintet\u00e9ben \u2013 a fentiekben ismertetetteknek megfelel\u0151en m\u0171k\u00f6dik. Vegy\u00fck ki a t\u00f6r\u00e9spontot, \u00edgy futtassuk az alkalmaz\u00e1st: vegy\u00fck \u00e9szre, hogy am\u00edg egy sz\u00e1m\u00edt\u00e1s fut, \u00fajabbakat is ind\u00edthatunk, hiszen a fel\u00fclet\u00fcnk v\u00e9gig reszponz\u00edv maradt. 4. feladat \u2013 M\u0171velet v\u00e9gz\u00e9se Threadpool sz\u00e1lon \u00b6 Az el\u0151z\u0151 megold\u00e1s egy jellemz\u0151je, hogy mindig \u00faj sz\u00e1lat hoz l\u00e9tre a m\u0171velethez. Eset\u00fcnkben ennek nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge, de ez a megk\u00f6zel\u00edt\u00e9s egy olyan kiszolg\u00e1l\u00f3 alkalmaz\u00e1s eset\u00e9ben, amely nagysz\u00e1m\u00fa k\u00e9r\u00e9st szolg\u00e1l ki \u00fagy, hogy minden k\u00e9r\u00e9shez k\u00fcl\u00f6n sz\u00e1lat ind\u00edt, m\u00e1r probl\u00e9m\u00e1s lehet. K\u00e9t okb\u00f3l is: Ha a sz\u00e1lf\u00fcggv\u00e9ny gyorsan lefut (egy kliens kiszolg\u00e1l\u00e1sa gyors), akkor a CPU nagy r\u00e9sz\u00e9t arra pazaroljuk, hogy sz\u00e1lakat ind\u00edtsunk \u00e9s \u00e1ll\u00edtsunk le, ezek ugyanis \u00f6nmagukban is er\u0151forr\u00e1sig\u00e9nyesek. T\u00fal nagy sz\u00e1m\u00fa sz\u00e1l is l\u00e9trej\u00f6het, ennyit kell \u00fctemeznie az oper\u00e1ci\u00f3s rendszernek, ami feleslegesen pazarolja az er\u0151forr\u00e1sokat. Egy m\u00e1sik probl\u00e9ma jelen megold\u00e1sunkkal: mivel a sz\u00e1m\u00edt\u00e1s \u00fan. el\u0151t\u00e9rsz\u00e1lon fut (az \u00fajonnan l\u00e9trehozott sz\u00e1lak alap\u00e9rtelmez\u00e9sben el\u0151t\u00e9rsz\u00e1lak), hi\u00e1ba z\u00e1rjuk be az alkalmaz\u00e1st, a program tov\u00e1bb fut a h\u00e1tt\u00e9rben mindaddig, am\u00edg v\u00e9gre nem hajt\u00f3dik az utolj\u00e1ra ind\u00edtott sz\u00e1mol\u00e1s is: egy processz fut\u00e1sa ugyanis csak akkor fejez\u0151dik csak be, ha m\u00e1r nincs fut\u00f3 el\u0151t\u00e9rsz\u00e1la. M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy \u00faj sz\u00e1l ind\u00edt\u00e1sa helyett threadpool sz\u00e1lon futtassa a sz\u00e1m\u00edt\u00e1st. Ehhez csak a gombnyom\u00e1s esem\u00e9nykezel\u0151j\u00e9t kell ism\u00e9t \u00e1t\u00edrni. private void buttonCalcResult_Click ( object sender , EventArgs e ) { if ( double . TryParse ( textBoxParam1 . Text , out var p1 ) && double . TryParse ( textBoxParam2 . Text , out var p2 )) { var parameters = new double [] { p1 , p2 }; ThreadPool . QueueUserWorkItem ( CalculatorThread , parameters ); } else { MessageBox . Show ( this , \"Invalid parameter!\" , \"Error\" ); } } Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az alkalmaz\u00e1s az ablak bez\u00e1r\u00e1sakor azonnal le\u00e1ll, nem foglalkozik az esetlegesen m\u00e9g fut\u00f3 sz\u00e1lakkal (mert a threadpool sz\u00e1lak h\u00e1tt\u00e9r sz\u00e1lak). 5. Feladat \u2013 Termel\u0151-fogyaszt\u00f3 alap\u00fa megold\u00e1s \u00b6 Az el\u0151z\u0151 feladatok megold\u00e1sa sor\u00e1n \u00f6nmag\u00e1ban egy j\u00f3l m\u0171k\u00f6d\u0151 komplett megold\u00e1s\u00e1t kaptuk az eredeti probl\u00e9m\u00e1nak, mely lehet\u0151v\u00e9 teszi, hogy ak\u00e1r t\u00f6bb munkasz\u00e1l is p\u00e1rhuzamosan dolgozzon a h\u00e1tt\u00e9rben a sz\u00e1m\u00edt\u00e1son, ha a gombot sokszor egym\u00e1s ut\u00e1n megnyomjuk. A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1sunkat, hogy a gombnyom\u00e1sra ne mindig keletkezzen \u00faj sz\u00e1l, hanem a feladatok beker\u00fcljenek egy feladatsorba, ahonnan t\u00f6bb, a h\u00e1tt\u00e9rben folyamatosan fut\u00f3 sz\u00e1l egym\u00e1s ut\u00e1n fogja kivenni \u0151ket \u00e9s v\u00e9grehajtani. Ez a feladat a klasszikus termel\u0151-fogyaszt\u00f3 probl\u00e9ma, mely a gyakorlatban is sokszor el\u0151fordul, a m\u0171k\u00f6d\u00e9s\u00e9t az al\u00e1bbi \u00e1bra szeml\u00e9lteti. Termel\u0151 fogyaszt\u00f3 vs ThreadPool Ha belegondolunk, a ThreadPool is egy speci\u00e1lis, a .NET \u00e1ltal sz\u00e1munkra biztos\u00edtott termel\u0151-fogyaszt\u00f3 \u00e9s \u00fctemez\u0151 mechanizmus. A k\u00f6vetkez\u0151kben egy m\u00e1s jelleg\u0171 termel\u0151-fogyaszt\u00f3 megold\u00e1st dolgozunk ki annak \u00e9rdek\u00e9ben, hogy bizonyos sz\u00e1lkezel\u00e9ssel kapcsolatos konkurencia probl\u00e9m\u00e1kkal tal\u00e1lkozhassunk. A f\u0151sz\u00e1lunk a termel\u0151, a Calculate result gombra kattintva hoz l\u00e9tre egy \u00faj feladatot. Fogyaszt\u00f3/feldolgoz\u00f3/munkasz\u00e1lb\u00f3l az\u00e9rt ind\u00edtunk majd t\u00f6bbet, mert \u00edgy t\u00f6bb CPU magot is ki tudunk haszn\u00e1lni, valamint a feladatok v\u00e9grehajt\u00e1s\u00e1t p\u00e1rhuzamos\u00edtani tudjuk. A feladatok ideiglenes t\u00e1rol\u00e1s\u00e1ra a kiindul\u00f3 projekt\u00fcnkben m\u00e1r n\u00e9mik\u00e9ppen el\u0151k\u00e9sz\u00edtett DataFifo oszt\u00e1lyt tudjuk haszn\u00e1lni. N\u00e9zz\u00fck meg a forr\u00e1sk\u00f3dj\u00e1t. Egy egyszer\u0171 FIFO sort val\u00f3s\u00edt meg, melyben double[] elemeket t\u00e1rol. A Put met\u00f3dus hozz\u00e1f\u0171zi a bels\u0151 lista v\u00e9g\u00e9hez az \u00faj p\u00e1rokat, m\u00edg a TryGet met\u00f3dus visszaadja (\u00e9s elt\u00e1vol\u00edtja) a bels\u0151 lista els\u0151 elem\u00e9t. Amennyiben a lista \u00fcres, a f\u00fcggv\u00e9ny nem tud visszaadni elemet. Ilyenkor a false visszat\u00e9r\u00e9si \u00e9rt\u00e9kkel jelzi ezt. M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy ne ThreadPool ba dolgozzon, hanem a FIFO-ba: private void buttonCalcResult_Click ( object sender , EventArgs e ) { if ( double . TryParse ( textBoxParam1 . Text , out var p1 ) && double . TryParse ( textBoxParam2 . Text , out var p2 )) { var parameters = new double [] { p1 , p2 }; _fifo . Put ( parameters ); } else { MessageBox . Show ( this , \"Invalid parameter!\" , \"Error\" ); } } K\u00e9sz\u00edts\u00fck el az \u00faj sz\u00e1lkezel\u0151 f\u00fcggv\u00e9ny na\u00edv implement\u00e1ci\u00f3j\u00e1t az \u0171rlap oszt\u00e1lyunkban: private void WorkerThread () { while ( true ) { if ( _fifo . TryGet ( out var data )) { double result = Algorithms . SuperAlgorithm . Calculate ( data ); ShowResult ( data , result ); } Thread . Sleep ( 500 ); } } A Thread.Sleep bevezet\u00e9s\u00e9re az\u00e9rt van sz\u00fcks\u00e9g, mert e n\u00e9lk\u00fcl a munkasz\u00e1lak \u00fcres FIFO eset\u00e9n folyamatosan feleslegesen p\u00f6r\u00f6gn\u00e9nek, semmi hasznos m\u0171veletet nem v\u00e9gezve is 100%-ban kiterheln\u00e9nek egy-egy CPU magot. Megold\u00e1sunk nem ide\u00e1lis, k\u00e9s\u0151bb tov\u00e1bbfejlesztj\u00fck. Hozzuk l\u00e9tre, \u00e9s ind\u00edtsuk el a feldolgoz\u00f3 sz\u00e1lakat a konstruktorban: new Thread ( WorkerThread ) { Name = \"Szal1\" }. Start (); new Thread ( WorkerThread ) { Name = \"Szal2\" }. Start (); new Thread ( WorkerThread ) { Name = \"Szal3\" }. Start (); Ind\u00edtsuk el az alkalmaz\u00e1st, majd z\u00e1rjuk is be azonnal an\u00e9lk\u00fcl, hogy a Calculate Result gombra kattintan\u00e1nk. Az tapasztaljuk, hogy az ablakunk bez\u00e1r\u00f3dik ugyan, de a processz\u00fcnk tov\u00e1bb fut, az alkalmaz\u00e1s bez\u00e1r\u00e1s\u00e1ra csak a Visual Studiob\u00f3l, vagy a Task Managerb\u0151l van lehet\u0151s\u00e9g: A feldolgoz\u00f3 sz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9p\u00e9skor megakad\u00e1lyozz\u00e1k a processz megsz\u0171n\u00e9s\u00e9t. Az egyik megold\u00e1s az lehetne, ha a sz\u00e1lak IsBackground tulajdons\u00e1g\u00e1t true -ra \u00e1ll\u00edtan\u00e1nk a l\u00e9trehoz\u00e1sukat k\u00f6vet\u0151en. A m\u00e1sik megold\u00e1s, hogy kil\u00e9p\u00e9skor gondoskodunk a feldolgoz\u00f3 sz\u00e1lak kil\u00e9ptet\u00e9s\u00e9r\u0151l. Egyel\u0151re tegy\u00fck f\u00e9lre ezt a probl\u00e9m\u00e1t, k\u00e9s\u0151bb visszat\u00e9r\u00fcnk r\u00e1. Ind\u00edtsuk el az alkalmaz\u00e1st azt tapasztaljuk, hogy miut\u00e1n kattintunk a Calculate Result gombon (csak egyszer kattintsunk rajta) nagy val\u00f3sz\u00edn\u0171s\u00e9ggel kiv\u00e9telt fogunk kapni. A probl\u00e9ma az, hogy a DataFifo nem sz\u00e1lbiztos, inkonzisztens\u00e9 v\u00e1lt. K\u00e9t ered\u0151 ok is h\u00faz\u00f3dik a h\u00e1tt\u00e9rben: Probl\u00e9ma 1 \u00b6 N\u00e9zz\u00fck a k\u00f6vetkez\u0151 forgat\u00f3k\u00f6nyvet: A sor \u00fcres. A feldolgoz\u00f3 sz\u00e1lak egy while ciklusban folyamatosan pollozz\u00e1k a FIFO-t, vagyis h\u00edvj\u00e1k a TryGet met\u00f3dus\u00e1t. A felhaszn\u00e1l\u00f3 egy feladatot tesz a sorba. Az egyik feldolgoz\u00f3 sz\u00e1l a TryGet met\u00f3dusban azt l\u00e1tja, van adat a sorban, vagyis if ( _innerList.Count > 0 ) k\u00f3dsor felt\u00e9tele teljes\u00fcl, \u00e9s r\u00e1l\u00e9p a k\u00f6vetkez\u0151 k\u00f3dsorra. Tegy\u00fck fel, hogy ez a sz\u00e1l ebben a pillanatban elveszti a fut\u00e1si jog\u00e1t, m\u00e1r nincs ideje kivenni az adatot a sorb\u00f3l. Egy m\u00e1sik feldolgoz\u00f3 sz\u00e1l is \u00e9ppen ekkor ejti meg az if ( _innerList.Count > 0 ) vizsg\u00e1latot, n\u00e1la is teljes\u00fcl a felt\u00e9tel, \u00e9s ez a sz\u00e1l ki is veszi az adatot a sorb\u00f3l. Az els\u0151 sz\u00e1lunk \u00fajra \u00fctemez\u00e9sre ker\u00fcl, fel\u00e9bred, \u0151 is megpr\u00f3b\u00e1lja kivenni az adatot a sorb\u00f3l: a sor viszont m\u00e1r \u00fcres, a m\u00e1sik sz\u00e1lunk kivette az egyetlen adatot a sorb\u00f3l az orra el\u0151tt. \u00cdgy az _innerList[0] hozz\u00e1f\u00e9r\u00e9s kiv\u00e9telt eredm\u00e9nyez. Ezt a probl\u00e9m\u00e1t csak \u00fagy tudjuk elker\u00fclni, ha a sor \u00fcress\u00e9g\u00e9nek a vizsg\u00e1lat\u00e1t \u00e9s az elem kiv\u00e9tel\u00e9t oszthatatlann\u00e1 tessz\u00fck. Thread.Sleep(500) Az \u00fcress\u00e9gvizsg\u00e1latot figyel\u0151 k\u00f3dsort k\u00f6vet\u0151 Thread.Sleep(500); k\u00f3dsornak csak az a szerepe a p\u00e9ldak\u00f3dunkban, hogy a fenti peches forgat\u00f3k\u00f6nyv bek\u00f6vetkez\u00e9s\u00e9nek a val\u00f3sz\u00edn\u0171s\u00e9g\u00e9t megn\u00f6velje, s \u00edgy a p\u00e9ld\u00e1t szeml\u00e9letesebb\u00e9 tegye (mivel ilyenkor szinte biztos, hogy \u00e1t\u00fctemez\u0151dik a sz\u00e1l). A k\u00e9s\u0151bbiekben ezt ki is fogjuk venni, egyel\u0151re hagyjuk benne. Probl\u00e9ma 2 \u00b6 A DataFifo oszt\u00e1ly egyid\u0151ben t\u00f6bb sz\u00e1lb\u00f3l is hozz\u00e1f\u00e9rhet a List<double[]> t\u00edpus\u00fa _innerList tagv\u00e1ltoz\u00f3hoz. Ugyanakkor, ha megn\u00e9zz\u00fck a List<T> dokument\u00e1ci\u00f3j\u00e1t, azt tal\u00e1ljuk, hogy az oszt\u00e1ly nem sz\u00e1lbiztos (not thread safe). Ez esetben viszont ez nem tehetj\u00fck meg, nek\u00fcnk kell z\u00e1rakkal biztos\u00edtanunk, hogy a k\u00f3dunk egyid\u0151ben csak egy met\u00f3dus\u00e1hoz / tulajdons\u00e1g\u00e1hoz / tagv\u00e1ltoz\u00f3j\u00e1hoz f\u00e9r hozz\u00e1 (pontosabban inkonzisztencia csak egyidej\u0171 \u00edr\u00e1s, illetve egyidej\u0171 \u00edr\u00e1s \u00e9s olvas\u00e1s eset\u00e9n l\u00e9phet fel, de az \u00edr\u00f3kat \u00e9s az olvas\u00f3kat a legt\u00f6bb esetben nem szoktuk megk\u00fcl\u00f6nb\u00f6ztetni, itt sem tessz\u00fck). A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a DataFifo oszt\u00e1lyunkat sz\u00e1lbiztoss\u00e1 tessz\u00fck, amivel megakad\u00e1lyozzuk, hogy a fenti k\u00e9t probl\u00e9ma bek\u00f6vetkezhessen. 6. feladat \u2013 Tegy\u00fck sz\u00e1biztoss\u00e1 a DataFifo oszt\u00e1lyt \u00b6 A DataFifo oszt\u00e1ly sz\u00e1lbiztoss\u00e1 t\u00e9tel\u00e9hez sz\u00fcks\u00e9g\u00fcnk van egy objektumra (ez b\u00e1rmilyen referencia t\u00edpus\u00fa objektum lehet), melyet kulcsk\u00e9nt haszn\u00e1lhatunk a z\u00e1rol\u00e1sn\u00e1l. Ezt k\u00f6vet\u0151en a lock kulcssz\u00f3 seg\u00edts\u00e9g\u00e9vel el tudjuk \u00e9rni, hogy egyszerre mindig csak egy sz\u00e1l tart\u00f3zkodjon az adott kulccsal v\u00e9dett blokkokban. Vegy\u00fcnk fel egy object t\u00edpus\u00fa mez\u0151t _syncRoot n\u00e9ven a DataFifo oszt\u00e1lyba. private object _syncRoot = new object (); Eg\u00e9sz\u00edts\u00fck ki a Put \u00e9s a TryGet f\u00fcggv\u00e9nyeket a z\u00e1rol\u00e1ssal. public void Put ( double [] data ) { lock ( _syncRoot ) { _innerList . Add ( data ); } } public bool TryGet ( out double [] data ) { lock ( _syncRoot ) { if ( _innerList . Count > 0 ) { Thread . Sleep ( 500 ); data = _innerList [ 0 ]; _innerList . RemoveAt ( 0 ); return true ; } data = null ; return false ; } } Surround with Haszn\u00e1ljuk a Visual Studio Surround with funkci\u00f3j\u00e1t a CTRL + K, CTRL + S billenty\u0171 kombin\u00e1ci\u00f3j\u00e1val a k\u00f6r\u00fclvenni k\u00edv\u00e1nt kijel\u00f6lt k\u00f3dr\u00e9szleten. Most m\u00e1r nem szabad kiv\u00e9telt kapnunk. Ki is vehetj\u00fck a TryGet met\u00f3dusb\u00f3l a mesters\u00e9ges k\u00e9sleltet\u00e9st ( Thread.Sleep(500); sor). Lockol\u00e1s this -en Felmer\u00fclhet a k\u00e9rd\u00e9s, hogy mi\u00e9rt vezett\u00fcnk be egy k\u00fcl\u00f6n _syncRoot tagv\u00e1ltoz\u00f3t \u00e9s haszn\u00e1ltuk ezt z\u00e1rol\u00e1sra a lock param\u00e9terek\u00e9nt, amikor a this -t is haszn\u00e1lhattuk volna helyette (a DataFifo referencia t\u00edpus, \u00edgy ennek nem lenne akad\u00e1lya). A this alkalmaz\u00e1sa azonban s\u00e9rten\u00e9 az oszt\u00e1lyunk egys\u00e9gbez\u00e1r\u00e1s\u00e1t ! Ne feledj\u00fck: a this egy referencia az objektumunkra, de m\u00e1s oszt\u00e1lyoknak is van ugyanerre az objektumra referenci\u00e1juk (pl. eset\u00fcnkben a MainForm -nak van referenci\u00e1ja a DataFifo -ra), \u00e9s ha ezek a k\u00fcls\u0151 oszt\u00e1lyok z\u00e1rat tesznek a lock seg\u00edts\u00e9g\u00e9vel az objektumra, akkor az \"interfer\u00e1l\" az \u00e1ltalunk az oszt\u00e1lyon bel\u00fck haszn\u00e1lt z\u00e1rol\u00e1ssal (mivel this alkalmaz\u00e1sa miatt a k\u00fcls\u0151 \u00e9s bels\u0151 lock -ok param\u00e9tere ugyanaz lesz). \u00cdgy pl. egy k\u00fcls\u0151 z\u00e1rral teljesen meg lehet \"b\u00e9n\u00edtani\" a TryGet \u00e9s Put m\u0171velet m\u0171k\u00f6d\u00e9s\u00e9t. Ezzel szemben az \u00e1ltalunk v\u00e1lasztott megold\u00e1sban a lock param\u00e9tere, a _syncRoot v\u00e1ltoz\u00f3 priv\u00e1t, ehhez m\u00e1r k\u00fcls\u0151 oszt\u00e1lyok nem f\u00e9rhetnek hozz\u00e1, \u00edgy nem is zavarhatj\u00e1k meg az oszt\u00e1lyunk bels\u0151 m\u0171k\u00f6d\u00e9s\u00e9t. 7. feladat \u2013 Hat\u00e9kony jelz\u00e9s megval\u00f3s\u00edt\u00e1sa \u00b6 ManualResetEvent haszn\u00e1lata \u00b6 A WorkerThread -ben folyamatosan fut\u00f3 while ciklus \u00fan. akt\u00edv v\u00e1rakoz\u00e1st val\u00f3s\u00edt meg, ami mindig ker\u00fclend\u0151. Ha a Thread.Sleep -et nem tett\u00fck volna a ciklusmagba, akkor ezzel maximumra ki is terheln\u00e9 a processzort. A Thread.Sleep megoldja ugyan a processzor terhel\u00e9s probl\u00e9m\u00e1t, de bevezet egy m\u00e1sikat: ha mindh\u00e1rom munkasz\u00e1lunk \u00e9ppen alv\u00f3 \u00e1llapotba l\u00e9pett, mikor be\u00e9rkezik egy \u00faj adat, akkor feleslegesen v\u00e1runk 500 ms-ot az adat feldolgoz\u00e1s\u00e1nak megkezd\u00e9s\u00e9ig. A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1st, hogy blokkolva v\u00e1rakozzon, am\u00edg adat nem ker\u00fcl a FIFO-ba (amikor viszont adat ker\u00fcl bele, azonnal kezdje meg a feldolgoz\u00e1st). Annak jelz\u00e9s\u00e9re, hogy van-e adat a sorban egy ManualResetEvent -et fogunk haszn\u00e1lni. Adjunk hozz\u00e1 egy MaunalResetEvent p\u00e9ld\u00e1nyt a DataFifo oszt\u00e1lyunkhoz _hasData n\u00e9ven. // A false konstruktor param\u00e9ter eredm\u00e9nyek\u00e9ppen kezdetben az esem\u00e9ny nem jelzett (kapu csukva) private ManualResetEvent _hasData = new ManualResetEvent ( false ); A _hasData alkalmaz\u00e1sunkban kapuk\u00e9nt viselkedik. Amikor adat ker\u00fcl a list\u00e1ba \u201ekinyitjuk\u201d, m\u00edg amikor ki\u00fcr\u00fcl a lista \u201ebez\u00e1rjuk\u201d. Az esem\u00e9ny szemantik\u00e1ja \u00e9s elnevez\u00e9se L\u00e9nyeges, hogy j\u00f3 v\u00e1lasszuk meg az esem\u00e9ny\u00fcnk szemantik\u00e1j\u00e1t \u00e9s ezt a v\u00e1ltoz\u00f3nk nev\u00e9vel pontosan ki is fejezz\u00fck. A p\u00e9ld\u00e1nkban a _hasData n\u00e9v j\u00f3l kifejezi, hogy pontosan akkor \u00e9s csak akkor jelzett az esem\u00e9ny\u00fcnk (nyitott a kapu), amikor van feldolgozand\u00f3 adat. Most m\u00e1r \"csak\" az a dolgunk, hogy ezt a szemantik\u00e1t megval\u00f3s\u00edtsuk: jelzettbe tegy\u00fck az esem\u00e9nyt, mikor adat ker\u00fcl a FIFO-ba, \u00e9s jelzetlenbe, amikor ki\u00fcr\u00fcl a FIFO. public void Put ( double [] data ) { lock ( _syncRoot ) { _innerList . Add ( data ); _hasData . Set (); } } public bool TryGet ( out double [] data ) { lock ( _syncRoot ) { if ( _innerList . Count > 0 ) { data = _innerList [ 0 ]; _innerList . RemoveAt ( 0 ); if ( _innerList . Count == 0 ) { _hasData . Reset (); } return true ; } data = null ; return false ; } } Jelz\u00e9sre v\u00e1rakoz\u00e1s (blokkol\u00f3 a Get) \u00b6 Az el\u0151z\u0151 pontban megoldottuk a jelz\u00e9st, \u00e1m ez \u00f6nmag\u00e1ban nem sokat \u00e9r, hiszen nem v\u00e1rakoznak r\u00e1. Ennek megval\u00f3s\u00edt\u00e1sa j\u00f6n most. M\u00f3dos\u00edtsuk a met\u00f3dust az al\u00e1bbiak szerint: kidobjuk az \u00fcress\u00e9g vizsg\u00e1latot \u00e9s az esem\u00e9nyre val\u00f3 v\u00e1rakoz\u00e1ssal p\u00f3toljuk. public bool TryGet ( out double [] data ) { lock ( _syncRoot ) { if ( _hasData . WaitOne ()) { // ... A WaitOne m\u0171velet visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9nek vizsg\u00e1lata A WaitOne m\u0171velet egy bool \u00e9rt\u00e9kkel t\u00e9r vissza, mely igaz, ha a WaitOne param\u00e9ter\u00e9ben megadott id\u0151korl\u00e1t el\u0151tt jelzett \u00e1llapotba ker\u00fcl az esem\u00e9ny (ill. ennek megfelel\u0151en hamis, ha lej\u00e1rt az id\u0151korl\u00e1t). A p\u00e9ld\u00e1nkban nem adtunk meg id\u0151korl\u00e1tot param\u00e9terben, mely v\u00e9gtelen id\u0151korl\u00e1t alkalmaz\u00e1s\u00e1t jelenti. Ennek megfelel\u0151en felesleges is az if felt\u00e9telvizsg\u00e1lat, hiszen eset\u00fcnkben a WaitOne() mindig igaz \u00e9rt\u00e9kkel t\u00e9r vissza. Ez egyetlen ok, ami\u00e9rt m\u00e9gis \u00e9lt\u00fcnk felt\u00e9telvizsg\u00e1lattal: \u00edgy a k\u00f6vetketkez\u0151 \u00e9s egy k\u00e9s\u0151bbi feladatn\u00e1l kisebb \u00e1talak\u00edt\u00e1sra lesz majd sz\u00fcks\u00e9g. Ezzel a Thread.Sleep a WorkerThread -ben feleslegess\u00e9 v\u00e1lt, kommentezz\u00fck ki! A fenti megold\u00e1s futtat\u00e1sakor azt tapasztaljuk, hogy az alkalmaz\u00e1sunk fel\u00fclete az els\u0151 gombnyom\u00e1st k\u00f6vet\u0151en befagy. Az el\u0151z\u0151 megold\u00e1sunkban ugyanis egy amat\u0151r hib\u00e1t k\u00f6vett\u00fcnk el. A lock-olt k\u00f3dr\u00e9szleten bel\u00fcl v\u00e1rakozunk a _hasData jelz\u00e9s\u00e9re, \u00edgy a f\u0151sz\u00e1lnak lehet\u0151s\u00e9ge sincs arra, hogy a Put m\u0171veletben (egy szint\u00e9n lock -kal v\u00e9dett r\u00e9szen bel\u00fcl) jelz\u00e9st k\u00fcldj\u00f6n _hasData -val. Gyakorlatilag egy holtpont (deadlock) helyzet alakult ki. Gyors hibajav\u00edt\u00e1sk\u00e9nt megadhatunk egy id\u0151korl\u00e1tot (ms) a v\u00e1rakoz\u00e1sn\u00e1l: if ( _hasData . WaitOne ( 100 )) Tesztelj\u00fck az alkalmaz\u00e1st! A megold\u00e1s ugyan fut, de az eleg\u00e1ns \u00e9s k\u00f6vetend\u0151 minta az, hogy lock-on bel\u00fcl ker\u00fclj\u00fck a blokkolva v\u00e1rakoz\u00e1st. Val\u00f3di jav\u00edt\u00e1sk\u00e9nt cser\u00e9lj\u00fck meg a lock -ot \u00e9s a WaitOne -t, illetve a WaitOne param\u00e9ter elt\u00e1vol\u00edt\u00e1s\u00e1val sz\u00fcntess\u00fck meg a v\u00e1rakoz\u00e1si id\u0151korl\u00e1tot: public bool TryGet ( out double [] data ) { if ( _hasData . WaitOne ()) { lock ( _syncRoot ) { data = _innerList [ 0 ]; _innerList . RemoveAt ( 0 ); if ( _innerList . Count == 0 ) { _hasData . Reset (); } return true ; } } data = null ; return false ; } Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Az els\u0151 gombnyom\u00e1s hat\u00e1s\u00e1ra kiv\u00e9telt kapunk. \u00cdgy elker\u00fclj\u00fck ugyan a deadlockot, azonban a sz\u00e1lbiztoss\u00e1g s\u00e9r\u00fclt , hiszen mire a lock -on bel\u00fclre jutunk, nem biztos, hogy maradt elem a list\u00e1ban. Ugyanis lehet, t\u00f6bb sz\u00e1l is v\u00e1rakozik a _hasData.WaitOne() m\u0171veletn\u00e9l arra, hogy elem ker\u00fclj\u00f6n a sorba. Mikor ez bek\u00f6vetkezik, a ManualResetEvent objektumunk mind \u00e1tengedi (hacsak \u00e9ppen gyorsan le nem csukja egy sz\u00e1l, de ez nem garant\u00e1lt). A konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s neh\u00e9zs\u00e9gei J\u00f3l illusztr\u00e1lja a feladat, hogy milyen alapos \u00e1tgondol\u00e1st ig\u00e9nyel a konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s. Tulajdonk\u00e9ppen m\u00e9g szerencs\u00e9nk is volt az el\u0151z\u0151ekben, mert j\u00f3l reproduk\u00e1lhat\u00f3an el\u0151j\u00f6tt a hiba. A gyakorlatban azonban ez ritk\u00e1n van \u00edgy. Sajnos sokkal gyakoribb, hogy a konkurenciahib\u00e1k id\u0151nk\u00e9nti, nem reproduk\u00e1lhat\u00f3 probl\u00e9m\u00e1kat okoznak. Az ilyen jelleg\u0171 feladatok megold\u00e1s\u00e1t mindig nagyon \u00e1t kell gondolni, nem lehet az \"addig-pr\u00f3b\u00e1lkozom-m\u00edg-j\u00f3-nem-lesz-a-k\u00e9zi-teszt-sor\u00e1n\" elv ment\u00e9n leprogramozni. Jav\u00edt\u00e1sk\u00e9nt tegy\u00fck vissza a lock -on bel\u00fcli \u00fcress\u00e9g-vizsg\u00e1latot. public bool TryGet ( out double [] data ) { if ( _hasData . WaitOne ()) { lock ( _syncRoot ) { if ( _innerList . Count > 0 ) { data = _innerList [ 0 ]; _innerList . RemoveAt ( 0 ); if ( _innerList . Count == 0 ) { _hasData . Reset (); } return true ; } } } data = null ; return false ; } Ez m\u00e1r j\u00f3l m\u0171k\u00f6dik. El\u0151fordulhat ugyan, hogy feleslegesen fordulunk a list\u00e1hoz, de ezzel \u00edgy most megel\u00e9gsz\u00fcnk. Tesztelj\u00fck az alkalmaz\u00e1st! System.Collections.Concurrent A .NET keretrendszerben t\u00f6bb be\u00e9p\u00edtett sz\u00e1lbiztoss\u00e1gra felk\u00e9sz\u00edtett oszt\u00e1ly is tal\u00e1lhat\u00f3 a System.Collections.Concurrent n\u00e9vt\u00e9rben. A fenti p\u00e9ld\u00e1ban a DataFifo oszt\u00e1lyt a System.Collections.Concurrent.ConcurrentQueue oszt\u00e1llyal kiv\u00e1lthattuk volna. 8. feladat \u2013 Kultur\u00e1lt le\u00e1ll\u00e1s \u00b6 Kor\u00e1bban f\u00e9lretett\u00fck azt a probl\u00e9m\u00e1t, hogy az ablakunk bez\u00e1r\u00e1sakor a processz\u00fcnk \u201eberagad\u201d, ugyanis a feldolgoz\u00f3 munkasz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9ptet\u00e9s\u00fcket eddig nem oldottuk meg. C\u00e9lunk, hogy a v\u00e9gtelen while ciklust kiv\u00e1ltva a munkasz\u00e1laink az alkalmaz\u00e1s bez\u00e1r\u00e1sakor kultur\u00e1lt m\u00f3don \u00e1lljanak le. Egy ManualResetEvent seg\u00edts\u00e9g\u00e9vel jelezz\u00fck a le\u00e1ll\u00edt\u00e1st a FIFO-ban a TryGet -ben t\u00f6rt\u00e9n\u0151 v\u00e1rakoz\u00e1s sor\u00e1n. A FIFO-ban vegy\u00fcnk fel egy \u00faj ManualResetEvent -et, \u00e9s vezess\u00fcnk be egy Release m\u0171veletet, amellyel a v\u00e1rakoz\u00e1sainkat z\u00e1rhatjuk r\u00f6vidre (\u00faj esem\u00e9ny\u00fcnk jelzett \u00e1llapotba \u00e1ll\u00edthat\u00f3). private ManualResetEvent _releaseTryGet = new ManualResetEvent ( false ); public void Release () { _releaseTryGet . Set (); } A TryGet -ben erre az esem\u00e9nyre is v\u00e1rakozzunk. A WaitAny met\u00f3dus akkor engedi tov\u00e1bb a futtat\u00e1st, ha a param\u00e9terk\u00e9nt megadott WaitHandle t\u00edpus\u00fa objektumok k\u00f6z\u00fcl valamelyik jelzett \u00e1llapotba ker\u00fcl, \u00e9s visszaadja annak t\u00f6mbb\u00e9li index\u00e9t. T\u00e9nyleges adatfeldolgoz\u00e1st pedig csak akkor szeretn\u00e9nk, ha a _hasData jelzett (amikor is a WaitAny 0-val t\u00e9r vissza). public bool TryGet ( out double [] data ) { if ( WaitHandle . WaitAny ( new [] { _hasData , _releaseTryGet }) == 0 ) { lock ( _syncRoot ) { MainForm.cs -ban vegy\u00fcnk fel egy flag tagv\u00e1ltoz\u00f3t a bez\u00e1r\u00e1s jelz\u00e9s\u00e9re: private bool _isClosed = false ; A form bez\u00e1r\u00e1sakor \u00e1ll\u00edtsuk jelzettre az \u00faj esem\u00e9nyt \u00e9s billents\u00fcnk be be a flag-et is. (A Form oszt\u00e1ly OnClosed met\u00f3dusa mindig megh\u00edv\u00f3dik bez\u00e1r\u00e1skor, a Dispose -zal ellent\u00e9tben.) protected override void OnClosed ( EventArgs e ) { base . OnClosed ( e ); _isClosed = true ; _fifo . Release (); } \u00cdrjuk \u00e1t a while ciklust az el\u0151z\u0151 pontban felvett flag figyel\u00e9s\u00e9re. private void WorkerThread () { while (! _isClosed ) { V\u00e9g\u00fcl biztos\u00edtsuk, hogy a m\u00e1r bez\u00e1r\u00f3d\u00f3 ablak eset\u00e9ben ne pr\u00f3b\u00e1ljunk \u00fczeneteket ki\u00edrni private void ShowResult ( double [] parameters , double result ) { if ( _isClosed ) return ; Futtassuk az alkalmaz\u00e1st, \u00e9s ellen\u0151rizz\u00fck, kil\u00e9p\u00e9skor az processz\u00fcnk val\u00f3ban befejezi-e a fut\u00e1s\u00e1t. Hol h\u00edvjunk Release-t? (kitekint\u00e9s - nem k\u00f6telez\u0151 anyag) Az OnClosed vagy OnClosing \u00e9letciklus f\u00fcggv\u00e9nyei a Formnak j\u00f3 v\u00e1laszt\u00e1sok, mert azokr\u00f3l biztosan tudjuk, hogy helyesen h\u00edv\u00f3dnak meg minden esetben. Cser\u00e9ben egy plusz flag-et kell karbantartanunk. Egyik alternat\u00edva lehetne m\u00e9g az \u00e9letciklus esem\u00e9nyek helyett a Dispose met\u00fadusba rakni ezt a logik\u00e1t, \u00e9s akkor az IsDisposed be\u00e9p\u00edtett flag-et is haszn\u00e1lhatn\u00e1nk. Ezt k\u00e9t okb\u00f3l is \u00e9rdemes ker\u00fclni Formok eset\u00e9ben: A Dispose met\u00f3dus m\u00e1r l\u00e9tezik a MainForm.Designer.cs f\u00e1jlban, \u00e9s a Designer.cs f\u00e1jlokat alapvet\u0151en nem szok\u00e1s szerkeszteni, b\u00e1r ezt a met\u00f3dust a designer m\u00e1r nem piszk\u00e1lja, ha m\u00e1r l\u00e9trej\u00f6tt a form, \u00edgy ezt ak\u00e1r nyugodtan \u00e1t is helyezhetn\u00e9nk a MainForm.cs -be. A Dispose megh\u00edv\u00e1sa nem mindig determinisztikus Windows Forms eset\u00e9ben, mert el\u0151fordulhat, hogy nem a keretrendszer nyitotta a formot, hanem a fejleszt\u0151 programozottan, \u00e9s elfelejtette Dispose -t h\u00edvni rajta, aminek a hat\u00e1s\u00e1ra, majd csak a GC fogja megh\u00edvni a Dispose f\u00fcggv\u00e9nyt. A Release m\u0171velet helyett m\u00e9g egy m\u00e1sik alternat\u00edva lehetne, hogy az IDisposable mint\u00e1t megval\u00f3s\u00edtjuk a DataFifo -ba, de ilyenkor is k\u00e9zzel kellene Dispose -t h\u00edvni, mivel nem f\u00fcggv\u00e9ny szint\u0171 az \u00e9letciklusa a FIFO objektumnak, \u00edgy nem tudn\u00e1nk using blokkban haszn\u00e1lni. Egy \u00f6sszetett alkalmaz\u00e1sban egy\u00e9nk\u00e9nt gyakran nem k\u00e9zzel kezelj\u00fck egy-egy oszt\u00e1lynak a f\u00fcgg\u0151s\u00e9geit \u00e9s az \u00e9letciklus\u00e1t. Helyette a Dependency Injection tervez\u00e9si mint\u00e1t \u00e9rdemes alkalmazni, ahol egy k\u00fcl\u00f6n komponensbe szervezz\u00fck ki az objektumok p\u00e9ld\u00e1nyos\u00edt\u00e1s\u00e1t \u00e9s \u00e9letciklus\u00e1nak kezel\u00e9s\u00e9t. Kitekint\u00e9s: Task, async, await \u00b6 A t\u00e1rgynak nem anyaga, de .NET alkalmaz\u00e1sok (\u00e9s m\u00e1s modern nyelv\u0171 alkalmaz\u00e1sok (Swift, Kotlin, TypeScript, stb.)) eset\u00e9ben megker\u00fclhetetlen az aszinkron programoz\u00e1s koncepci\u00f3ja. A C# (\u00e9s m\u00e1s modern nyelvek) nyelvi szintre emelt\u00e9k az szinkron esem\u00e9nyek bev\u00e1r\u00e1s\u00e1nak kezel\u00e9s\u00e9t az async / await kulcsszavakkal ( L\u00e1sd b\u0151vebben ) M\u00e9gis ehhez az anyaghoz laz\u00e1n \u00fagy kapcsol\u00f3dhat ez a t\u00e9ma, hogy a Task oszt\u00e1ly olyan aszinkron m\u0171veletet is reprezent\u00e1lhat, ami ak\u00e1r k\u00fcl\u00f6n sz\u00e1lon is futhat (de nem k\u00f6telez\u0151en futnak ezek k\u00fcl\u00f6n sz\u00e1lon!), \u00e9s bev\u00e1rhat\u00f3 ennek az eredm\u00e9nye aszinkron m\u00f3don. A Task.Run statikus f\u00fcggv\u00e9ny pedig egyenesen a ThreadPool -on \u00fctemez egy m\u0171veletet, ami \u00edgy aszinkron bev\u00e1rhat\u00f3.","title":"4. T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se"},{"location":"labor/4-tobbszalu/#4-tobbszalu-alkalmazasok-keszitese","text":"","title":"4. T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se"},{"location":"labor/4-tobbszalu/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja, hogy megismertesse a hallgat\u00f3kat a t\u00f6bbsz\u00e1las programoz\u00e1s sor\u00e1n k\u00f6vetend\u0151 alapelvekkel. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt): Sz\u00e1lak ind\u00edt\u00e1sa ( Thread ) Sz\u00e1lak le\u00e1ll\u00edt\u00e1sa Sz\u00e1lbiztos (thread safe) oszt\u00e1lyok k\u00e9sz\u00edt\u00e9se a lock kulcssz\u00f3 alkalmaz\u00e1s\u00e1val ThreadPool haszn\u00e1lata Jelz\u00e9s \u00e9s jelz\u00e9sre v\u00e1rakoz\u00e1s sz\u00e1l szinkroniz\u00e1ci\u00f3 ManualResetEvent seg\u00edts\u00e9g\u00e9vel ( WaitHandle ) Windows Forms sz\u00e1lkezel\u00e9si saj\u00e1toss\u00e1gok ( Invoke ) Term\u00e9szetesen, mivel a t\u00e9mak\u00f6r hatalmas, csak alapszint\u0171 tud\u00e1st fogunk szerezni, de e tud\u00e1s birtok\u00e1ban m\u00e1r k\u00e9pesek lesz\u00fcnk \u00f6n\u00e1ll\u00f3an is elindulni a bonyolultabb feladatok megval\u00f3s\u00edt\u00e1s\u00e1ban. A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Konkurens (t\u00f6bbsz\u00e1l\u00fa) alkalmaz\u00e1sok fejleszt\u00e9se.","title":"A gyakorlat c\u00e9lja"},{"location":"labor/4-tobbszalu/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)","title":"El\u0151felt\u00e9telek"},{"location":"labor/4-tobbszalu/#bevezeto","text":"A p\u00e1rhuzamosan fut\u00f3 sz\u00e1lak kezel\u00e9se kiemelt fontoss\u00e1g\u00fa ter\u00fclet, melyet miden szoftverfejleszt\u0151nek legal\u00e1bb alapszinten ismernie kell. A gyakorlat sor\u00e1n alapszint\u0171, de kiemelt fontoss\u00e1g\u00fa probl\u00e9m\u00e1kat oldunk meg, ez\u00e9rt t\u00f6rekedn\u00fcnk kell arra, hogy ne csak a v\u00e9geredm\u00e9nyt, hanem az elv\u00e9gzett m\u00f3dos\u00edt\u00e1sok \u00e9rtelm\u00e9t \u00e9s indokait is meg\u00e9rts\u00fck. A feladat sor\u00e1n egyszer\u0171 Windows Forms alkalmaz\u00e1st fogunk felruh\u00e1zni t\u00f6bbsz\u00e1las k\u00e9pess\u00e9gekkel, egyre komplexebb feladatokat megoldva. Az alapprobl\u00e9ma a k\u00f6vetkez\u0151: van egy f\u00fcggv\u00e9ny\u00fcnk, mely hossz\u00fa ideig fut, s mint l\u00e1tni fogjuk, ennek \u201edirektben\u201d t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sa a fel\u00fcletr\u0151l kellemetlen k\u00f6vetkezm\u00e9nyekkel j\u00e1r. A megold\u00e1s sor\u00e1n egy megl\u00e9v\u0151 alkalmaz\u00e1st fogunk kieg\u00e9sz\u00edteni saj\u00e1t k\u00f3dr\u00e9szletekkel. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi.","title":"Bevezet\u0151"},{"location":"labor/4-tobbszalu/#0-feladat-ismerkedes-a-kiindulo-alkalmazassal-elokeszites","text":"Kl\u00f3nozzuk le a 4. gyakorlathoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1st repositoryj\u00e1t . Nyissunk egy command prompt-ot Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN Adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo.git Nyissuk meg SuperCalculator.sln solutiont Visual Studio-ban. A feladatunk az, hogy egy bin\u00e1ris form\u00e1ban megkapott algoritmus futtat\u00e1s\u00e1hoz Windows Forms technol\u00f3gi\u00e1val felhaszn\u00e1l\u00f3i fel\u00fcletet k\u00e9sz\u00edts\u00fcnk. A bin\u00e1ris forma .NET eset\u00e9ben egy .dll kiterjeszt\u00e9s\u0171 f\u00e1jlt jelent, ami programoz\u00f3i szemmel egy oszt\u00e1lyk\u00f6nyvt\u00e1r. A f\u00e1jl neve eset\u00fcnkben Algorithms.dll , megtal\u00e1lhat\u00f3 a lekl\u00f3nozott Git repositoryban. A kiindul\u00f3 alkalmaz\u00e1sban a felhaszn\u00e1l\u00f3i fel\u00fclet el\u0151 is van k\u00e9sz\u00edtve. Futtassuk az alkalmaz\u00e1st: Az alkalmaz\u00e1s fel\u00fclet\u00e9n meg tudjuk adni az algoritmus bemen\u0151 param\u00e9tereit ( double sz\u00e1mok t\u00f6mbje): a p\u00e9ld\u00e1nkban mindig k\u00e9t double sz\u00e1m param\u00e9terrel h\u00edvjuk az algoritmust, ezt a k\u00e9t fels\u0151 sz\u00f6vegmez\u0151ben lehet megadni. A feladatunk az, hogy a Calculate Result gombra kattint\u00e1s sor\u00e1n futtassuk az algoritmust a megadott param\u00e9terekkel, majd, ha v\u00e9gzett, akkor a Result alatti list\u00e1z\u00f3 mez\u0151 \u00faj sor\u00e1ban jelen\u00edts\u00fck meg a kapott eredm\u00e9nyt a bemen\u0151 param\u00e9terekkel egy\u00fctt. K\u00f6vetkez\u0151 l\u00e9p\u00e9sben ismerkedj\u00fcnk meg a let\u00f6lt\u00f6tt Visual Studio solutionnel: N\u00e9zz\u00fck v\u00e9gig a MainForm oszt\u00e1lyt. Az l\u00e1tjuk, hogy a fel\u00fclet alapvet\u0151en k\u00e9sz, csak az algoritmus futtat\u00e1sa hi\u00e1nyzik. Az eredm\u00e9ny \u00e9s a param\u00e9terei napl\u00f3z\u00e1s\u00e1hoz is tal\u00e1lunk egy ShowResult nev\u0171 seg\u00e9df\u00fcggv\u00e9nyt. A DataFifo oszt\u00e1lyt egyel\u0151re hagyjuk ki, csak a gyakorlat m\u00e1sodik fel\u00e9ben fogjuk haszn\u00e1lni, majd k\u00e9s\u0151bb megismerked\u00fcnk vele.","title":"0. Feladat - Ismerked\u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal, el\u0151k\u00e9sz\u00edt\u00e9s"},{"location":"labor/4-tobbszalu/#a-dll-ben-levo-kod-felhasznalasa","text":"A kiindul\u00f3 projektben megtal\u00e1ljuk a Algorithm.dll -t. Ebben leford\u00edtott form\u00e1ban egy Algorithms n\u00e9vt\u00e9rben lev\u0151 SuperAlgorithm nev\u0171 oszt\u00e1ly tal\u00e1lhat\u00f3, melynek egy Calculate nev\u0171 statikus m\u0171velete van. Ahhoz, hogy egy projektben fel tudjuk haszn\u00e1lni a DLL-ben lev\u0151 oszt\u00e1lyokat, a DLL-re a projekt\u00fcnkben egy \u00fan. referenci\u00e1t kell felvegy\u00fcnk. Solution Explorerben a projekt\u00fcnk Dependencies node-j\u00e1ra jobbklikkelve v\u00e1lasszuk az Add Project reference opci\u00f3t! K\u00fcls\u0151 referenci\u00e1k Itt val\u00f3j\u00e1ban nem egy m\u00e1sik Visual Studio projektre adunk referenci\u00e1t, de \u00edgy a legegyszer\u0171bb el\u0151hozni ezt az ablakot. Megeml\u00edtend\u0151 m\u00e9g, hogy k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1rak eset\u00e9ben m\u00e1r nem DLL-eket szoktunk refer\u00e1lni egy rendes projektben, hanem a .NET csomagkezel\u0151 rendeszer\u00e9b\u0151l a NuGet-r\u0151l szok\u00e1s a k\u00fcls\u0151 csomagokat beszerezni. Most az Algorithm.dll eset\u00fcnkben nincs NuGet-en publik\u00e1lva, ez\u00e9rt kell k\u00e9zzel felvegy\u00fck azt. Az el\u0151ugr\u00f3 ablak jobb als\u00f3 sarokban tal\u00e1lhat\u00f3 Browse gomb seg\u00edts\u00e9g\u00e9vel keress\u00fck meg \u00e9s v\u00e1lasszuk ki projekt External almapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 Algorithms.dll f\u00e1jlt, majd hagyjuk j\u00f3v\u00e1 a hozz\u00e1ad\u00e1st az OK gombbal! A Solution Explorerben egy projekt alatti Dependencies csom\u00f3pontot lenyitva l\u00e1thatjuk a hivatkozott k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket. Itt most m\u00e1r megjelenik az Assemblyk k\u00f6z\u00f6tt el\u0151bb felvett Algorithms referencia is. A Frameworks kateg\u00f3ri\u00e1ban a .NET keretrendszer csomagjait tal\u00e1ljuk. Az Analyzerek pedig statikus k\u00f3delemz\u0151 eszk\u00f6z\u00f6k ford\u00edt\u00e1s id\u0151ben. Illetve itt lenn\u00e9nek m\u00e9g a projekt vagy a NuGet referenci\u00e1k is. Kattintsunk Algorithms referenci\u00e1n jobb gombbal \u00e9s v\u00e1lasszuk a View in Object Browser funkci\u00f3t. Ekkor megny\u00edlik az Object Browser tabf\u00fcl, ahol megtekinthetj\u00fck, hogy az adott DLL-ben milyen n\u00e9vterek, oszt\u00e1lyok tal\u00e1lhat\u00f3k, illetve ezeknek milyen tagjaik (tagv\u00e1ltoz\u00f3, tagf\u00fcggv\u00e9ny, property, event) vannak. Ezeket a Visual Studio a DLL metaadataib\u00f3l az \u00fan. reflection mechanizmus seg\u00edts\u00e9g\u00e9vel olvassa ki (ilyen k\u00f3dot ak\u00e1r mi is \u00edrhatunk). Az al\u00e1bbi \u00e1br\u00e1nak megfelel\u0151en az Object Browserben baloldalt keress\u00fck ki az Algorithms csom\u00f3pontot, nyissuk le, \u00e9s l\u00e1that\u00f3v\u00e1 v\u00e1lik, hogy egy Algorithms n\u00e9vt\u00e9r van benne, abban pedig egy SuperAlgorithm oszt\u00e1ly. Ezt kiv\u00e1lasztva k\u00f6z\u00e9pen megjelennek az oszt\u00e1ly f\u00fcggv\u00e9nyei, itt egy f\u00fcggv\u00e9nyt kiv\u00e1lasztva pedig az adott f\u00fcggv\u00e9ny pontos szignat\u00far\u00e1ja:","title":"A DLL-ben lev\u0151 k\u00f3d felhaszn\u00e1l\u00e1sa"},{"location":"labor/4-tobbszalu/#1-feladat-muvelet-futtatasa-a-foszalon","text":"Most m\u00e1r r\u00e1t\u00e9rhet\u00fcnk az algoritmus futtat\u00e1s\u00e1ra. Els\u0151 l\u00e9p\u00e9sben ezt az alkalmaz\u00e1sunk f\u0151 sz\u00e1l\u00e1n tessz\u00fck meg. A f\u0151ablakon l\u00e9v\u0151 gomb Click esem\u00e9nykezel\u0151j\u00e9ben h\u00edvjuk meg a sz\u00e1mol\u00f3 f\u00fcggv\u00e9ny\u00fcnket. Ehhez kattintsunk a Solution Explorerben dupl\u00e1n a MainForm.cs f\u00e1jlra, majd a megjelen\u0151 Form Designer-ben a Calculate Result gombra. Eg\u00e9sz\u00edts\u00fck ki a k\u00f3dot az \u00fajonnan behivatkozott algoritmus megh\u00edv\u00e1s\u00e1val. private void buttonCalcResult_Click ( object sender , EventArgs e ) { if ( double . TryParse ( textBoxParam1 . Text , out var p1 ) && double . TryParse ( textBoxParam2 . Text , out var p2 )) { var parameters = new double [] { p1 , p2 }; var result = Algorithms . SuperAlgorithm . Calculate ( parameters ); ShowResult ( parameters , result ); } else { MessageBox . Show ( this , \"Invalid parameter!\" , \"Error\" ); } } Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az ablak a sz\u00e1mol\u00e1s ideje alatt nem reag\u00e1l a mozgat\u00e1sra, \u00e1tm\u00e9retez\u00e9sre, a fel\u00fclet gyakorlatilag befagy. Az alkalmaz\u00e1sunk esem\u00e9nyvez\u00e9relt, mint minden Windows alkalmaz\u00e1s. Az oper\u00e1ci\u00f3s rendszer a k\u00fcl\u00f6nb\u00f6z\u0151 interakci\u00f3kr\u00f3l (pl. mozgat\u00e1s, \u00e1tm\u00e9retez\u00e9s) \u00fczenetekben \u00e9rtes\u00edti az alkalmaz\u00e1sunkat. Mivel a gombnyom\u00e1st k\u00f6vet\u0151en az alkalmaz\u00e1sunk egyetlen sz\u00e1la a kalkul\u00e1ci\u00f3val van elfoglalva, nem tudja azonnal feldolgozni a tov\u00e1bbi felhaszn\u00e1l\u00f3i utas\u00edt\u00e1sokat. Amint a sz\u00e1m\u00edt\u00e1s lefutott (\u00e9s az eredm\u00e9nyek megjelennek a list\u00e1ban) a kor\u00e1bban kapott parancsok is v\u00e9grehajt\u00e1sra ker\u00fclnek.","title":"1. Feladat \u2013 M\u0171velet futtat\u00e1sa a f\u0151sz\u00e1lon"},{"location":"labor/4-tobbszalu/#2-feladat-vegezzuk-a-szamitast-kulon-szalban","text":"K\u00f6vetkez\u0151 l\u00e9p\u00e9sben a sz\u00e1m\u00edt\u00e1s elv\u00e9gz\u00e9s\u00e9re egy k\u00fcl\u00f6n sz\u00e1lat fogunk ind\u00edtani, hogy az ne blokkolja a felhaszn\u00e1l\u00f3i fel\u00fcletet. K\u00e9sz\u00edts\u00fcnk egy \u00faj f\u00fcggv\u00e9nyt a MainForm oszt\u00e1lyban, mely a feldolgoz\u00f3 sz\u00e1l bel\u00e9p\u00e9si pontja lesz. private void CalculatorThread ( object arg ) { var parameters = ( double []) arg ; var result = Algorithms . SuperAlgorithm . Calculate ( parameters ); ShowResult ( parameters , result ); } Ind\u00edtsuk el a sz\u00e1lat a gomb Click esem\u00e9nykezel\u0151j\u00e9ben. Ehhez cser\u00e9lj\u00fck le a kor\u00e1bban hozz\u00e1adott k\u00f3dot: private void buttonCalcResult_Click ( object sender , EventArgs e ) { if ( double . TryParse ( textBoxParam1 . Text , out var p1 ) && double . TryParse ( textBoxParam2 . Text , out var p2 )) { var parameters = new double [] { p1 , p2 }; var th = new Thread ( CalculatorThread ); th . Start ( parameters ); } else { MessageBox . Show ( this , \"Invalid parameter!\" , \"Error\" ); } } A Thread objektum Start m\u0171velet\u00e9ben \u00e1tadott param\u00e9tert kapja meg a CalculatorThread sz\u00e1lf\u00fcggv\u00e9ny\u00fcnk. Futtassuk az alkalmaz\u00e1st F5-tel (most fontos, hogy \u00edgy, a debuggerben futtassuk)! InvalidOperationException, Cross-thread operation not valid hiba\u00fczenetet kapunk a ShowResult met\u00f3dusban, ugyanis nem abb\u00f3l a sz\u00e1lb\u00f3l pr\u00f3b\u00e1lunk hozz\u00e1f\u00e9rni a UI elemhez / vez\u00e9rl\u0151h\u00f6z, amelyik l\u00e9trehozta (a vez\u00e9rl\u0151t). A k\u00f6vetkez\u0151 feladatban ezt a probl\u00e9m\u00e1t analiz\u00e1ljuk \u00e9s oldjuk meg.","title":"2. Feladat \u2013 V\u00e9gezz\u00fck a sz\u00e1m\u00edt\u00e1st k\u00fcl\u00f6n sz\u00e1lban"},{"location":"labor/4-tobbszalu/#3-feladat-az-invoke-es-invokerequired-hasznalata","text":"Az el\u0151z\u0151 pontban a probl\u00e9m\u00e1t a k\u00f6vetkez\u0151 okozza. Windows Forms alkalmaz\u00e1sokn\u00e1l \u00e9l az al\u00e1bbi szab\u00e1ly: az \u0171rlapok/vez\u00e9rl\u0151elemek alapvet\u0151en nem sz\u00e1lv\u00e9dett objektumok, \u00edgy egy \u0171rlaphoz/vez\u00e9rl\u0151h\u00f6z csak abb\u00f3l a sz\u00e1lb\u00f3l szabad hozz\u00e1f\u00e9rni (pl. propertyj\u00e9t olvasni, \u00e1ll\u00edtani, m\u0171velet\u00e9t megh\u00edvni), amelyik sz\u00e1l az adott \u0171rlapot/vez\u00e9rl\u0151t l\u00e9trehozta , m\u00e1sk\u00fcl\u00f6nben kiv\u00e9telt kapunk. Alkalmaz\u00e1sunkban az\u00e9rt kaptunk kiv\u00e9telt, mert a listViewResult vez\u00e9rl\u0151t a f\u0151 sz\u00e1lban hoztuk l\u00e9tre, a ShowResult met\u00f3dusban az eredm\u00e9ny megjelen\u00edt\u00e9sekor viszont egy m\u00e1sik sz\u00e1lb\u00f3l f\u00e9r\u00fcnk hozz\u00e1 ( listViewResult.Items.Add ). A fenti szab\u00e1ly al\u00f3l van p\u00e1r kiv\u00e9tel: ilyen pl. a Control oszt\u00e1lyban defini\u00e1lt InvokeRequired property \u00e9s Invoke met\u00f3dus, melyek b\u00e1rmely sz\u00e1lb\u00f3l biztons\u00e1gosan el\u00e9rhet\u0151k. Ezek pont abban ny\u00fajtanak seg\u00edts\u00e9get, hogy a vez\u00e9rl\u0151kh\u00f6z mindig a megfelel\u0151 sz\u00e1lb\u00f3l f\u00e9rj\u00fcnk hozz\u00e1: Ha az InvokeRequired tulajdons\u00e1g \u00e9rt\u00e9ke igaz, akkor a sz\u00e1l (mely az InvokeRequired -et h\u00edvja) a h\u00edv\u00e1s hely\u00e9n nem egyezik a vez\u00e9rl\u0151t l\u00e9trehoz\u00f3 sz\u00e1llal, \u00e9s ilyenkor csak az Invoke m\u0171velet seg\u00edts\u00e9g\u00e9vel \"ker\u00fcl\u0151 \u00faton\" f\u00e9rhet\u00fcnk vez\u00e9rl\u0151nkh\u00f6z. Vagyis egy vez\u00e9rl\u0151h\u00f6z val\u00f3 hozz\u00e1f\u00e9r\u00e9s sor\u00e1n ezzel tudjuk eld\u00f6nteni, k\u00f6zvetlen\u00fcl hozz\u00e1f\u00e9rhet\u00fcnk-e egy adott helyen a sz\u00e1lunkb\u00f3l, vagy csak az Invoke seg\u00edts\u00e9g\u00e9vel. Az Invoke met\u00f3dus a vez\u00e9rl\u0151elemet l\u00e9trehoz\u00f3 sz\u00e1lon futtatja le a sz\u00e1m\u00e1ra param\u00e9terk\u00e9nt megadott met\u00f3dust (melyb\u0151l m\u00e1r k\u00f6zvetlen\u00fcl hozz\u00e1f\u00e9rhet\u00fcnk a vez\u00e9rl\u0151h\u00f6z). Az InvokeRequired \u00e9s az Invoke felhaszn\u00e1l\u00e1s\u00e1val el tudjuk ker\u00fclni kor\u00e1bbi kiv\u00e9tel\u00fcnket (a vez\u00e9rl\u0151h\u00f6z, eset\u00fcnkben a listViewResult-hoz val\u00f3 hozz\u00e1f\u00e9r\u00e9st a megfelel\u0151 sz\u00e1lra tudjuk \"ir\u00e1ny\u00edtani\"). Ezt fogjuk a k\u00f6vetkez\u0151kben megtenni. Csak debuggerben futtatva j\u00f6n az InvalidOperationException ? Ha kipr\u00f3b\u00e1ln\u00e1nk, hogy debugger n\u00e9lk\u00fcl ind\u00edtjuk el az alkalmaz\u00e1st (VS-ben Start without debugging vagy mag\u00e1t az exe-t), akkor azt tapasztaln\u00e1nk, hogy nem j\u00f6n a fenti kiv\u00e9tel. Ennek az az oka, hogy, fejleszt\u00e9s id\u0151ben, debuggerrel vizsg\u00e1lva az alkalmaz\u00e1st, sokkal szigor\u00fabban figyeli a keretrendszer a UI sz\u00e1l s\u00e9rt\u00e9st, hogy m\u00e1r fejleszt\u00e9s id\u0151ben el\u0151j\u00f6jjenek olyan potenci\u00e1lis hib\u00e1k, melyek am\u00fagy m\u00e9g nem jelenten\u00e9k az alkalmaz\u00e1s \u00f6sszeoml\u00e1s\u00e1t. A fenti esetben a ListView Invoke n\u00e9lk\u00fcli manipul\u00e1l\u00e1s\u00e1t j\u00f3 es\u00e9llyel az esetek t\u00f6bbs\u00e9g\u00e9ben m\u00e9g t\u00fal\u00e9ln\u00e9 az app, de a keretrendszer a debuggeren kereszt\u00fcl futtat\u00e1s sor\u00e1n jelzi a hib\u00e1s gyakorlatot. M\u00f3dos\u00edtanunk kell a ShowResult met\u00f3dust annak \u00e9rdek\u00e9ben, hogy mell\u00e9ksz\u00e1lb\u00f3l t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1s eset\u00e9n se dobjon kiv\u00e9telt. private void ShowResult ( double [] parameters , double result ) { if ( InvokeRequired ) { Invoke ( ShowResult , new object [] { parameters , result }); } else if (! IsDisposed ) { var lvi = listViewResult . Items . Add ( $\"{parameters[0]} # {parameters[1]} = {result}\" ); listViewResult . EnsureVisible ( lvi . Index ); listViewResult . AutoResizeColumns ( ColumnHeaderAutoResizeStyle . ColumnContent ); } } Pr\u00f3b\u00e1ljuk ki! Ez a megold\u00e1s m\u00e1r m\u0171k\u00f6d\u0151k\u00e9pes. A Form oszt\u00e1ly InvokeRequired met\u00f3dusa igazat ad vissza, amennyiben nem az \u0151t l\u00e9trehoz\u00f3 sz\u00e1lb\u00f3l h\u00edvjuk meg. Ilyen esetekben a Form ot az Invoke met\u00f3dus\u00e1n kereszt\u00fcl tudjuk megk\u00e9rni, hogy egy adott m\u0171veletet a saj\u00e1t sz\u00e1l\u00e1n (amelyik a Form ot l\u00e9trehozta, ez a legt\u00f6bb alkalmaz\u00e1sban a f\u0151 sz\u00e1l) hajtson v\u00e9gre. A fenti p\u00e9ld\u00e1ban tulajdonk\u00e9ppen a ShowResult f\u00fcggv\u00e9ny \u00f6nmag\u00e1t h\u00edvja meg m\u00e9g egyszer, csak m\u00e1sodik esetben m\u00e1r a Form saj\u00e1t sz\u00e1l\u00e1n. Ez egy bevett minta a redund\u00e1ns k\u00f3dok elker\u00fcl\u00e9s\u00e9re. Tegy\u00fcnk t\u00f6r\u00e9spontot a ShowResult m\u0171velet els\u0151 sor\u00e1ra, \u00e9s az alkalmaz\u00e1st futtatva gy\u0151z\u0151dj\u00fcnk meg, hogy a ShowResult m\u0171velet \u2013 k\u00fcl\u00f6n\u00f6sen az Invoke tekintet\u00e9ben \u2013 a fentiekben ismertetetteknek megfelel\u0151en m\u0171k\u00f6dik. Vegy\u00fck ki a t\u00f6r\u00e9spontot, \u00edgy futtassuk az alkalmaz\u00e1st: vegy\u00fck \u00e9szre, hogy am\u00edg egy sz\u00e1m\u00edt\u00e1s fut, \u00fajabbakat is ind\u00edthatunk, hiszen a fel\u00fclet\u00fcnk v\u00e9gig reszponz\u00edv maradt.","title":"3. Feladat \u2013 az Invoke \u00e9s InvokeRequired haszn\u00e1lata"},{"location":"labor/4-tobbszalu/#4-feladat-muvelet-vegzese-threadpool-szalon","text":"Az el\u0151z\u0151 megold\u00e1s egy jellemz\u0151je, hogy mindig \u00faj sz\u00e1lat hoz l\u00e9tre a m\u0171velethez. Eset\u00fcnkben ennek nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge, de ez a megk\u00f6zel\u00edt\u00e9s egy olyan kiszolg\u00e1l\u00f3 alkalmaz\u00e1s eset\u00e9ben, amely nagysz\u00e1m\u00fa k\u00e9r\u00e9st szolg\u00e1l ki \u00fagy, hogy minden k\u00e9r\u00e9shez k\u00fcl\u00f6n sz\u00e1lat ind\u00edt, m\u00e1r probl\u00e9m\u00e1s lehet. K\u00e9t okb\u00f3l is: Ha a sz\u00e1lf\u00fcggv\u00e9ny gyorsan lefut (egy kliens kiszolg\u00e1l\u00e1sa gyors), akkor a CPU nagy r\u00e9sz\u00e9t arra pazaroljuk, hogy sz\u00e1lakat ind\u00edtsunk \u00e9s \u00e1ll\u00edtsunk le, ezek ugyanis \u00f6nmagukban is er\u0151forr\u00e1sig\u00e9nyesek. T\u00fal nagy sz\u00e1m\u00fa sz\u00e1l is l\u00e9trej\u00f6het, ennyit kell \u00fctemeznie az oper\u00e1ci\u00f3s rendszernek, ami feleslegesen pazarolja az er\u0151forr\u00e1sokat. Egy m\u00e1sik probl\u00e9ma jelen megold\u00e1sunkkal: mivel a sz\u00e1m\u00edt\u00e1s \u00fan. el\u0151t\u00e9rsz\u00e1lon fut (az \u00fajonnan l\u00e9trehozott sz\u00e1lak alap\u00e9rtelmez\u00e9sben el\u0151t\u00e9rsz\u00e1lak), hi\u00e1ba z\u00e1rjuk be az alkalmaz\u00e1st, a program tov\u00e1bb fut a h\u00e1tt\u00e9rben mindaddig, am\u00edg v\u00e9gre nem hajt\u00f3dik az utolj\u00e1ra ind\u00edtott sz\u00e1mol\u00e1s is: egy processz fut\u00e1sa ugyanis csak akkor fejez\u0151dik csak be, ha m\u00e1r nincs fut\u00f3 el\u0151t\u00e9rsz\u00e1la. M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy \u00faj sz\u00e1l ind\u00edt\u00e1sa helyett threadpool sz\u00e1lon futtassa a sz\u00e1m\u00edt\u00e1st. Ehhez csak a gombnyom\u00e1s esem\u00e9nykezel\u0151j\u00e9t kell ism\u00e9t \u00e1t\u00edrni. private void buttonCalcResult_Click ( object sender , EventArgs e ) { if ( double . TryParse ( textBoxParam1 . Text , out var p1 ) && double . TryParse ( textBoxParam2 . Text , out var p2 )) { var parameters = new double [] { p1 , p2 }; ThreadPool . QueueUserWorkItem ( CalculatorThread , parameters ); } else { MessageBox . Show ( this , \"Invalid parameter!\" , \"Error\" ); } } Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az alkalmaz\u00e1s az ablak bez\u00e1r\u00e1sakor azonnal le\u00e1ll, nem foglalkozik az esetlegesen m\u00e9g fut\u00f3 sz\u00e1lakkal (mert a threadpool sz\u00e1lak h\u00e1tt\u00e9r sz\u00e1lak).","title":"4. feladat \u2013 M\u0171velet v\u00e9gz\u00e9se Threadpool sz\u00e1lon"},{"location":"labor/4-tobbszalu/#5-feladat-termelo-fogyaszto-alapu-megoldas","text":"Az el\u0151z\u0151 feladatok megold\u00e1sa sor\u00e1n \u00f6nmag\u00e1ban egy j\u00f3l m\u0171k\u00f6d\u0151 komplett megold\u00e1s\u00e1t kaptuk az eredeti probl\u00e9m\u00e1nak, mely lehet\u0151v\u00e9 teszi, hogy ak\u00e1r t\u00f6bb munkasz\u00e1l is p\u00e1rhuzamosan dolgozzon a h\u00e1tt\u00e9rben a sz\u00e1m\u00edt\u00e1son, ha a gombot sokszor egym\u00e1s ut\u00e1n megnyomjuk. A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1sunkat, hogy a gombnyom\u00e1sra ne mindig keletkezzen \u00faj sz\u00e1l, hanem a feladatok beker\u00fcljenek egy feladatsorba, ahonnan t\u00f6bb, a h\u00e1tt\u00e9rben folyamatosan fut\u00f3 sz\u00e1l egym\u00e1s ut\u00e1n fogja kivenni \u0151ket \u00e9s v\u00e9grehajtani. Ez a feladat a klasszikus termel\u0151-fogyaszt\u00f3 probl\u00e9ma, mely a gyakorlatban is sokszor el\u0151fordul, a m\u0171k\u00f6d\u00e9s\u00e9t az al\u00e1bbi \u00e1bra szeml\u00e9lteti. Termel\u0151 fogyaszt\u00f3 vs ThreadPool Ha belegondolunk, a ThreadPool is egy speci\u00e1lis, a .NET \u00e1ltal sz\u00e1munkra biztos\u00edtott termel\u0151-fogyaszt\u00f3 \u00e9s \u00fctemez\u0151 mechanizmus. A k\u00f6vetkez\u0151kben egy m\u00e1s jelleg\u0171 termel\u0151-fogyaszt\u00f3 megold\u00e1st dolgozunk ki annak \u00e9rdek\u00e9ben, hogy bizonyos sz\u00e1lkezel\u00e9ssel kapcsolatos konkurencia probl\u00e9m\u00e1kkal tal\u00e1lkozhassunk. A f\u0151sz\u00e1lunk a termel\u0151, a Calculate result gombra kattintva hoz l\u00e9tre egy \u00faj feladatot. Fogyaszt\u00f3/feldolgoz\u00f3/munkasz\u00e1lb\u00f3l az\u00e9rt ind\u00edtunk majd t\u00f6bbet, mert \u00edgy t\u00f6bb CPU magot is ki tudunk haszn\u00e1lni, valamint a feladatok v\u00e9grehajt\u00e1s\u00e1t p\u00e1rhuzamos\u00edtani tudjuk. A feladatok ideiglenes t\u00e1rol\u00e1s\u00e1ra a kiindul\u00f3 projekt\u00fcnkben m\u00e1r n\u00e9mik\u00e9ppen el\u0151k\u00e9sz\u00edtett DataFifo oszt\u00e1lyt tudjuk haszn\u00e1lni. N\u00e9zz\u00fck meg a forr\u00e1sk\u00f3dj\u00e1t. Egy egyszer\u0171 FIFO sort val\u00f3s\u00edt meg, melyben double[] elemeket t\u00e1rol. A Put met\u00f3dus hozz\u00e1f\u0171zi a bels\u0151 lista v\u00e9g\u00e9hez az \u00faj p\u00e1rokat, m\u00edg a TryGet met\u00f3dus visszaadja (\u00e9s elt\u00e1vol\u00edtja) a bels\u0151 lista els\u0151 elem\u00e9t. Amennyiben a lista \u00fcres, a f\u00fcggv\u00e9ny nem tud visszaadni elemet. Ilyenkor a false visszat\u00e9r\u00e9si \u00e9rt\u00e9kkel jelzi ezt. M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy ne ThreadPool ba dolgozzon, hanem a FIFO-ba: private void buttonCalcResult_Click ( object sender , EventArgs e ) { if ( double . TryParse ( textBoxParam1 . Text , out var p1 ) && double . TryParse ( textBoxParam2 . Text , out var p2 )) { var parameters = new double [] { p1 , p2 }; _fifo . Put ( parameters ); } else { MessageBox . Show ( this , \"Invalid parameter!\" , \"Error\" ); } } K\u00e9sz\u00edts\u00fck el az \u00faj sz\u00e1lkezel\u0151 f\u00fcggv\u00e9ny na\u00edv implement\u00e1ci\u00f3j\u00e1t az \u0171rlap oszt\u00e1lyunkban: private void WorkerThread () { while ( true ) { if ( _fifo . TryGet ( out var data )) { double result = Algorithms . SuperAlgorithm . Calculate ( data ); ShowResult ( data , result ); } Thread . Sleep ( 500 ); } } A Thread.Sleep bevezet\u00e9s\u00e9re az\u00e9rt van sz\u00fcks\u00e9g, mert e n\u00e9lk\u00fcl a munkasz\u00e1lak \u00fcres FIFO eset\u00e9n folyamatosan feleslegesen p\u00f6r\u00f6gn\u00e9nek, semmi hasznos m\u0171veletet nem v\u00e9gezve is 100%-ban kiterheln\u00e9nek egy-egy CPU magot. Megold\u00e1sunk nem ide\u00e1lis, k\u00e9s\u0151bb tov\u00e1bbfejlesztj\u00fck. Hozzuk l\u00e9tre, \u00e9s ind\u00edtsuk el a feldolgoz\u00f3 sz\u00e1lakat a konstruktorban: new Thread ( WorkerThread ) { Name = \"Szal1\" }. Start (); new Thread ( WorkerThread ) { Name = \"Szal2\" }. Start (); new Thread ( WorkerThread ) { Name = \"Szal3\" }. Start (); Ind\u00edtsuk el az alkalmaz\u00e1st, majd z\u00e1rjuk is be azonnal an\u00e9lk\u00fcl, hogy a Calculate Result gombra kattintan\u00e1nk. Az tapasztaljuk, hogy az ablakunk bez\u00e1r\u00f3dik ugyan, de a processz\u00fcnk tov\u00e1bb fut, az alkalmaz\u00e1s bez\u00e1r\u00e1s\u00e1ra csak a Visual Studiob\u00f3l, vagy a Task Managerb\u0151l van lehet\u0151s\u00e9g: A feldolgoz\u00f3 sz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9p\u00e9skor megakad\u00e1lyozz\u00e1k a processz megsz\u0171n\u00e9s\u00e9t. Az egyik megold\u00e1s az lehetne, ha a sz\u00e1lak IsBackground tulajdons\u00e1g\u00e1t true -ra \u00e1ll\u00edtan\u00e1nk a l\u00e9trehoz\u00e1sukat k\u00f6vet\u0151en. A m\u00e1sik megold\u00e1s, hogy kil\u00e9p\u00e9skor gondoskodunk a feldolgoz\u00f3 sz\u00e1lak kil\u00e9ptet\u00e9s\u00e9r\u0151l. Egyel\u0151re tegy\u00fck f\u00e9lre ezt a probl\u00e9m\u00e1t, k\u00e9s\u0151bb visszat\u00e9r\u00fcnk r\u00e1. Ind\u00edtsuk el az alkalmaz\u00e1st azt tapasztaljuk, hogy miut\u00e1n kattintunk a Calculate Result gombon (csak egyszer kattintsunk rajta) nagy val\u00f3sz\u00edn\u0171s\u00e9ggel kiv\u00e9telt fogunk kapni. A probl\u00e9ma az, hogy a DataFifo nem sz\u00e1lbiztos, inkonzisztens\u00e9 v\u00e1lt. K\u00e9t ered\u0151 ok is h\u00faz\u00f3dik a h\u00e1tt\u00e9rben:","title":"5. Feladat \u2013 Termel\u0151-fogyaszt\u00f3 alap\u00fa megold\u00e1s"},{"location":"labor/4-tobbszalu/#problema-1","text":"N\u00e9zz\u00fck a k\u00f6vetkez\u0151 forgat\u00f3k\u00f6nyvet: A sor \u00fcres. A feldolgoz\u00f3 sz\u00e1lak egy while ciklusban folyamatosan pollozz\u00e1k a FIFO-t, vagyis h\u00edvj\u00e1k a TryGet met\u00f3dus\u00e1t. A felhaszn\u00e1l\u00f3 egy feladatot tesz a sorba. Az egyik feldolgoz\u00f3 sz\u00e1l a TryGet met\u00f3dusban azt l\u00e1tja, van adat a sorban, vagyis if ( _innerList.Count > 0 ) k\u00f3dsor felt\u00e9tele teljes\u00fcl, \u00e9s r\u00e1l\u00e9p a k\u00f6vetkez\u0151 k\u00f3dsorra. Tegy\u00fck fel, hogy ez a sz\u00e1l ebben a pillanatban elveszti a fut\u00e1si jog\u00e1t, m\u00e1r nincs ideje kivenni az adatot a sorb\u00f3l. Egy m\u00e1sik feldolgoz\u00f3 sz\u00e1l is \u00e9ppen ekkor ejti meg az if ( _innerList.Count > 0 ) vizsg\u00e1latot, n\u00e1la is teljes\u00fcl a felt\u00e9tel, \u00e9s ez a sz\u00e1l ki is veszi az adatot a sorb\u00f3l. Az els\u0151 sz\u00e1lunk \u00fajra \u00fctemez\u00e9sre ker\u00fcl, fel\u00e9bred, \u0151 is megpr\u00f3b\u00e1lja kivenni az adatot a sorb\u00f3l: a sor viszont m\u00e1r \u00fcres, a m\u00e1sik sz\u00e1lunk kivette az egyetlen adatot a sorb\u00f3l az orra el\u0151tt. \u00cdgy az _innerList[0] hozz\u00e1f\u00e9r\u00e9s kiv\u00e9telt eredm\u00e9nyez. Ezt a probl\u00e9m\u00e1t csak \u00fagy tudjuk elker\u00fclni, ha a sor \u00fcress\u00e9g\u00e9nek a vizsg\u00e1lat\u00e1t \u00e9s az elem kiv\u00e9tel\u00e9t oszthatatlann\u00e1 tessz\u00fck. Thread.Sleep(500) Az \u00fcress\u00e9gvizsg\u00e1latot figyel\u0151 k\u00f3dsort k\u00f6vet\u0151 Thread.Sleep(500); k\u00f3dsornak csak az a szerepe a p\u00e9ldak\u00f3dunkban, hogy a fenti peches forgat\u00f3k\u00f6nyv bek\u00f6vetkez\u00e9s\u00e9nek a val\u00f3sz\u00edn\u0171s\u00e9g\u00e9t megn\u00f6velje, s \u00edgy a p\u00e9ld\u00e1t szeml\u00e9letesebb\u00e9 tegye (mivel ilyenkor szinte biztos, hogy \u00e1t\u00fctemez\u0151dik a sz\u00e1l). A k\u00e9s\u0151bbiekben ezt ki is fogjuk venni, egyel\u0151re hagyjuk benne.","title":"Probl\u00e9ma 1"},{"location":"labor/4-tobbszalu/#problema-2","text":"A DataFifo oszt\u00e1ly egyid\u0151ben t\u00f6bb sz\u00e1lb\u00f3l is hozz\u00e1f\u00e9rhet a List<double[]> t\u00edpus\u00fa _innerList tagv\u00e1ltoz\u00f3hoz. Ugyanakkor, ha megn\u00e9zz\u00fck a List<T> dokument\u00e1ci\u00f3j\u00e1t, azt tal\u00e1ljuk, hogy az oszt\u00e1ly nem sz\u00e1lbiztos (not thread safe). Ez esetben viszont ez nem tehetj\u00fck meg, nek\u00fcnk kell z\u00e1rakkal biztos\u00edtanunk, hogy a k\u00f3dunk egyid\u0151ben csak egy met\u00f3dus\u00e1hoz / tulajdons\u00e1g\u00e1hoz / tagv\u00e1ltoz\u00f3j\u00e1hoz f\u00e9r hozz\u00e1 (pontosabban inkonzisztencia csak egyidej\u0171 \u00edr\u00e1s, illetve egyidej\u0171 \u00edr\u00e1s \u00e9s olvas\u00e1s eset\u00e9n l\u00e9phet fel, de az \u00edr\u00f3kat \u00e9s az olvas\u00f3kat a legt\u00f6bb esetben nem szoktuk megk\u00fcl\u00f6nb\u00f6ztetni, itt sem tessz\u00fck). A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a DataFifo oszt\u00e1lyunkat sz\u00e1lbiztoss\u00e1 tessz\u00fck, amivel megakad\u00e1lyozzuk, hogy a fenti k\u00e9t probl\u00e9ma bek\u00f6vetkezhessen.","title":"Probl\u00e9ma 2"},{"location":"labor/4-tobbszalu/#6-feladat-tegyuk-szabiztossa-a-datafifo-osztalyt","text":"A DataFifo oszt\u00e1ly sz\u00e1lbiztoss\u00e1 t\u00e9tel\u00e9hez sz\u00fcks\u00e9g\u00fcnk van egy objektumra (ez b\u00e1rmilyen referencia t\u00edpus\u00fa objektum lehet), melyet kulcsk\u00e9nt haszn\u00e1lhatunk a z\u00e1rol\u00e1sn\u00e1l. Ezt k\u00f6vet\u0151en a lock kulcssz\u00f3 seg\u00edts\u00e9g\u00e9vel el tudjuk \u00e9rni, hogy egyszerre mindig csak egy sz\u00e1l tart\u00f3zkodjon az adott kulccsal v\u00e9dett blokkokban. Vegy\u00fcnk fel egy object t\u00edpus\u00fa mez\u0151t _syncRoot n\u00e9ven a DataFifo oszt\u00e1lyba. private object _syncRoot = new object (); Eg\u00e9sz\u00edts\u00fck ki a Put \u00e9s a TryGet f\u00fcggv\u00e9nyeket a z\u00e1rol\u00e1ssal. public void Put ( double [] data ) { lock ( _syncRoot ) { _innerList . Add ( data ); } } public bool TryGet ( out double [] data ) { lock ( _syncRoot ) { if ( _innerList . Count > 0 ) { Thread . Sleep ( 500 ); data = _innerList [ 0 ]; _innerList . RemoveAt ( 0 ); return true ; } data = null ; return false ; } } Surround with Haszn\u00e1ljuk a Visual Studio Surround with funkci\u00f3j\u00e1t a CTRL + K, CTRL + S billenty\u0171 kombin\u00e1ci\u00f3j\u00e1val a k\u00f6r\u00fclvenni k\u00edv\u00e1nt kijel\u00f6lt k\u00f3dr\u00e9szleten. Most m\u00e1r nem szabad kiv\u00e9telt kapnunk. Ki is vehetj\u00fck a TryGet met\u00f3dusb\u00f3l a mesters\u00e9ges k\u00e9sleltet\u00e9st ( Thread.Sleep(500); sor). Lockol\u00e1s this -en Felmer\u00fclhet a k\u00e9rd\u00e9s, hogy mi\u00e9rt vezett\u00fcnk be egy k\u00fcl\u00f6n _syncRoot tagv\u00e1ltoz\u00f3t \u00e9s haszn\u00e1ltuk ezt z\u00e1rol\u00e1sra a lock param\u00e9terek\u00e9nt, amikor a this -t is haszn\u00e1lhattuk volna helyette (a DataFifo referencia t\u00edpus, \u00edgy ennek nem lenne akad\u00e1lya). A this alkalmaz\u00e1sa azonban s\u00e9rten\u00e9 az oszt\u00e1lyunk egys\u00e9gbez\u00e1r\u00e1s\u00e1t ! Ne feledj\u00fck: a this egy referencia az objektumunkra, de m\u00e1s oszt\u00e1lyoknak is van ugyanerre az objektumra referenci\u00e1juk (pl. eset\u00fcnkben a MainForm -nak van referenci\u00e1ja a DataFifo -ra), \u00e9s ha ezek a k\u00fcls\u0151 oszt\u00e1lyok z\u00e1rat tesznek a lock seg\u00edts\u00e9g\u00e9vel az objektumra, akkor az \"interfer\u00e1l\" az \u00e1ltalunk az oszt\u00e1lyon bel\u00fck haszn\u00e1lt z\u00e1rol\u00e1ssal (mivel this alkalmaz\u00e1sa miatt a k\u00fcls\u0151 \u00e9s bels\u0151 lock -ok param\u00e9tere ugyanaz lesz). \u00cdgy pl. egy k\u00fcls\u0151 z\u00e1rral teljesen meg lehet \"b\u00e9n\u00edtani\" a TryGet \u00e9s Put m\u0171velet m\u0171k\u00f6d\u00e9s\u00e9t. Ezzel szemben az \u00e1ltalunk v\u00e1lasztott megold\u00e1sban a lock param\u00e9tere, a _syncRoot v\u00e1ltoz\u00f3 priv\u00e1t, ehhez m\u00e1r k\u00fcls\u0151 oszt\u00e1lyok nem f\u00e9rhetnek hozz\u00e1, \u00edgy nem is zavarhatj\u00e1k meg az oszt\u00e1lyunk bels\u0151 m\u0171k\u00f6d\u00e9s\u00e9t.","title":"6. feladat \u2013 Tegy\u00fck sz\u00e1biztoss\u00e1 a DataFifo oszt\u00e1lyt"},{"location":"labor/4-tobbszalu/#7-feladat-hatekony-jelzes-megvalositasa","text":"","title":"7. feladat \u2013 Hat\u00e9kony jelz\u00e9s megval\u00f3s\u00edt\u00e1sa"},{"location":"labor/4-tobbszalu/#manualresetevent-hasznalata","text":"A WorkerThread -ben folyamatosan fut\u00f3 while ciklus \u00fan. akt\u00edv v\u00e1rakoz\u00e1st val\u00f3s\u00edt meg, ami mindig ker\u00fclend\u0151. Ha a Thread.Sleep -et nem tett\u00fck volna a ciklusmagba, akkor ezzel maximumra ki is terheln\u00e9 a processzort. A Thread.Sleep megoldja ugyan a processzor terhel\u00e9s probl\u00e9m\u00e1t, de bevezet egy m\u00e1sikat: ha mindh\u00e1rom munkasz\u00e1lunk \u00e9ppen alv\u00f3 \u00e1llapotba l\u00e9pett, mikor be\u00e9rkezik egy \u00faj adat, akkor feleslegesen v\u00e1runk 500 ms-ot az adat feldolgoz\u00e1s\u00e1nak megkezd\u00e9s\u00e9ig. A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1st, hogy blokkolva v\u00e1rakozzon, am\u00edg adat nem ker\u00fcl a FIFO-ba (amikor viszont adat ker\u00fcl bele, azonnal kezdje meg a feldolgoz\u00e1st). Annak jelz\u00e9s\u00e9re, hogy van-e adat a sorban egy ManualResetEvent -et fogunk haszn\u00e1lni. Adjunk hozz\u00e1 egy MaunalResetEvent p\u00e9ld\u00e1nyt a DataFifo oszt\u00e1lyunkhoz _hasData n\u00e9ven. // A false konstruktor param\u00e9ter eredm\u00e9nyek\u00e9ppen kezdetben az esem\u00e9ny nem jelzett (kapu csukva) private ManualResetEvent _hasData = new ManualResetEvent ( false ); A _hasData alkalmaz\u00e1sunkban kapuk\u00e9nt viselkedik. Amikor adat ker\u00fcl a list\u00e1ba \u201ekinyitjuk\u201d, m\u00edg amikor ki\u00fcr\u00fcl a lista \u201ebez\u00e1rjuk\u201d. Az esem\u00e9ny szemantik\u00e1ja \u00e9s elnevez\u00e9se L\u00e9nyeges, hogy j\u00f3 v\u00e1lasszuk meg az esem\u00e9ny\u00fcnk szemantik\u00e1j\u00e1t \u00e9s ezt a v\u00e1ltoz\u00f3nk nev\u00e9vel pontosan ki is fejezz\u00fck. A p\u00e9ld\u00e1nkban a _hasData n\u00e9v j\u00f3l kifejezi, hogy pontosan akkor \u00e9s csak akkor jelzett az esem\u00e9ny\u00fcnk (nyitott a kapu), amikor van feldolgozand\u00f3 adat. Most m\u00e1r \"csak\" az a dolgunk, hogy ezt a szemantik\u00e1t megval\u00f3s\u00edtsuk: jelzettbe tegy\u00fck az esem\u00e9nyt, mikor adat ker\u00fcl a FIFO-ba, \u00e9s jelzetlenbe, amikor ki\u00fcr\u00fcl a FIFO. public void Put ( double [] data ) { lock ( _syncRoot ) { _innerList . Add ( data ); _hasData . Set (); } } public bool TryGet ( out double [] data ) { lock ( _syncRoot ) { if ( _innerList . Count > 0 ) { data = _innerList [ 0 ]; _innerList . RemoveAt ( 0 ); if ( _innerList . Count == 0 ) { _hasData . Reset (); } return true ; } data = null ; return false ; } }","title":"ManualResetEvent haszn\u00e1lata"},{"location":"labor/4-tobbszalu/#jelzesre-varakozas-blokkolo-a-get","text":"Az el\u0151z\u0151 pontban megoldottuk a jelz\u00e9st, \u00e1m ez \u00f6nmag\u00e1ban nem sokat \u00e9r, hiszen nem v\u00e1rakoznak r\u00e1. Ennek megval\u00f3s\u00edt\u00e1sa j\u00f6n most. M\u00f3dos\u00edtsuk a met\u00f3dust az al\u00e1bbiak szerint: kidobjuk az \u00fcress\u00e9g vizsg\u00e1latot \u00e9s az esem\u00e9nyre val\u00f3 v\u00e1rakoz\u00e1ssal p\u00f3toljuk. public bool TryGet ( out double [] data ) { lock ( _syncRoot ) { if ( _hasData . WaitOne ()) { // ... A WaitOne m\u0171velet visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9nek vizsg\u00e1lata A WaitOne m\u0171velet egy bool \u00e9rt\u00e9kkel t\u00e9r vissza, mely igaz, ha a WaitOne param\u00e9ter\u00e9ben megadott id\u0151korl\u00e1t el\u0151tt jelzett \u00e1llapotba ker\u00fcl az esem\u00e9ny (ill. ennek megfelel\u0151en hamis, ha lej\u00e1rt az id\u0151korl\u00e1t). A p\u00e9ld\u00e1nkban nem adtunk meg id\u0151korl\u00e1tot param\u00e9terben, mely v\u00e9gtelen id\u0151korl\u00e1t alkalmaz\u00e1s\u00e1t jelenti. Ennek megfelel\u0151en felesleges is az if felt\u00e9telvizsg\u00e1lat, hiszen eset\u00fcnkben a WaitOne() mindig igaz \u00e9rt\u00e9kkel t\u00e9r vissza. Ez egyetlen ok, ami\u00e9rt m\u00e9gis \u00e9lt\u00fcnk felt\u00e9telvizsg\u00e1lattal: \u00edgy a k\u00f6vetketkez\u0151 \u00e9s egy k\u00e9s\u0151bbi feladatn\u00e1l kisebb \u00e1talak\u00edt\u00e1sra lesz majd sz\u00fcks\u00e9g. Ezzel a Thread.Sleep a WorkerThread -ben feleslegess\u00e9 v\u00e1lt, kommentezz\u00fck ki! A fenti megold\u00e1s futtat\u00e1sakor azt tapasztaljuk, hogy az alkalmaz\u00e1sunk fel\u00fclete az els\u0151 gombnyom\u00e1st k\u00f6vet\u0151en befagy. Az el\u0151z\u0151 megold\u00e1sunkban ugyanis egy amat\u0151r hib\u00e1t k\u00f6vett\u00fcnk el. A lock-olt k\u00f3dr\u00e9szleten bel\u00fcl v\u00e1rakozunk a _hasData jelz\u00e9s\u00e9re, \u00edgy a f\u0151sz\u00e1lnak lehet\u0151s\u00e9ge sincs arra, hogy a Put m\u0171veletben (egy szint\u00e9n lock -kal v\u00e9dett r\u00e9szen bel\u00fcl) jelz\u00e9st k\u00fcldj\u00f6n _hasData -val. Gyakorlatilag egy holtpont (deadlock) helyzet alakult ki. Gyors hibajav\u00edt\u00e1sk\u00e9nt megadhatunk egy id\u0151korl\u00e1tot (ms) a v\u00e1rakoz\u00e1sn\u00e1l: if ( _hasData . WaitOne ( 100 )) Tesztelj\u00fck az alkalmaz\u00e1st! A megold\u00e1s ugyan fut, de az eleg\u00e1ns \u00e9s k\u00f6vetend\u0151 minta az, hogy lock-on bel\u00fcl ker\u00fclj\u00fck a blokkolva v\u00e1rakoz\u00e1st. Val\u00f3di jav\u00edt\u00e1sk\u00e9nt cser\u00e9lj\u00fck meg a lock -ot \u00e9s a WaitOne -t, illetve a WaitOne param\u00e9ter elt\u00e1vol\u00edt\u00e1s\u00e1val sz\u00fcntess\u00fck meg a v\u00e1rakoz\u00e1si id\u0151korl\u00e1tot: public bool TryGet ( out double [] data ) { if ( _hasData . WaitOne ()) { lock ( _syncRoot ) { data = _innerList [ 0 ]; _innerList . RemoveAt ( 0 ); if ( _innerList . Count == 0 ) { _hasData . Reset (); } return true ; } } data = null ; return false ; } Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Az els\u0151 gombnyom\u00e1s hat\u00e1s\u00e1ra kiv\u00e9telt kapunk. \u00cdgy elker\u00fclj\u00fck ugyan a deadlockot, azonban a sz\u00e1lbiztoss\u00e1g s\u00e9r\u00fclt , hiszen mire a lock -on bel\u00fclre jutunk, nem biztos, hogy maradt elem a list\u00e1ban. Ugyanis lehet, t\u00f6bb sz\u00e1l is v\u00e1rakozik a _hasData.WaitOne() m\u0171veletn\u00e9l arra, hogy elem ker\u00fclj\u00f6n a sorba. Mikor ez bek\u00f6vetkezik, a ManualResetEvent objektumunk mind \u00e1tengedi (hacsak \u00e9ppen gyorsan le nem csukja egy sz\u00e1l, de ez nem garant\u00e1lt). A konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s neh\u00e9zs\u00e9gei J\u00f3l illusztr\u00e1lja a feladat, hogy milyen alapos \u00e1tgondol\u00e1st ig\u00e9nyel a konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s. Tulajdonk\u00e9ppen m\u00e9g szerencs\u00e9nk is volt az el\u0151z\u0151ekben, mert j\u00f3l reproduk\u00e1lhat\u00f3an el\u0151j\u00f6tt a hiba. A gyakorlatban azonban ez ritk\u00e1n van \u00edgy. Sajnos sokkal gyakoribb, hogy a konkurenciahib\u00e1k id\u0151nk\u00e9nti, nem reproduk\u00e1lhat\u00f3 probl\u00e9m\u00e1kat okoznak. Az ilyen jelleg\u0171 feladatok megold\u00e1s\u00e1t mindig nagyon \u00e1t kell gondolni, nem lehet az \"addig-pr\u00f3b\u00e1lkozom-m\u00edg-j\u00f3-nem-lesz-a-k\u00e9zi-teszt-sor\u00e1n\" elv ment\u00e9n leprogramozni. Jav\u00edt\u00e1sk\u00e9nt tegy\u00fck vissza a lock -on bel\u00fcli \u00fcress\u00e9g-vizsg\u00e1latot. public bool TryGet ( out double [] data ) { if ( _hasData . WaitOne ()) { lock ( _syncRoot ) { if ( _innerList . Count > 0 ) { data = _innerList [ 0 ]; _innerList . RemoveAt ( 0 ); if ( _innerList . Count == 0 ) { _hasData . Reset (); } return true ; } } } data = null ; return false ; } Ez m\u00e1r j\u00f3l m\u0171k\u00f6dik. El\u0151fordulhat ugyan, hogy feleslegesen fordulunk a list\u00e1hoz, de ezzel \u00edgy most megel\u00e9gsz\u00fcnk. Tesztelj\u00fck az alkalmaz\u00e1st! System.Collections.Concurrent A .NET keretrendszerben t\u00f6bb be\u00e9p\u00edtett sz\u00e1lbiztoss\u00e1gra felk\u00e9sz\u00edtett oszt\u00e1ly is tal\u00e1lhat\u00f3 a System.Collections.Concurrent n\u00e9vt\u00e9rben. A fenti p\u00e9ld\u00e1ban a DataFifo oszt\u00e1lyt a System.Collections.Concurrent.ConcurrentQueue oszt\u00e1llyal kiv\u00e1lthattuk volna.","title":"Jelz\u00e9sre v\u00e1rakoz\u00e1s (blokkol\u00f3 a Get)"},{"location":"labor/4-tobbszalu/#8-feladat-kulturalt-leallas","text":"Kor\u00e1bban f\u00e9lretett\u00fck azt a probl\u00e9m\u00e1t, hogy az ablakunk bez\u00e1r\u00e1sakor a processz\u00fcnk \u201eberagad\u201d, ugyanis a feldolgoz\u00f3 munkasz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9ptet\u00e9s\u00fcket eddig nem oldottuk meg. C\u00e9lunk, hogy a v\u00e9gtelen while ciklust kiv\u00e1ltva a munkasz\u00e1laink az alkalmaz\u00e1s bez\u00e1r\u00e1sakor kultur\u00e1lt m\u00f3don \u00e1lljanak le. Egy ManualResetEvent seg\u00edts\u00e9g\u00e9vel jelezz\u00fck a le\u00e1ll\u00edt\u00e1st a FIFO-ban a TryGet -ben t\u00f6rt\u00e9n\u0151 v\u00e1rakoz\u00e1s sor\u00e1n. A FIFO-ban vegy\u00fcnk fel egy \u00faj ManualResetEvent -et, \u00e9s vezess\u00fcnk be egy Release m\u0171veletet, amellyel a v\u00e1rakoz\u00e1sainkat z\u00e1rhatjuk r\u00f6vidre (\u00faj esem\u00e9ny\u00fcnk jelzett \u00e1llapotba \u00e1ll\u00edthat\u00f3). private ManualResetEvent _releaseTryGet = new ManualResetEvent ( false ); public void Release () { _releaseTryGet . Set (); } A TryGet -ben erre az esem\u00e9nyre is v\u00e1rakozzunk. A WaitAny met\u00f3dus akkor engedi tov\u00e1bb a futtat\u00e1st, ha a param\u00e9terk\u00e9nt megadott WaitHandle t\u00edpus\u00fa objektumok k\u00f6z\u00fcl valamelyik jelzett \u00e1llapotba ker\u00fcl, \u00e9s visszaadja annak t\u00f6mbb\u00e9li index\u00e9t. T\u00e9nyleges adatfeldolgoz\u00e1st pedig csak akkor szeretn\u00e9nk, ha a _hasData jelzett (amikor is a WaitAny 0-val t\u00e9r vissza). public bool TryGet ( out double [] data ) { if ( WaitHandle . WaitAny ( new [] { _hasData , _releaseTryGet }) == 0 ) { lock ( _syncRoot ) { MainForm.cs -ban vegy\u00fcnk fel egy flag tagv\u00e1ltoz\u00f3t a bez\u00e1r\u00e1s jelz\u00e9s\u00e9re: private bool _isClosed = false ; A form bez\u00e1r\u00e1sakor \u00e1ll\u00edtsuk jelzettre az \u00faj esem\u00e9nyt \u00e9s billents\u00fcnk be be a flag-et is. (A Form oszt\u00e1ly OnClosed met\u00f3dusa mindig megh\u00edv\u00f3dik bez\u00e1r\u00e1skor, a Dispose -zal ellent\u00e9tben.) protected override void OnClosed ( EventArgs e ) { base . OnClosed ( e ); _isClosed = true ; _fifo . Release (); } \u00cdrjuk \u00e1t a while ciklust az el\u0151z\u0151 pontban felvett flag figyel\u00e9s\u00e9re. private void WorkerThread () { while (! _isClosed ) { V\u00e9g\u00fcl biztos\u00edtsuk, hogy a m\u00e1r bez\u00e1r\u00f3d\u00f3 ablak eset\u00e9ben ne pr\u00f3b\u00e1ljunk \u00fczeneteket ki\u00edrni private void ShowResult ( double [] parameters , double result ) { if ( _isClosed ) return ; Futtassuk az alkalmaz\u00e1st, \u00e9s ellen\u0151rizz\u00fck, kil\u00e9p\u00e9skor az processz\u00fcnk val\u00f3ban befejezi-e a fut\u00e1s\u00e1t. Hol h\u00edvjunk Release-t? (kitekint\u00e9s - nem k\u00f6telez\u0151 anyag) Az OnClosed vagy OnClosing \u00e9letciklus f\u00fcggv\u00e9nyei a Formnak j\u00f3 v\u00e1laszt\u00e1sok, mert azokr\u00f3l biztosan tudjuk, hogy helyesen h\u00edv\u00f3dnak meg minden esetben. Cser\u00e9ben egy plusz flag-et kell karbantartanunk. Egyik alternat\u00edva lehetne m\u00e9g az \u00e9letciklus esem\u00e9nyek helyett a Dispose met\u00fadusba rakni ezt a logik\u00e1t, \u00e9s akkor az IsDisposed be\u00e9p\u00edtett flag-et is haszn\u00e1lhatn\u00e1nk. Ezt k\u00e9t okb\u00f3l is \u00e9rdemes ker\u00fclni Formok eset\u00e9ben: A Dispose met\u00f3dus m\u00e1r l\u00e9tezik a MainForm.Designer.cs f\u00e1jlban, \u00e9s a Designer.cs f\u00e1jlokat alapvet\u0151en nem szok\u00e1s szerkeszteni, b\u00e1r ezt a met\u00f3dust a designer m\u00e1r nem piszk\u00e1lja, ha m\u00e1r l\u00e9trej\u00f6tt a form, \u00edgy ezt ak\u00e1r nyugodtan \u00e1t is helyezhetn\u00e9nk a MainForm.cs -be. A Dispose megh\u00edv\u00e1sa nem mindig determinisztikus Windows Forms eset\u00e9ben, mert el\u0151fordulhat, hogy nem a keretrendszer nyitotta a formot, hanem a fejleszt\u0151 programozottan, \u00e9s elfelejtette Dispose -t h\u00edvni rajta, aminek a hat\u00e1s\u00e1ra, majd csak a GC fogja megh\u00edvni a Dispose f\u00fcggv\u00e9nyt. A Release m\u0171velet helyett m\u00e9g egy m\u00e1sik alternat\u00edva lehetne, hogy az IDisposable mint\u00e1t megval\u00f3s\u00edtjuk a DataFifo -ba, de ilyenkor is k\u00e9zzel kellene Dispose -t h\u00edvni, mivel nem f\u00fcggv\u00e9ny szint\u0171 az \u00e9letciklusa a FIFO objektumnak, \u00edgy nem tudn\u00e1nk using blokkban haszn\u00e1lni. Egy \u00f6sszetett alkalmaz\u00e1sban egy\u00e9nk\u00e9nt gyakran nem k\u00e9zzel kezelj\u00fck egy-egy oszt\u00e1lynak a f\u00fcgg\u0151s\u00e9geit \u00e9s az \u00e9letciklus\u00e1t. Helyette a Dependency Injection tervez\u00e9si mint\u00e1t \u00e9rdemes alkalmazni, ahol egy k\u00fcl\u00f6n komponensbe szervezz\u00fck ki az objektumok p\u00e9ld\u00e1nyos\u00edt\u00e1s\u00e1t \u00e9s \u00e9letciklus\u00e1nak kezel\u00e9s\u00e9t.","title":"8. feladat \u2013 Kultur\u00e1lt le\u00e1ll\u00e1s"},{"location":"labor/4-tobbszalu/#kitekintes-task-async-await","text":"A t\u00e1rgynak nem anyaga, de .NET alkalmaz\u00e1sok (\u00e9s m\u00e1s modern nyelv\u0171 alkalmaz\u00e1sok (Swift, Kotlin, TypeScript, stb.)) eset\u00e9ben megker\u00fclhetetlen az aszinkron programoz\u00e1s koncepci\u00f3ja. A C# (\u00e9s m\u00e1s modern nyelvek) nyelvi szintre emelt\u00e9k az szinkron esem\u00e9nyek bev\u00e1r\u00e1s\u00e1nak kezel\u00e9s\u00e9t az async / await kulcsszavakkal ( L\u00e1sd b\u0151vebben ) M\u00e9gis ehhez az anyaghoz laz\u00e1n \u00fagy kapcsol\u00f3dhat ez a t\u00e9ma, hogy a Task oszt\u00e1ly olyan aszinkron m\u0171veletet is reprezent\u00e1lhat, ami ak\u00e1r k\u00fcl\u00f6n sz\u00e1lon is futhat (de nem k\u00f6telez\u0151en futnak ezek k\u00fcl\u00f6n sz\u00e1lon!), \u00e9s bev\u00e1rhat\u00f3 ennek az eredm\u00e9nye aszinkron m\u00f3don. A Task.Run statikus f\u00fcggv\u00e9ny pedig egyenesen a ThreadPool -on \u00fctemez egy m\u0171veletet, ami \u00edgy aszinkron bev\u00e1rhat\u00f3.","title":"Kitekint\u00e9s: Task, async, await"},{"location":"labor/5-adatkezeles/","text":"5. Adatkezel\u00e9s \u00b6 A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9lja az ADO.NET programoz\u00e1si modellj\u00e9nek megismer\u00e9se \u00e9s a leggyakoribb adatkezel\u00e9si probl\u00e9m\u00e1k, buktat\u00f3k szeml\u00e9ltet\u00e9se alapvet\u0151 CRUD m\u0171veletek meg\u00edr\u00e1s\u00e1n kereszt\u00fcl. Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Adatkezel\u00e9s, ADO.NET alapismeretek. El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer A gyakorlat sor\u00e1n Visual Studioban az SQL Server Object Explorer -t fogjuk haszn\u00e1lni az adatb\u00e1zis objektumok k\u00f6z\u00f6tti navig\u00e1l\u00e1s\u00e1ra \u00e9s a lek\u00e9rdez\u00e9sek futtat\u00e1s\u00e1ra. Ehhez sz\u00fcks\u00e9g lehet az SQL Server Data Tools komponensre, melyet legegyszer\u0171bben az Individual Components oldalon tudunk telep\u00edteni a Visual Studio Installer-ben, de a Data Storage and Processing workload is tartalmazza ezt. Gyakorlat Linuxon vagy Macen A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studiora k\u00e9sz\u00fclt, de - n\u00e9mik\u00e9ppen m\u00e1s \u00faton - elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is, mivel a .NET 6 SDK t\u00e1mogatott Linuxon \u00e9s Mac-en, Linuxon: Visual Studio helyett sz\u00f6vegszerkeszt\u0151vel (pl.: VSCode) \u00e9s CLI eszk\u00f6z\u00f6kkel. Az SQL szervernek van Linuxos v\u00e1ltozata, Mac-en pedig Dockerben futtathat\u00f3 (de Linuxon is tal\u00e1n a Docker legk\u00e9nyelmesebb m\u00f3d a futtat\u00e1s\u00e1ra). Az adatok vizualiz\u00e1ci\u00f3j\u00e1ra haszn\u00e1lhat\u00f3 a szint\u00e9n keresztplatformos Azure Data Studio eszk\u00f6z. Bevezet\u0151 \u00b6 Megjegyz\u00e9s gyakorlatvezet\u0151knek Ezt a fejezetet gyakorlaton nem kell a le\u00edrtaknak megfelel\u0151 r\u00e9szletess\u00e9ggel ismertetni, a fontosabb fogalmakat azonban mindenk\u00e9ppen ismertess\u00fck r\u00f6viden. ADO.NET \u00b6 Alacsony szint\u0171 adatb\u00e1ziskezel\u00e9sre a .NET platformon az ADO.NET \u00e1ll rendelkez\u00e9sre, seg\u00edts\u00e9g\u00e9vel rel\u00e1ci\u00f3s adatb\u00e1zisokat tudunk el\u00e9rni. Az ADO.NET haszn\u00e1lata sor\u00e1n k\u00e9t elt\u00e9r\u0151 adathozz\u00e1f\u00e9r\u00e9si modellt alkalmazhatunk: Kapcsolatalap\u00fa modell Kapcsolat n\u00e9lk\u00fcli modell Az al\u00e1bbi k\u00e9t blokkot lenyitva \u00e1ttekint\u00e9st kaphatunk a k\u00e9t modell alapelv\u00e9r\u0151l. A Kapcsolatalap\u00fa modell alapelvei L\u00e9nyege az, hogy az adatb\u00e1ziskapcsolatot v\u00e9gig nyitva tartjuk, am\u00edg az adatokat lek\u00e9rdezz\u00fck, m\u00f3dos\u00edtjuk, majd a v\u00e1ltoztat\u00e1sokat az adatb\u00e1zisba vissza\u00edrjuk. A megold\u00e1sra DataReader objektumokat haszn\u00e1lhatunk (l\u00e1sd k\u00e9s\u0151bb). A megold\u00e1s el\u0151nye az egyszer\u0171s\u00e9g\u00e9ben rejlik (egyszer\u0171bb programoz\u00e1si modell \u00e9s konkurenciakezel\u00e9s). A megold\u00e1s h\u00e1tr\u00e1nya, hogy a folyamatosan fenntartott h\u00e1l\u00f3zati kapcsolat miatt sk\u00e1l\u00e1zhat\u00f3s\u00e1gi probl\u00e9m\u00e1k ad\u00f3dhatnak. Ez azt jelenti, hogy az adatkezel\u0151h\u00f6z t\u00f6rt\u00e9n\u0151 nagysz\u00e1m\u00fa p\u00e1rhuzamos felhaszn\u00e1l\u00f3i hozz\u00e1f\u00e9r\u00e9s eset\u00e9n folyamatosan nagysz\u00e1m\u00fa adatb\u00e1zis kapcsolat \u00e9l, ami adatkezel\u0151 rendszerek eset\u00e9n a teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l k\u00f6lts\u00e9ges er\u0151forr\u00e1snak sz\u00e1m\u00edt. \u00cdgy a fejleszt\u00e9s sor\u00e1n c\u00e9lszer\u0171 arra t\u00f6rekedni, hogy az adatb\u00e1zis kapcsolatokat miel\u0151bb z\u00e1rjuk le. A modell el\u0151nyei: Egyszer\u0171bb a konkurencia kezel\u00e9se Az adatok mindenhol a legfrissebbek Megjegyz\u00e9s: ezek az el\u0151ny\u00f6k akkor jelentkeznek, ha az adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9s az adatkezel\u0151 szigor\u00fa z\u00e1rakat haszn\u00e1l \u2013 ezt mi a hozz\u00e1f\u00e9r\u00e9s sor\u00e1n megfelel\u0151 tranzakci\u00f3 izol\u00e1ci\u00f3s szint megad\u00e1s\u00e1val tudjuk szab\u00e1lyozni. Ennek technik\u00e1i k\u00e9s\u0151bbi tanulm\u00e1nyok sor\u00e1n ker\u00fclnek ismertet\u00e9sre). H\u00e1tr\u00e1nyok: Folyamatos h\u00e1l\u00f3zati kapcsolat Sk\u00e1l\u00e1zhat\u00f3s\u00e1g A Kapcsolatn\u00e9lk\u00fcli modell alapelvei A kapcsolatalap\u00fa modellel ellent\u00e9tben az adatok megjelen\u00edt\u00e9se \u00e9s mem\u00f3ri\u00e1ban t\u00f6rt\u00e9n\u0151 m\u00f3dos\u00edt\u00e1sa sor\u00e1n nem tartunk fent adatb\u00e1zis kapcsolatot. Ennek megfelel\u0151en a f\u0151bb l\u00e9p\u00e9sek a k\u00f6vetkez\u0151k: a kapcsolat felv\u00e9tel\u00e9t \u00e9s az adatok lek\u00e9rdez\u00e9s\u00e9t k\u00f6vet\u0151en azonnal bontjuk a kapcsolatot. Az adatokat ezt k\u00f6vet\u0151en tipikusan megjelen\u00edtj\u00fck \u00e9s lehet\u0151s\u00e9get biztos\u00edtunk a felhaszn\u00e1l\u00f3nak az adatok m\u00f3dos\u00edt\u00e1s\u00e1ra (rekordok felv\u00e9tele, m\u00f3dos\u00edt\u00e1sa, t\u00f6rl\u00e9se ig\u00e9ny szerint). A m\u00f3dos\u00edt\u00e1sok ment\u00e9se sor\u00e1n \u00fajra felvessz\u00fck az adatkapcsolatot, mentj\u00fck az adatb\u00e1zisba a v\u00e1ltoztat\u00e1sokat \u00e9s z\u00e1rjuk a kapcsolatot. Term\u00e9szetesen a modell megk\u00f6veteli, hogy a lek\u00e9rdez\u00e9se \u00e9s a m\u00f3dos\u00edt\u00e1sok vissza\u00edr\u00e1sa k\u00f6z\u00f6tt \u2013 amikor nincs kapcsolatunk az adatb\u00e1zissal \u2013 az adatokat \u00e9s a v\u00e1ltoztat\u00e1sokat a mem\u00f3ri\u00e1ban nyilv\u00e1ntartsuk. Erre az ADO.NET k\u00f6rnyezetben nagyon k\u00e9nyelmes megold\u00e1st ny\u00fajt a DataSet objektumok alkalmaz\u00e1sa. A modell el\u0151nyei: Nem sz\u00fcks\u00e9ges folyamatos h\u00e1l\u00f3zati kapcsolat Sk\u00e1l\u00e1zhat\u00f3s\u00e1g H\u00e1tr\u00e1nyok Az adatok nem mindig a legfrissebbek \u00dctk\u00f6z\u00e9sek lehets\u00e9gesek Megjegyz\u00e9s: Sz\u00e1mos lehet\u0151s\u00e9g\u00fcnk van arra, hogy az objektumokat \u00e9s kapcsol\u00f3d\u00f3 v\u00e1ltoz\u00e1sokat nyilv\u00e1ntartsuk a mem\u00f3ri\u00e1ban. A DataSet csak az egyik lehets\u00e9ges technika. De haszn\u00e1lhatunk erre a c\u00e9lra k\u00f6z\u00f6ns\u00e9ges objektumokat, illetve ezek menedzsel\u00e9s\u00e9t megk\u00f6nny\u00edt\u0151 ADO.NET-n\u00e9l korszer\u0171bb .NET technol\u00f3gi\u00e1kat (pl. Entity Framework Core). A kapcsolatalap\u00fa modell \u00b6 A labor keret\u00e9ben a kapcsolatalap\u00fa modellt ismerj\u00fck meg. Az alapfolyamat a k\u00f6vetkez\u0151: Kapcsolat l\u00e9trehoz\u00e1sa az alkalmaz\u00e1s, illetve az adatb\u00e1zis kezel\u0151 rendszer k\u00f6z\u00f6tt ( Connection objektum felhaszn\u00e1l\u00e1s\u00e1val). A futtatand\u00f3 SQL utas\u00edt\u00e1s \u00f6ssze\u00e1ll\u00edt\u00e1s ( Command objektum felhaszn\u00e1l\u00e1s\u00e1val). Utas\u00edt\u00e1s futtat\u00e1sa ( Command objektum felhaszn\u00e1l\u00e1s\u00e1val). Lek\u00e9rdez\u00e9sek eset\u00e9n a visszakapott rekordhalmaz feldolgoz\u00e1sa ( DataReader objektum felhaszn\u00e1l\u00e1s\u00e1val). Erre a m\u00f3dos\u00edt\u00f3 parancsok eset\u00e9n \u00e9rtelemszer\u0171en nincs sz\u00fcks\u00e9g. Kapcsolat lez\u00e1r\u00e1sa. Mint a fentiekb\u0151l kider\u00fcl, az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3nak ebben a modellben h\u00e1rom f\u0151 \u00f6sszetev\u0151je van: Connection Command Data Reader Ezek az \u00f6sszetev\u0151k egy-egy oszt\u00e1lyk\u00e9nt jelennek meg, adatb\u00e1ziskezel\u0151f\u00fcggetlen r\u00e9sz\u00fck a BCL System.Data.Common n\u00e9vter\u00e9ben tal\u00e1lhat\u00f3 DbConnection , DbCommand , illetve DbDataReader n\u00e9ven. Ezek absztrakt oszt\u00e1lyok, az adatb\u00e1ziskezel\u0151k gy\u00e1rt\u00f3inak feladata, hogy ezekb\u0151l lesz\u00e1rmazva meg\u00edrj\u00e1k a konkr\u00e9t adatb\u00e1ziskezel\u0151ket t\u00e1mogat\u00f3 v\u00e1ltozatokat. Mindh\u00e1rom ADO.NET \u00f6sszetev\u0151 t\u00e1mogatja a Dispose mint\u00e1t, \u00edgy using blokkban haszn\u00e1lhat\u00f3 \u2013 haszn\u00e1ljuk is \u00edgy, amikor csak tudjuk. Az adatb\u00e1ziskezel\u0151 \u00e1ltal\u00e1ban m\u00e1sik g\u00e9pen tal\u00e1lhat\u00f3, mint ahol a k\u00f3dunk fut (a labor sor\u00e1n pont nem :)), \u00edgy tekints\u00fcnk ezekre, mint t\u00e1voli h\u00e1l\u00f3zati er\u0151forr\u00e1sokra. A Microsoft SQL Servert t\u00e1mogat\u00f3 v\u00e1ltozat a Microsoft.Data.SqlClient NuGet csomagban, az \u201eSql\u201d prefix\u0171 oszt\u00e1lyokban tal\u00e1lhat\u00f3k ( SqlConnection , SqlCommand \u00e9s SqlDataReader ). A t\u00f6bbi gy\u00e1rt\u00f3 k\u00fcl\u00f6n dll-(ek)be teszi a saj\u00e1t v\u00e1ltozat\u00e1t, az \u00edgy l\u00e9trej\u00f6tt komponenst data providernek nevezik. Teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl n\u00e9h\u00e1ny p\u00e9lda: PostgreSQL SQLite Oracle Connection \u00b6 Ez teremti meg a kapcsolatot a programunk, illetve az adatb\u00e1ziskezel\u0151-rendszer k\u00f6z\u00f6tt. Inicializ\u00e1l\u00e1s\u00e1hoz sz\u00fcks\u00e9g van egy connection string-re, mely a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9hez sz\u00fcks\u00e9ges adatokat adja meg a driver sz\u00e1m\u00e1ra. Adatb\u00e1zisgy\u00e1rt\u00f3nk\u00e9nt elt\u00e9r\u0151 a bels\u0151 form\u00e1tuma ( b\u0151vebben ). \u00daj Connection p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem biztos, hogy t\u00e9nyleg \u00faj kapcsolat fog l\u00e9trej\u00f6nni az adatb\u00e1zis fel\u00e9, a driverek \u00e1ltal\u00e1ban connection pooling-ot alkalmaznak, hasonl\u00f3an, mint a thread pool eset\u00e9ben, \u00fajrahaszn\u00e1lhatj\u00e1k a kor\u00e1bbi (\u00e9ppen nem haszn\u00e1lt) kapcsolatokat. A Connection k\u00fcl\u00f6n\u00f6sen k\u00f6lts\u00e9ges nem fel\u00fcgyelt er\u0151forr\u00e1sokat haszn\u00e1l, \u00edgy kiemelten fontos, hogy a lehet\u0151 leghamarabb gondoskodjunk lez\u00e1r\u00e1s\u00e1r\u00f3l , amikor m\u00e1r nincs r\u00e1 sz\u00fcks\u00e9g (pl. a Dispose() h\u00edv\u00e1s\u00e1val, amit az esetek t\u00f6bbs\u00e9g\u00e9ben legegyszer\u0171bben a using blokk alkalmaz\u00e1s\u00e1val tehet\u00fcnk meg). Command \u00b6 Ennek seg\u00edts\u00e9g\u00e9vel vagyunk k\u00e9pesek \u201eutas\u00edt\u00e1sokat\u201d megfogalmazni az adatb\u00e1zis kezel\u0151 sz\u00e1m\u00e1ra. Ezeket SQL nyelven kell megfogalmaznunk. A Command -nak be kell \u00e1ll\u00edtani egy kapcsolatot \u2013 ezen kereszt\u00fcl fog a parancs v\u00e9grehajt\u00f3dni. A parancsnak k\u00fcl\u00f6nb\u00f6z\u0151 eredm\u00e9nye lehet, ennek megfelel\u0151en k\u00fcl\u00f6nb\u00f6z\u0151 f\u00fcggv\u00e9nyekkel futtatjuk a parancsot: ExecuteReader : Eredm\u00e9nyhalmaz (result set) lek\u00e9rdez\u00e9se ExecuteScalar : Skal\u00e1r \u00e9rt\u00e9k lek\u00e9rdez\u00e9se ExecuteNonQuery : Nincs visszat\u00e9r\u00e9si \u00e9rt\u00e9k (Pl: INSERT, UPDATE \u00e9s DELETE), viszont a m\u0171velet k\u00f6vetkezt\u00e9ben \u00e9rintett rekordok sz\u00e1m\u00e1t visszakapjuk Data Reader \u00b6 Ha a parancs eredm\u00e9nye eredm\u00e9nyhalmaz, akkor ennek a komponensnek a seg\u00edts\u00e9g\u00e9vel tudjuk az adatokat kiolvasni. Az eredm\u00e9nyhalmaz egy t\u00e1bl\u00e1zatnak tekinthet\u0151, a Data Reader ezen tud soronk\u00e9nt v\u00e9gignavig\u00e1lni (csak egyes\u00e9vel el\u0151refel\u00e9!). A kurzor egyszerre egy soron \u00e1ll, ha a sorb\u00f3l a sz\u00fcks\u00e9ges adatokat kiolvastuk, a kurzort egy sorral el\u0151re l\u00e9ptethetj\u00fck. Csak az aktu\u00e1lis sorb\u00f3l tudunk olvasni. Kezdetben a kurzor nem az els\u0151 soron \u00e1ll, azt egyszer l\u00e9ptetn\u00fcnk kell, hogy az els\u0151 sorra \u00e1lljon. Megjegyz\u00e9s: navig\u00e1l\u00e1s kliens oldalon t\u00f6rt\u00e9nik a mem\u00f3ri\u00e1ban, nincs k\u00f6ze az egyes adatkezel\u0151k \u00e1ltal t\u00e1mogatott kiszolg\u00e1l\u00f3 oldali kurzorokhoz. 1. Feladat \u2013 Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se \u00b6 Els\u0151k\u00e9nt sz\u00fcks\u00e9g\u00fcnk van egy adatb\u00e1ziskezel\u0151re. Ezt val\u00f3s k\u00f6rnyezetben dedik\u00e1lt szerveren fut\u00f3, adatb\u00e1zis adminisztr\u00e1torok \u00e1ltal fel\u00fcgyelt, teljes\u00e9rt\u00e9k\u0171 adatb\u00e1ziskezel\u0151k jelentik. Fejleszt\u00e9si id\u0151ben, lok\u00e1lis tesztel\u00e9shez azonban k\u00e9nyelmesebb egy fejleszt\u0151i adatb\u00e1ziskezel\u0151 haszn\u00e1lata. A Visual Studio telep\u00edt\u00e9s\u00e9nek r\u00e9szek\u00e9nt kapunk is egy ilyen adatb\u00e1zismotort, ez a LocalDB, mely a teljes\u00e9rt\u00e9k\u0171 SQL Server egyszer\u0171s\u00edtett v\u00e1ltozata. F\u0151bb tulajdons\u00e1gai: nem csak a Visual Studio-val, hanem k\u00fcl\u00f6n is telep\u00edthet\u0151, az adatb\u00e1zismotor szinte teljes m\u00e9rt\u00e9kben kompatibilis a teljes\u00e9rt\u00e9k\u0171 Microsoft SQL Serverrel, alapvet\u0151en arr\u00f3l a g\u00e9pr\u0151l \u00e9rhet\u0151 el, melyre telep\u00edtett\u00fck, t\u00f6bb p\u00e9ld\u00e1ny is l\u00e9trehozhat\u00f3 ig\u00e9ny szerint, a p\u00e9ld\u00e1nyok alapvet\u0151en a l\u00e9trehoz\u00f3 oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3ja sz\u00e1m\u00e1ra \u00e9rhet\u0151k el (ig\u00e9ny eset\u00e9n megoszthat\u00f3 egy p\u00e9ld\u00e1ny a felhaszn\u00e1l\u00f3k k\u00f6z\u00f6tt), a saj\u00e1t p\u00e9ld\u00e1nyok kezel\u00e9se (l\u00e9trehoz\u00e1s, t\u00f6rl\u00e9s, stb.) nem ig\u00e9nyel adminisztr\u00e1tori jogokat. ssqllocaldb parancssori eszk\u00f6z A gyakorlat sor\u00e1n nincs sz\u00fcks\u00e9g\u00fcnk erre, de a p\u00e9ld\u00e1nyok kezel\u00e9s\u00e9re az sqllocaldb parancssori eszk\u00f6z haszn\u00e1lhat\u00f3. N\u00e9h\u00e1ny parancs, melyet az sqllocaldb ut\u00e1n be\u00edrva alkalmazhatunk: Paracs Le\u00edr\u00e1s info az aktu\u00e1lis felhaszn\u00e1\u00e1l\u00f3 sz\u00e1m\u00e1ra l\u00e1that\u00f3 p\u00e9ld\u00e1nyok list\u00e1ja create \u201elocdb\u201d \u00faj p\u00e9ld\u00e1ny l\u00e9trehoz\u00e1sa \u201elocdb\u201d n\u00e9vvel delete \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny t\u00f6rl\u00e9se start \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny ind\u00edt\u00e1sa stop \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny le\u00e1ll\u00edt\u00e1sa A Visual Studio is telep\u00edt, illetve ind\u00edt LocalDB p\u00e9ld\u00e1nyokat, ez\u00e9rt \u00e9rdemes megn\u00e9zni, hogy a Visual Studio alapesetben milyen p\u00e9ld\u00e1nyokat l\u00e1t. Ind\u00edtsuk el a Visual Studio-t, a View men\u00fcb\u0151l v\u00e1lasszuk az SQL Server Object Explorer-t (SSOE). Nyissuk ki az SQL Server csom\u00f3pontot, ha alatta l\u00e1tunk tov\u00e1bbi csom\u00f3pontokat, akkor nyert \u00fcgy\u00fcnk van, nyissuk ki valamelyiket (ilyenkor indul el a p\u00e9ld\u00e1ny, ha nincs elind\u00edtva, \u00edgy lehet, hogy v\u00e1rni kell kicsit). Ha nem jelent meg semmi, akkor parancssorb\u00f3l az mssqllocaldb info parancs megadja a l\u00e9tez\u0151 p\u00e9ld\u00e1nyokat. V\u00e1lasszuk az SQL Server csom\u00f3ponton jobbklikkelve az Add SQL Server opci\u00f3t, majd adjuk meg valamelyik l\u00e9tez\u0151 p\u00e9ld\u00e1nyt, pl.: (localdb)\\MSSQLLocalDB A megjelen\u0151 Databases csom\u00f3ponton v\u00e1lasszuk a New Database opci\u00f3t, itt adjunk meg egy adatb\u00e1zisnevet. (Laboron, mivel t\u00f6bb hallgat\u00f3 is haszn\u00e1lhatja ugyanazt az oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3t, javasolt a Neptun k\u00f3d, mint n\u00e9v haszn\u00e1lata). Az \u00faj adatb\u00e1zis csom\u00f3pontj\u00e1n jobbklikkelve v\u00e1lasszuk a New Query opci\u00f3t, ami egy \u00faj query ablakot nyit. Nyissuk meg vagy t\u00f6lts\u00fck le a Northwind adatb\u00e1zis inicializ\u00e1l\u00f3 szkriptet . M\u00e1soljuk be a teljes szkriptet a query ablakba. Futtassuk le a szkriptet a kis z\u00f6ld ny\u00edllal ( Execute ). Figyelj\u00fcnk oda, hogy j\u00f3 adatb\u00e1zis (melyet fenti 4. l\u00e9p\u00e9sben hoztunk l\u00e9tre) legyen kiv\u00e1lasztva a query ablak tetej\u00e9n a leg\u00f6rd\u00fcl\u0151ben !. Ellen\u0151rizz\u00fck, hogy az adatb\u00e1zisunkban megjelentek-e t\u00e1bl\u00e1k, n\u00e9zetek. Fedezz\u00fck fel az SSOE legfontosabb funkci\u00f3it (t\u00e1bl\u00e1k adatainak, s\u00e9m\u00e1j\u00e1nak lek\u00e9rdez\u00e9se stb.). MSSQL menedzsment eszk\u00f6z\u00f6k A Visual Studio-ban k\u00e9t eszk\u00f6zzel is kezelhet\u00fcnk adatb\u00e1zisokat: a Server Explorer-rel \u00e9s az SQL Server Object Explorer-rel is. El\u0151bbi egy \u00e1ltal\u00e1nosabb eszk\u00f6z, mely nem csak adatb\u00e1zis, hanem egy\u00e9b szerver er\u0151forr\u00e1sok (pl. Azure szerverek) kezel\u00e9s\u00e9re is alkalmas, m\u00edg a m\u00e1sik kifejezetten csak adatb\u00e1ziskezel\u00e9sre van kihegyezve. Mindkett\u0151 el\u00e9rhet\u0151 a View men\u00fcb\u0151l \u00e9s mindkett\u0151 hasonl\u00f3 funkci\u00f3kat ad adatb\u00e1ziskezel\u00e9shez, ez\u00e9rt ebben a m\u00e9r\u00e9sben csak az egyiket (SQL Server Object Explorer) haszn\u00e1ljuk. Amikor nem \u00e1ll rendelkez\u00e9s\u00fcnkre a Visual Studio fejleszt\u0151k\u00f6rnyezet, akkor az adatb\u00e1zisunk menedzsel\u00e9s\u00e9re az (ingyenes) SQL Server Management Studio-t vagy a szint\u00e9n ingyenes \u00e9s multiplatform Azure Data Studio-t tudjuk haszn\u00e1lni. 2. Feladat \u2013 Lek\u00e9rdez\u00e9s ADO.NET SqlDataReader-rel \u00b6 A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely haszn\u00e1lja a Northwind adatb\u00e1zis Shippers t\u00e1bl\u00e1j\u00e1nak rekordjait. Hozzunk l\u00e9tre egy C# nyelv\u0171 konzolos alkalmaz\u00e1st. A projekt t\u00edpusa Console App legyen, \u00e9s NE a Console App (.NET Framework) : A projekt neve legyen AdoExample A Target Framework legyen .NET 6 Pip\u00e1ljuk be a Do not use top-level statements kapcsol\u00f3t Keress\u00fck ki a connection stringet az SSOE-b\u0151l: jobbklikk az adatb\u00e1ziskapcsolatunkon (pirossal jel\u00f6lve az al\u00e1bbi \u00e1br\u00e1n) / Properties. M\u00e1soljuk a Properties ablakb\u00f3l Connection String tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t egy v\u00e1ltoz\u00f3ba a Program oszt\u00e1lyba. private const string ConnString = @\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=neptun;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\" ; SQL Server connection string form\u00e1tuma MSSQL eset\u00e9ben a connection string kulcs \u00e9rt\u00e9k p\u00e1rokat tartalmaz pontosvessz\u0151vel elv\u00e1lasztva. A Data Source kulcs alatt az SQL szerver p\u00e9ld\u00e1ny neve, az Initial Catalog kulcs alatt az adatb\u00e1zis neve szerepel. Az Integrated Security=true kapcsol\u00f3 pedig a Windows authentik\u00e1ci\u00f3t jelenti. @-os string (C# verbatim string) A @ egy speci\u00e1lis karakter (verbatim indentifier), amit itt arra haszn\u00e1lunk, hogy a connection string-ben megjelen\u0151 backslash karakter ( \\ ) ne felold\u00f3jelk\u00e9nt (escape character) ker\u00fclj\u00f6n \u00e9rtelmez\u00e9sre. Vegy\u00fck fel a projektbe a Microsoft.Data.SqlClient NuGet csomagot. Ezt k\u00e9tf\u00e9lek\u00e9ppen tehetj\u00fck meg: A) Visual Studio NuGet kezel\u0151ben: Projekten jobb gomb / Manage NuGet Packages... , a megjelen\u0151 oldalon Browse oldalra v\u00e1lt\u00e1s. A keres\u0151be Microsoft.Data.SqlClient be\u00edr\u00e1sa. A Version mez\u0151ben az 5.0.1 kiv\u00e1laszt\u00e1sa (laboron az\u00e9rt v\u00e1laszuk ki ezt a verzi\u00f3t, mert ez szerepel a g\u00e9peken a NuGet cache-ben, otthoni gyakorl\u00e1s sor\u00e1n v\u00e1lasszuk ink\u00e1bb a Latest stable -t). B) Bem\u00e1soljuk az al\u00e1bbi csomag referenci\u00e1t a a projektf\u00e1jlba: <ItemGroup> <PackageReference Include= \"Microsoft.Data.SqlClient\" Version= \"5.0.1\" /> </ItemGroup> NuGet csomagkezel\u0151 A NuGet egy olyan online csomagkezel\u0151 rendszer, ahonnan .NET alap\u00fa projektjeinbe tudunk k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket, oszt\u00e1lyk\u00f6nyvt\u00e1rakat egyszer\u0171en, verzi\u00f3zott form\u00e1ban behivatkozni. B\u0151vebben az els\u0151 el\u0151ad\u00e1son szerepel. \u00cdrjunk lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyt, mely lek\u00e9rdezi az \u00f6sszes sz\u00e1ll\u00edt\u00f3t: private static void GetShippers () { using ( var conn = new SqlConnection ( ConnString )) using ( var command = new SqlCommand ( \"SELECT ShipperID, CompanyName, Phone FROM Shippers\" , conn )) { conn . Open (); Console . WriteLine ( \"{0,-10}{1,-20}{2,-20}\" , \"ShipperID\" , \"CompanyName\" , \"Phone\" ); Console . WriteLine ( new string ( '-' , 60 )); using ( SqlDataReader reader = command . ExecuteReader ()) { while ( reader . Read ()) { Console . WriteLine ( $\"{reader[\" ShipperID \"],-10}\" + $\"{reader[\" CompanyName \"],-20}\" + $\"{reader[\" Phone \"],-20}\" ); } } } } A kapcsolat alap\u00fa modell folyamata Kapcsolat, parancs inicializ\u00e1l\u00e1sa Kapcsolat megnyit\u00e1sa Parancs futtat\u00e1sa Eredm\u00e9ny feldolgoz\u00e1sa Kapcsolat bont\u00e1sa, takar\u00edt\u00e1s N\u00e9h\u00e1ny megjegyz\u00e9s a k\u00f3dhoz A DataReader -t a parancs futtat\u00e1s\u00e1nak eredm\u00e9nyek\u00e9nt kapjuk meg, nem pedig k\u00f6zvetlen\u00fcl p\u00e9ld\u00e1nyos\u00edtjuk A parancs futtat\u00e1sa el\u0151tt meg kell nyitnunk a kapcsolatot A DbConnection p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem nyit\u00f3dik meg a kapcsolat (nem t\u00f6rt\u00e9nik h\u00e1l\u00f3zati kommunik\u00e1ci\u00f3) A DataReader.Read() f\u00fcggv\u00e9nye mutatja, hogy van-e m\u00e9g adat az eredm\u00e9nyhalmazban A DataReader -t az eredm\u00e9nyhalmazban tal\u00e1lhat\u00f3 oszlopok nev\u00e9vel indexelhetj\u00fck \u2013 az eredm\u00e9ny object lesz, \u00edgy, ha konkr\u00e9tabb t\u00edpusra van sz\u00fcks\u00e9g\u00fcnk cast-olni kell A ford\u00edt\u00f3 nem \u00e9rtelmezi az SQL parancs sz\u00f6veg\u00e9t (az csak egy string), hanem majd csak az adatb\u00e1zis, \u00edgy hib\u00e1s SQL eset\u00e9n csak fut\u00e1si idej\u0171 kiv\u00e9telt kapunk Figyelj\u00fck meg, hogy az adatb\u00e1zis s\u00e9ma v\u00e1ltoz\u00e1sa eset\u00e9n, pl. egy oszlop \u00e1tnevez\u00e9se ut\u00e1n, h\u00e1ny helyen kell k\u00e9zzel \u00e1t\u00edrni string-eket a k\u00f3dban $ -ral prefixelve string interpol\u00e1ci\u00f3t alkalmazhatunk, azaz k\u00f6zvetlen\u00fcl a stringbe \u00e1gyazhatunk ki\u00e9rt\u00e9kelend\u0151 kifejez\u00e9seket (C# 6-os k\u00e9pess\u00e9g). A $@ seg\u00edts\u00e9g\u00e9vel t\u00f6bbsoros string interpol\u00e1ci\u00f3s kifejez\u00e9seket \u00edrhatunk (a sort\u00f6r\u00e9st a {}-k k\u00f6z\u00f6tt kell betenn\u00fcnk, k\u00fcl\u00f6nben a kimeneten is megjelenik). \u00c9rdekess\u00e9g: C# 8-t\u00f3l f\u00f6lfele b\u00e1rmilyen sorrendben \u00edrhatjuk a $ \u00e9s @ karaktereket, teh\u00e1t a $@ \u00e9s a @$ is helyesnek sz\u00e1m\u00edt. A using kulcssz\u00fa blokk utas\u00edt\u00e1s helyett egysoros kifejez\u00e9sk\u00e9nt is haszn\u00e1lhat\u00f3. Ilyen esetben a using blokk v\u00e9ge az tartalmaz\u00f3 blokkig tart (eset\u00fcnkben a f\u00fcggv\u00e9ny v\u00e9g\u00e9ig.). Ezzel cs\u00f6kkenthet\u0151 a beh\u00faz\u00e1sok sz\u00e1ma, de ne legyen automatikus reflex a haszn\u00e1lata, mert el\u0151fordulhat, hogy hamarabb c\u00e9lszer\u0171 kik\u00e9nyszer\u00edteni az er\u0151forr\u00e1sok felszabad\u00edt\u00e1s\u00e1t, mint a tartalmaz\u00f3 blokk v\u00e9ge. private static void GetShippers () { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( \"SELECT ShipperID, CompanyName, Phone FROM Shippers\" , conn ); conn . Open (); Console . WriteLine ( \"{0,-10}{1,-20}{2,-20}\" , \"ShipperID\" , \"CompanyName\" , \"Phone\" ); Console . WriteLine ( new string ( '-' , 60 )); using var reader = command . ExecuteReader (); while ( reader . Read ()) { Console . WriteLine ( $\"{reader[\" ShipperID \"],-10}\" + $\"{reader[\" CompanyName \"],-20}\" + $\"{reader[\" Phone \"],-20}\" ); } } A tov\u00e1bbiakban ezt a m\u00f3dszert haszn\u00e1ljuk a beh\u00faz\u00e1sok \u00e9s z\u00e1r\u00f3jelek megsp\u00f3rol\u00e1sa \u00e9rdek\u00e9ben. H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l. private static void Main ( string [] args ) { GetShippers (); } Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Rontsuk el az SQL-t, \u00e9s \u00fagy is pr\u00f3b\u00e1ljuk ki. 3. Feladat \u2013 Besz\u00far\u00e1s SQL utas\u00edt\u00e1ssal \u00b6 \u00cdrjunk f\u00fcggv\u00e9nyt, mely \u00faj sz\u00e1ll\u00edt\u00f3t sz\u00far be az adatb\u00e1zisba: private static void InsertShipper ( string companyName , string phone ) { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( \"INSERT INTO Shippers(CompanyName, Phone) VALUES(@name,@phone)\" , conn ); command . Parameters . AddWithValue ( \"@name\" , companyName ); command . Parameters . AddWithValue ( \"@phone\" , phone ); conn . Open (); int affectedRows = command . ExecuteNonQuery (); Console . WriteLine ( $\"{affectedRows} rows affected\" ); } Itt olyan SQL-t kell \u00edrnunk, melynek az \u00f6ssze\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l k\u00edv\u00fclr\u0151l kapott v\u00e1ltoz\u00f3k \u00e9rt\u00e9keit is felhaszn\u00e1ltuk. A string \u00f6sszerak\u00e1s\u00e1hoz egyszer\u0171en a sztring \u00f6sszef\u0171z\u00e9s oper\u00e1tort, sztring interpol\u00e1ci\u00f3t vagy string.Format -ot is haszn\u00e1lhattunk volna, de ez biztons\u00e1gi kock\u00e1zatot (SQL Injection \u2013 b\u0151vebben l\u00e1sd lentebb) rejt \u2013 SOHA!!! ne rakjuk \u00f6ssze az SQL-t stringm\u0171velettel . Helyette \u00edrjuk meg \u00fagy az SQL-t, hogy ahov\u00e1 a v\u00e1ltoz\u00f3k \u00e9rt\u00e9keit \u00edrn\u00e1nk, oda param\u00e9terhivatkoz\u00e1sokat tesz\u00fcnk. SQL Server eset\u00e9ben a hivatkoz\u00e1s szintaxisa: @paramn\u00e9v. A parancs futtat\u00e1s\u00e1hoz a param\u00e9terek \u00e9rt\u00e9keit is \u00e1t kell adnunk az adatb\u00e1zisnak, ugyanis az fogja elv\u00e9gezni a param\u00e9terek hely\u00e9re az \u00e9rt\u00e9kek behelyettes\u00edt\u00e9s\u00e9t. A besz\u00far\u00e1si parancs kimenete nem eredm\u00e9nyhalmaz, \u00edgy az ExecuteNonQuery m\u0171velettel kell futtatnuk, mely visszaadja besz\u00fart sorok sz\u00e1m\u00e1t. H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l. GetShippers (); InsertShipper ( \"Super Shipper\" , \"49-98562\" ); GetShippers (); Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, ellen\u0151rizz\u00fck a konzolban \u00e9s az SSOE-ben is, hogy beker\u00fclt az \u00faj sor. Az SSOE-ben val\u00f3 gyors \u00e9s k\u00e9nyelmes ellen\u0151rz\u00e9shez a Shippers t\u00e1bla context men\u00fcj\u00e9b\u0151l v\u00e1lasszuk a View Data lehet\u0151s\u00e9get. 4. Feladat - M\u00f3dos\u00edt\u00e1s t\u00e1rolt elj\u00e1r\u00e1ssal \u00b6 Tanulm\u00e1nyozzuk SSOE-ben a Product_Update t\u00e1rolt elj\u00e1r\u00e1s k\u00f3dj\u00e1t. Ehhez nyissuk le a Programmability alatt tal\u00e1lhat\u00f3 Stored Procedures csom\u00f3pontot, majd a Product_Update t\u00e1rolt elj\u00e1r\u00e1s context men\u00fcj\u00e9b\u0151l v\u00e1lasszuk a View Code lehet\u0151s\u00e9get. Programk\u00f3d az adatb\u00e1zisban A nagyobb adatkezel\u0151 rendszerek lehet\u0151s\u00e9get biztos\u00edtanak arra, hogy programk\u00f3dot defini\u00e1ljunk mag\u00e1ban az adatkezel\u0151 adatb\u00e1zis\u00e1ban. Ezeket t\u00e1rol elj\u00e1r\u00e1soknak (stored procedure) nevezz\u00fck. A nyelve adatkezel\u0151 f\u00fcgg\u0151, de MSSQL eset\u00e9ben ez T-SQL. Manaps\u00e1g m\u00e1r egyre ink\u00e1bb kezd kikopni az a gyakorlat az iparb\u00f3l, hogy komolyabb \u00fczleti logik\u00e1t az adatb\u00e1zisban helyezz\u00fcnk el, mivel ezeknek az SQL dialektusoknak az eszk\u00f6zk\u00e9szlete ma m\u00e1r j\u00f3val korl\u00e1tosabb, mint egy magas szint\u0171 programoz\u00e1si nyelv\u00e9 (C#, Java). R\u00e1ad\u00e1sul a rendszer tesztelhet\u0151s\u00e9g\u00e9t nagyban rontja a t\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata. Ennek ellen\u00e9re n\u00e9ha indokolt lehet az adatb\u00e1zisban tartani valamennyi logik\u00e1t, amikor ki szeretn\u00e9nk azt haszn\u00e1lni, hogy az adatokhoz k\u00f6zel futnak a programk\u00f3djaink, pl. ha nem akarjuk megutaztatni a h\u00e1l\u00f3zaton az adatot egy egyszer\u0171 t\u00f6meges adatkarbantart\u00e1s \u00e9rdek\u00e9ben. \u00cdrjunk f\u00fcggv\u00e9nyt, mely ezt a t\u00e1rolt elj\u00e1r\u00e1st h\u00edvja private static void UpdateProduct ( int productID , string productName , decimal price ) { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( \"Product_Update\" , conn ); command . CommandType = CommandType . StoredProcedure ; command . Parameters . AddWithValue ( \"@ProductID\" , productID ); command . Parameters . AddWithValue ( \"@ProductName\" , productName ); command . Parameters . AddWithValue ( \"@UnitPrice\" , price ); conn . Open (); int affectedRows = command . ExecuteNonQuery (); Console . WriteLine ( $\"{affectedRows} rows affected\" ); } A Command -nak a t\u00e1rolt elj\u00e1r\u00e1s nev\u00e9t kellett megadni, \u00e9s a parancs t\u00edpus\u00e1t kellett \u00e1t\u00e1ll\u00edtani, egy\u00e9bk\u00e9nt szerkezetileg hasonl\u00edt a kor\u00e1bbi besz\u00far\u00f3 k\u00f3dra. H\u00edvjuk meg az \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l, p\u00e9ld\u00e1ul az al\u00e1bbi param\u00e9terez\u00e9ssel: UpdateProduct ( 1 , \"MyProduct\" , 50 ); Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, ellen\u0151rizz\u00fck a konzolban \u00e9s az SSOE-ben is, hogy m\u00f3dosult-e az 1-es azonos\u00edt\u00f3j\u00fa term\u00e9k. 5. Feladat - SQL Injection \u00b6 \u00cdrjuk meg a besz\u00far\u00f3 f\u00fcggv\u00e9nyt \u00fagy, hogy string interpol\u00e1ci\u00f3val rakja \u00f6ssze az SQL-t. private static void InsertShipper2 ( string companyName , string phone ) { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( $\"INSERT INTO Shippers(CompanyName, Phone) VALUES('{companyName}','{phone}')\" , conn ); conn . Open (); int affectedRows = command . ExecuteNonQuery (); Console . WriteLine ( $\"{affectedRows} row(s) inserted\" ); } H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l \u201especi\u00e1lisan\u201d param\u00e9terezve. InsertShipper2 ( \"Super Shipper\" , \"49-98562'); DELETE FROM Shippers;--\" ); \u00dagy \u00e1ll\u00edtottuk \u00f6ssze a m\u00e1sodik param\u00e9tert, hogy az lez\u00e1rja az eredeti utas\u00edt\u00e1st, ezut\u00e1n tetsz\u0151leges (!!!) SQL-t \u00edrhatunk, v\u00e9g\u00fcl kikommentezz\u00fck az erdeti utas\u00edt\u00e1s marad\u00e9k\u00e1t ( -- ). Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, hib\u00e1t kell kapjunk, mely arra utal, hogy valamelyik sz\u00e1ll\u00edt\u00f3 nem t\u00f6r\u00f6lhet\u0151 idegen kulcs hivatkoz\u00e1s miatt. Teh\u00e1t a DELETE FROM is lefutott! N\u00e9zz\u00fck meg debuggerrel (pl. a conn.Open utas\u00edt\u00e1son \u00e1llva), hogy mi a v\u00e9gleges SQL ( command.CommandText ). Tanuls\u00e1gok: SOSE f\u0171zz\u00fcnk \u00f6ssze programozottan SQL-t (semmilyen m\u00f3dszerrel), mert azzal kitessz\u00fck a k\u00f3dunkat SQL Injection alap\u00fa t\u00e1mad\u00e1snak. Az adatb\u00e1zis \u00e1ll\u00edtsa \u00f6ssze a v\u00e9gleges SQL-t SQL param\u00e9terek alapj\u00e1n, mert ilyenkor biztos\u00edtott, hogy a param\u00e9ter \u00e9rt\u00e9kek nem fognak SQL-k\u00e9nt \u00e9rtelmez\u0151dni (hi\u00e1ba \u00edrunk be SQL-t). Haszn\u00e1ljunk param\u00e9terezett SQL-t vagy t\u00e1rolt elj\u00e1r\u00e1st. Haszn\u00e1ljunk adatb\u00e1zis k\u00e9nyszereket, pl. a v\u00e9letlen t\u00f6rl\u00e9s ellen is v\u00e9d. Konfigur\u00e1ljunk adatb\u00e1zisban felhaszn\u00e1l\u00f3kat k\u00fcl\u00f6nb\u00f6z\u0151 jogosults\u00e1gokkal, a programunk connection string-j\u00e9ben megadott felhaszn\u00e1l\u00f3 csak a m\u0171k\u00f6d\u00e9shez sz\u00fcks\u00e9ges minim\u00e1lis jogokkal rendelkezzen. A mi eset\u00fcnkben nem adtunk meg felhaszn\u00e1l\u00f3t, a windows-os felhaszn\u00e1l\u00f3k\u00e9nt fogunk csatlakozni. H\u00edvjuk meg az eredeti (vagyis a biztons\u00e1gos, SQL param\u00e9tereket haszn\u00e1l\u00f3) besz\u00far\u00f3 f\u00fcggv\u00e9nyt a \u201especi\u00e1lis\u201d param\u00e9terez\u00e9ssel, hogy l\u00e1ssuk, m\u0171k\u00f6dik-e a v\u00e9delem: InsertShipper ( \"Super Shipper\" , \"49-98562'); DELETE FROM Shippers;--\" ); InsertShipper ( \"XXX');DELETE FROM Shippers;--\" , \"49-98562\" ); Az els\u0151n\u00e9l nem f\u00e9r\u00fcnk bele a m\u00e9retkorl\u00e1tba, a m\u00e1sodik lefut, de csak egy \u201efurcsa\u201d nev\u0171 sz\u00e1ll\u00edt\u00f3 ker\u00fclt be. A param\u00e9ter \u00e9rt\u00e9ke t\u00e9nyleg \u00e9rt\u00e9kk\u00e9nt \u00e9rtelmez\u0151d\u00f6tt nem pedig SQL-k\u00e9nt. Nem \u00fagy mint itt: 6. Feladat - T\u00f6rl\u00e9s \u00b6 \u00cdrjunk egy \u00faj f\u00fcggv\u00e9nyt, mely kit\u00f6r\u00f6l egy adott sz\u00e1ll\u00edt\u00f3t. private static void DeleteShipper ( int shipperID ) { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( \"DELETE FROM Shippers WHERE ShipperID = @ShipperID\" , conn ); command . Parameters . AddWithValue ( \"@ShipperID\" , shipperID ); conn . Open (); int affectedRows = command . ExecuteNonQuery (); Console . WriteLine ( $\"{affectedRows} row(s) affected\" ); } H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l, pl. 1-gyel param\u00e9terezve. Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Val\u00f3sz\u00edn\u0171leg kiv\u00e9telt kapunk, ugyanis van hivatkoz\u00e1s (idegen kulcs k\u00e9nyszerrel) az adott rekordra. SSOE-b\u0151l n\u00e9zz\u00fck ki az azonos\u00edt\u00f3j\u00e1t egy olyan sz\u00e1ll\u00edt\u00f3nak, melyet mi vett\u00fcnk fel. Adjuk \u00e1t ezt az azonos\u00edt\u00f3t a t\u00f6rl\u0151 f\u00fcggv\u00e9nynek \u2013 ezt m\u00e1r ki tudja t\u00f6r\u00f6lni, hiszen nincs r\u00e1 hivatkoz\u00e1s. T\u00f6rl\u00e9si strat\u00e9gi\u00e1k L\u00e1that\u00f3, hogy a t\u00f6rl\u00e9s igen kock\u00e1zatos \u00e9s kisz\u00e1m\u00edthatatlan m\u0171velet az idegen kulcs k\u00e9nyszerek miatt. N\u00e9h\u00e1ny m\u00f3dszer a t\u00f6rl\u00e9s kezel\u00e9s\u00e9re: nem enged\u00e9lyezz\u00fck a t\u00f6rl\u00e9st : Ha hivatkoznak a t\u00f6rlend\u0151 rekordra, az adatb\u00e1zis hib\u00e1val t\u00e9r vissza (ahogy fent is l\u00e1thattuk). kaszk\u00e1d t\u00f6rl\u00e9s \u2013 az idegen kulcs k\u00e9nyszeren be\u00e1ll\u00edthat\u00f3, hogy a hivatkozott rekord t\u00f6rl\u00e9sekor a hivatkoz\u00f3 rekord is t\u00f6rl\u0151dj\u00f6n. Gyakran ez oda vezet, hogy minden idegen kulcs k\u00e9nyszer\u00fcnk ilyen lesz, \u00e9s egy (v\u00e9letlen) t\u00f6rl\u00e9ssel v\u00e9gigt\u00f6r\u00f6lhetj\u00fck ak\u00e1r a teljes adatb\u00e1zist, azaz nehezen j\u00f3solhat\u00f3 a t\u00f6rl\u00e9s hat\u00e1sa. hivatkoz\u00e1s NULL-oz\u00e1sa \u2013 az idegen kulcs k\u00e9nyszeren be\u00e1ll\u00edthat\u00f3, hogy a hivatkozott rekord t\u00f6rl\u00e9sekor a hivatkoz\u00f3 rekord idegen kulcs mez\u0151je NULL \u00e9rt\u00e9k\u0171 legyen. Csak akkor alkalmazhat\u00f3, ha a modell\u00fcnkben az adott idegen kulcs mez\u0151 NULL -ozhat\u00f3. logikai t\u00f6rl\u00e9s (soft delete) \u2013 t\u00f6rl\u00e9s m\u0171velet helyett csak egy flag oszlopot (pl. IsDeleted ) \u00e1ll\u00edtunk be. El\u0151nye, hogy nem kell az idegen kulcs k\u00e9nyszerekkel foglalkoznunk, a t\u00f6r\u00f6lt adat rendelkez\u00e9sre \u00e1ll, ha sz\u00fcks\u00e9g lenne r\u00e1 (pl. undelete m\u0171velet). \u00c1m a m\u0171k\u00f6d\u00e9s bonyol\u00f3dik, mert foglalkozni kell azzal, hogy hogyan \u00e9s mikor sz\u0171rj\u00fck a t\u00f6r\u00f6lt rekordokat (pl. hogy ne jelenjenek meg a fel\u00fcleten, statisztik\u00e1kban), vagy hogyan kezelj\u00fck, ha egy nem t\u00f6r\u00f6lt rekord t\u00f6r\u00f6ltre hivatkozik. Kitekint\u00e9s \u00b6 A fenti ADO.NET alapm\u0171veleteket ebben az itt l\u00e1tott alapform\u00e1ban ritk\u00e1n haszn\u00e1lj\u00e1k k\u00e9t okb\u00f3l kifoly\u00f3an (m\u00e9g akkor is, ha ez a megk\u00f6zel\u00edt\u00e9s adja a legjobb teljes\u00edtm\u00e9nyt): Gyenge t\u00edpusoss\u00e1g (egy rekord adatait beolvasni egy oszt\u00e1ly property-jeibe igen k\u00f6r\u00fclm\u00e9nyes, cast-olni kell stb.) Stringbe k\u00f3dolt SQL (az elg\u00e9pel\u00e9sb\u0151l ered\u0151 hib\u00e1k csak fut\u00e1si id\u0151ben der\u00fclnek ki) Az el\u0151bbire megold\u00e1st jelenthetnek a k\u00fcl\u00f6nb\u00f6z\u0151 ADO.NET-et kieg\u00e9sz\u00edt\u0151 komponensek, pl.: Dapper PetaPoco Ezek a megold\u00e1sok egy minim\u00e1lis teljes\u00edtm\u00e9nyvesztes\u00e9g\u00e9rt cser\u00e9be nagyobb k\u00e9nyelmet k\u00edn\u00e1lnak. Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelentenek az ORM (Object-Relational-Mapping) rendszerek, cser\u00e9be ezek nagyobb overheaddel j\u00e1rnak, mint az el\u0151bb eml\u00edtett megold\u00e1sok. Az ORM-ek lek\u00e9pez\u00e9st alak\u00edtanak ki az adatb\u00e1zis \u00e9s az OO oszt\u00e1lyaink k\u00f6z\u00f6tt, \u00e9s ennek a lek\u00e9pez\u00e9snek a seg\u00edts\u00e9g\u00e9vel egyszer\u0171s\u00edtik az adatb\u00e1zis m\u0171veleteket. Az oszt\u00e1lyainkon v\u00e9gzett, t\u00edpusos k\u00f3ddal le\u00edrt m\u0171veleteinket automatikusan \u00e1tford\u00edtj\u00e1k a megfelel\u0151 adatb\u00e1zis m\u0171veletekre, \u00edgy a mem\u00f3riabeli objektummodell\u00fcnket szinkronban tartj\u00e1k az adatb\u00e1zissal. Az ORM-ek ebb\u0151l k\u00f6vetkez\u0151en kapcsolat n\u00e9lk\u00fcli modellt haszn\u00e1lnak. Ismertebb .NET-es ORM-ek: ADO.NET DataSet \u2013 els\u0151gener\u00e1ci\u00f3s ORM, ma m\u00e1r nagyon ritk\u00e1n haszn\u00e1ljuk. Entity Framework 6.x \u2013 (r\u00e9gi) .NET Framework leggyakrabban haszn\u00e1lt ORM keretrendszere Entity Framework Core (EF Core) \u2013 a jelenleg els\u0151dlegesen haszn\u00e1lt .NET ORM (open source) NHibernate \u2013 a java-s Hibernate .NET-es portja (open source) Az Entity Framework Core-ral r\u00e9szletesebben foglalkozunk az Adatvez\u00e9relt rendszerek specializ\u00e1ci\u00f3 t\u00e1rgyban illetve a Szofverfejleszt\u00e9s .NET platformon v\u00e1laszthat\u00f3 t\u00e1rgyban.","title":"5. Adatkezel\u00e9s"},{"location":"labor/5-adatkezeles/#5-adatkezeles","text":"","title":"5. Adatkezel\u00e9s"},{"location":"labor/5-adatkezeles/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9lja az ADO.NET programoz\u00e1si modellj\u00e9nek megismer\u00e9se \u00e9s a leggyakoribb adatkezel\u00e9si probl\u00e9m\u00e1k, buktat\u00f3k szeml\u00e9ltet\u00e9se alapvet\u0151 CRUD m\u0171veletek meg\u00edr\u00e1s\u00e1n kereszt\u00fcl. Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Adatkezel\u00e9s, ADO.NET alapismeretek.","title":"A gyakorlat c\u00e9lja"},{"location":"labor/5-adatkezeles/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer A gyakorlat sor\u00e1n Visual Studioban az SQL Server Object Explorer -t fogjuk haszn\u00e1lni az adatb\u00e1zis objektumok k\u00f6z\u00f6tti navig\u00e1l\u00e1s\u00e1ra \u00e9s a lek\u00e9rdez\u00e9sek futtat\u00e1s\u00e1ra. Ehhez sz\u00fcks\u00e9g lehet az SQL Server Data Tools komponensre, melyet legegyszer\u0171bben az Individual Components oldalon tudunk telep\u00edteni a Visual Studio Installer-ben, de a Data Storage and Processing workload is tartalmazza ezt. Gyakorlat Linuxon vagy Macen A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studiora k\u00e9sz\u00fclt, de - n\u00e9mik\u00e9ppen m\u00e1s \u00faton - elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is, mivel a .NET 6 SDK t\u00e1mogatott Linuxon \u00e9s Mac-en, Linuxon: Visual Studio helyett sz\u00f6vegszerkeszt\u0151vel (pl.: VSCode) \u00e9s CLI eszk\u00f6z\u00f6kkel. Az SQL szervernek van Linuxos v\u00e1ltozata, Mac-en pedig Dockerben futtathat\u00f3 (de Linuxon is tal\u00e1n a Docker legk\u00e9nyelmesebb m\u00f3d a futtat\u00e1s\u00e1ra). Az adatok vizualiz\u00e1ci\u00f3j\u00e1ra haszn\u00e1lhat\u00f3 a szint\u00e9n keresztplatformos Azure Data Studio eszk\u00f6z.","title":"El\u0151felt\u00e9telek"},{"location":"labor/5-adatkezeles/#bevezeto","text":"Megjegyz\u00e9s gyakorlatvezet\u0151knek Ezt a fejezetet gyakorlaton nem kell a le\u00edrtaknak megfelel\u0151 r\u00e9szletess\u00e9ggel ismertetni, a fontosabb fogalmakat azonban mindenk\u00e9ppen ismertess\u00fck r\u00f6viden.","title":"Bevezet\u0151"},{"location":"labor/5-adatkezeles/#adonet","text":"Alacsony szint\u0171 adatb\u00e1ziskezel\u00e9sre a .NET platformon az ADO.NET \u00e1ll rendelkez\u00e9sre, seg\u00edts\u00e9g\u00e9vel rel\u00e1ci\u00f3s adatb\u00e1zisokat tudunk el\u00e9rni. Az ADO.NET haszn\u00e1lata sor\u00e1n k\u00e9t elt\u00e9r\u0151 adathozz\u00e1f\u00e9r\u00e9si modellt alkalmazhatunk: Kapcsolatalap\u00fa modell Kapcsolat n\u00e9lk\u00fcli modell Az al\u00e1bbi k\u00e9t blokkot lenyitva \u00e1ttekint\u00e9st kaphatunk a k\u00e9t modell alapelv\u00e9r\u0151l. A Kapcsolatalap\u00fa modell alapelvei L\u00e9nyege az, hogy az adatb\u00e1ziskapcsolatot v\u00e9gig nyitva tartjuk, am\u00edg az adatokat lek\u00e9rdezz\u00fck, m\u00f3dos\u00edtjuk, majd a v\u00e1ltoztat\u00e1sokat az adatb\u00e1zisba vissza\u00edrjuk. A megold\u00e1sra DataReader objektumokat haszn\u00e1lhatunk (l\u00e1sd k\u00e9s\u0151bb). A megold\u00e1s el\u0151nye az egyszer\u0171s\u00e9g\u00e9ben rejlik (egyszer\u0171bb programoz\u00e1si modell \u00e9s konkurenciakezel\u00e9s). A megold\u00e1s h\u00e1tr\u00e1nya, hogy a folyamatosan fenntartott h\u00e1l\u00f3zati kapcsolat miatt sk\u00e1l\u00e1zhat\u00f3s\u00e1gi probl\u00e9m\u00e1k ad\u00f3dhatnak. Ez azt jelenti, hogy az adatkezel\u0151h\u00f6z t\u00f6rt\u00e9n\u0151 nagysz\u00e1m\u00fa p\u00e1rhuzamos felhaszn\u00e1l\u00f3i hozz\u00e1f\u00e9r\u00e9s eset\u00e9n folyamatosan nagysz\u00e1m\u00fa adatb\u00e1zis kapcsolat \u00e9l, ami adatkezel\u0151 rendszerek eset\u00e9n a teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l k\u00f6lts\u00e9ges er\u0151forr\u00e1snak sz\u00e1m\u00edt. \u00cdgy a fejleszt\u00e9s sor\u00e1n c\u00e9lszer\u0171 arra t\u00f6rekedni, hogy az adatb\u00e1zis kapcsolatokat miel\u0151bb z\u00e1rjuk le. A modell el\u0151nyei: Egyszer\u0171bb a konkurencia kezel\u00e9se Az adatok mindenhol a legfrissebbek Megjegyz\u00e9s: ezek az el\u0151ny\u00f6k akkor jelentkeznek, ha az adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9s az adatkezel\u0151 szigor\u00fa z\u00e1rakat haszn\u00e1l \u2013 ezt mi a hozz\u00e1f\u00e9r\u00e9s sor\u00e1n megfelel\u0151 tranzakci\u00f3 izol\u00e1ci\u00f3s szint megad\u00e1s\u00e1val tudjuk szab\u00e1lyozni. Ennek technik\u00e1i k\u00e9s\u0151bbi tanulm\u00e1nyok sor\u00e1n ker\u00fclnek ismertet\u00e9sre). H\u00e1tr\u00e1nyok: Folyamatos h\u00e1l\u00f3zati kapcsolat Sk\u00e1l\u00e1zhat\u00f3s\u00e1g A Kapcsolatn\u00e9lk\u00fcli modell alapelvei A kapcsolatalap\u00fa modellel ellent\u00e9tben az adatok megjelen\u00edt\u00e9se \u00e9s mem\u00f3ri\u00e1ban t\u00f6rt\u00e9n\u0151 m\u00f3dos\u00edt\u00e1sa sor\u00e1n nem tartunk fent adatb\u00e1zis kapcsolatot. Ennek megfelel\u0151en a f\u0151bb l\u00e9p\u00e9sek a k\u00f6vetkez\u0151k: a kapcsolat felv\u00e9tel\u00e9t \u00e9s az adatok lek\u00e9rdez\u00e9s\u00e9t k\u00f6vet\u0151en azonnal bontjuk a kapcsolatot. Az adatokat ezt k\u00f6vet\u0151en tipikusan megjelen\u00edtj\u00fck \u00e9s lehet\u0151s\u00e9get biztos\u00edtunk a felhaszn\u00e1l\u00f3nak az adatok m\u00f3dos\u00edt\u00e1s\u00e1ra (rekordok felv\u00e9tele, m\u00f3dos\u00edt\u00e1sa, t\u00f6rl\u00e9se ig\u00e9ny szerint). A m\u00f3dos\u00edt\u00e1sok ment\u00e9se sor\u00e1n \u00fajra felvessz\u00fck az adatkapcsolatot, mentj\u00fck az adatb\u00e1zisba a v\u00e1ltoztat\u00e1sokat \u00e9s z\u00e1rjuk a kapcsolatot. Term\u00e9szetesen a modell megk\u00f6veteli, hogy a lek\u00e9rdez\u00e9se \u00e9s a m\u00f3dos\u00edt\u00e1sok vissza\u00edr\u00e1sa k\u00f6z\u00f6tt \u2013 amikor nincs kapcsolatunk az adatb\u00e1zissal \u2013 az adatokat \u00e9s a v\u00e1ltoztat\u00e1sokat a mem\u00f3ri\u00e1ban nyilv\u00e1ntartsuk. Erre az ADO.NET k\u00f6rnyezetben nagyon k\u00e9nyelmes megold\u00e1st ny\u00fajt a DataSet objektumok alkalmaz\u00e1sa. A modell el\u0151nyei: Nem sz\u00fcks\u00e9ges folyamatos h\u00e1l\u00f3zati kapcsolat Sk\u00e1l\u00e1zhat\u00f3s\u00e1g H\u00e1tr\u00e1nyok Az adatok nem mindig a legfrissebbek \u00dctk\u00f6z\u00e9sek lehets\u00e9gesek Megjegyz\u00e9s: Sz\u00e1mos lehet\u0151s\u00e9g\u00fcnk van arra, hogy az objektumokat \u00e9s kapcsol\u00f3d\u00f3 v\u00e1ltoz\u00e1sokat nyilv\u00e1ntartsuk a mem\u00f3ri\u00e1ban. A DataSet csak az egyik lehets\u00e9ges technika. De haszn\u00e1lhatunk erre a c\u00e9lra k\u00f6z\u00f6ns\u00e9ges objektumokat, illetve ezek menedzsel\u00e9s\u00e9t megk\u00f6nny\u00edt\u0151 ADO.NET-n\u00e9l korszer\u0171bb .NET technol\u00f3gi\u00e1kat (pl. Entity Framework Core).","title":"ADO.NET"},{"location":"labor/5-adatkezeles/#a-kapcsolatalapu-modell","text":"A labor keret\u00e9ben a kapcsolatalap\u00fa modellt ismerj\u00fck meg. Az alapfolyamat a k\u00f6vetkez\u0151: Kapcsolat l\u00e9trehoz\u00e1sa az alkalmaz\u00e1s, illetve az adatb\u00e1zis kezel\u0151 rendszer k\u00f6z\u00f6tt ( Connection objektum felhaszn\u00e1l\u00e1s\u00e1val). A futtatand\u00f3 SQL utas\u00edt\u00e1s \u00f6ssze\u00e1ll\u00edt\u00e1s ( Command objektum felhaszn\u00e1l\u00e1s\u00e1val). Utas\u00edt\u00e1s futtat\u00e1sa ( Command objektum felhaszn\u00e1l\u00e1s\u00e1val). Lek\u00e9rdez\u00e9sek eset\u00e9n a visszakapott rekordhalmaz feldolgoz\u00e1sa ( DataReader objektum felhaszn\u00e1l\u00e1s\u00e1val). Erre a m\u00f3dos\u00edt\u00f3 parancsok eset\u00e9n \u00e9rtelemszer\u0171en nincs sz\u00fcks\u00e9g. Kapcsolat lez\u00e1r\u00e1sa. Mint a fentiekb\u0151l kider\u00fcl, az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3nak ebben a modellben h\u00e1rom f\u0151 \u00f6sszetev\u0151je van: Connection Command Data Reader Ezek az \u00f6sszetev\u0151k egy-egy oszt\u00e1lyk\u00e9nt jelennek meg, adatb\u00e1ziskezel\u0151f\u00fcggetlen r\u00e9sz\u00fck a BCL System.Data.Common n\u00e9vter\u00e9ben tal\u00e1lhat\u00f3 DbConnection , DbCommand , illetve DbDataReader n\u00e9ven. Ezek absztrakt oszt\u00e1lyok, az adatb\u00e1ziskezel\u0151k gy\u00e1rt\u00f3inak feladata, hogy ezekb\u0151l lesz\u00e1rmazva meg\u00edrj\u00e1k a konkr\u00e9t adatb\u00e1ziskezel\u0151ket t\u00e1mogat\u00f3 v\u00e1ltozatokat. Mindh\u00e1rom ADO.NET \u00f6sszetev\u0151 t\u00e1mogatja a Dispose mint\u00e1t, \u00edgy using blokkban haszn\u00e1lhat\u00f3 \u2013 haszn\u00e1ljuk is \u00edgy, amikor csak tudjuk. Az adatb\u00e1ziskezel\u0151 \u00e1ltal\u00e1ban m\u00e1sik g\u00e9pen tal\u00e1lhat\u00f3, mint ahol a k\u00f3dunk fut (a labor sor\u00e1n pont nem :)), \u00edgy tekints\u00fcnk ezekre, mint t\u00e1voli h\u00e1l\u00f3zati er\u0151forr\u00e1sokra. A Microsoft SQL Servert t\u00e1mogat\u00f3 v\u00e1ltozat a Microsoft.Data.SqlClient NuGet csomagban, az \u201eSql\u201d prefix\u0171 oszt\u00e1lyokban tal\u00e1lhat\u00f3k ( SqlConnection , SqlCommand \u00e9s SqlDataReader ). A t\u00f6bbi gy\u00e1rt\u00f3 k\u00fcl\u00f6n dll-(ek)be teszi a saj\u00e1t v\u00e1ltozat\u00e1t, az \u00edgy l\u00e9trej\u00f6tt komponenst data providernek nevezik. Teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl n\u00e9h\u00e1ny p\u00e9lda: PostgreSQL SQLite Oracle","title":"A kapcsolatalap\u00fa modell"},{"location":"labor/5-adatkezeles/#connection","text":"Ez teremti meg a kapcsolatot a programunk, illetve az adatb\u00e1ziskezel\u0151-rendszer k\u00f6z\u00f6tt. Inicializ\u00e1l\u00e1s\u00e1hoz sz\u00fcks\u00e9g van egy connection string-re, mely a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9hez sz\u00fcks\u00e9ges adatokat adja meg a driver sz\u00e1m\u00e1ra. Adatb\u00e1zisgy\u00e1rt\u00f3nk\u00e9nt elt\u00e9r\u0151 a bels\u0151 form\u00e1tuma ( b\u0151vebben ). \u00daj Connection p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem biztos, hogy t\u00e9nyleg \u00faj kapcsolat fog l\u00e9trej\u00f6nni az adatb\u00e1zis fel\u00e9, a driverek \u00e1ltal\u00e1ban connection pooling-ot alkalmaznak, hasonl\u00f3an, mint a thread pool eset\u00e9ben, \u00fajrahaszn\u00e1lhatj\u00e1k a kor\u00e1bbi (\u00e9ppen nem haszn\u00e1lt) kapcsolatokat. A Connection k\u00fcl\u00f6n\u00f6sen k\u00f6lts\u00e9ges nem fel\u00fcgyelt er\u0151forr\u00e1sokat haszn\u00e1l, \u00edgy kiemelten fontos, hogy a lehet\u0151 leghamarabb gondoskodjunk lez\u00e1r\u00e1s\u00e1r\u00f3l , amikor m\u00e1r nincs r\u00e1 sz\u00fcks\u00e9g (pl. a Dispose() h\u00edv\u00e1s\u00e1val, amit az esetek t\u00f6bbs\u00e9g\u00e9ben legegyszer\u0171bben a using blokk alkalmaz\u00e1s\u00e1val tehet\u00fcnk meg).","title":"Connection"},{"location":"labor/5-adatkezeles/#command","text":"Ennek seg\u00edts\u00e9g\u00e9vel vagyunk k\u00e9pesek \u201eutas\u00edt\u00e1sokat\u201d megfogalmazni az adatb\u00e1zis kezel\u0151 sz\u00e1m\u00e1ra. Ezeket SQL nyelven kell megfogalmaznunk. A Command -nak be kell \u00e1ll\u00edtani egy kapcsolatot \u2013 ezen kereszt\u00fcl fog a parancs v\u00e9grehajt\u00f3dni. A parancsnak k\u00fcl\u00f6nb\u00f6z\u0151 eredm\u00e9nye lehet, ennek megfelel\u0151en k\u00fcl\u00f6nb\u00f6z\u0151 f\u00fcggv\u00e9nyekkel futtatjuk a parancsot: ExecuteReader : Eredm\u00e9nyhalmaz (result set) lek\u00e9rdez\u00e9se ExecuteScalar : Skal\u00e1r \u00e9rt\u00e9k lek\u00e9rdez\u00e9se ExecuteNonQuery : Nincs visszat\u00e9r\u00e9si \u00e9rt\u00e9k (Pl: INSERT, UPDATE \u00e9s DELETE), viszont a m\u0171velet k\u00f6vetkezt\u00e9ben \u00e9rintett rekordok sz\u00e1m\u00e1t visszakapjuk","title":"Command"},{"location":"labor/5-adatkezeles/#data-reader","text":"Ha a parancs eredm\u00e9nye eredm\u00e9nyhalmaz, akkor ennek a komponensnek a seg\u00edts\u00e9g\u00e9vel tudjuk az adatokat kiolvasni. Az eredm\u00e9nyhalmaz egy t\u00e1bl\u00e1zatnak tekinthet\u0151, a Data Reader ezen tud soronk\u00e9nt v\u00e9gignavig\u00e1lni (csak egyes\u00e9vel el\u0151refel\u00e9!). A kurzor egyszerre egy soron \u00e1ll, ha a sorb\u00f3l a sz\u00fcks\u00e9ges adatokat kiolvastuk, a kurzort egy sorral el\u0151re l\u00e9ptethetj\u00fck. Csak az aktu\u00e1lis sorb\u00f3l tudunk olvasni. Kezdetben a kurzor nem az els\u0151 soron \u00e1ll, azt egyszer l\u00e9ptetn\u00fcnk kell, hogy az els\u0151 sorra \u00e1lljon. Megjegyz\u00e9s: navig\u00e1l\u00e1s kliens oldalon t\u00f6rt\u00e9nik a mem\u00f3ri\u00e1ban, nincs k\u00f6ze az egyes adatkezel\u0151k \u00e1ltal t\u00e1mogatott kiszolg\u00e1l\u00f3 oldali kurzorokhoz.","title":"Data Reader"},{"location":"labor/5-adatkezeles/#1-feladat-adatbazis-elokeszitese","text":"Els\u0151k\u00e9nt sz\u00fcks\u00e9g\u00fcnk van egy adatb\u00e1ziskezel\u0151re. Ezt val\u00f3s k\u00f6rnyezetben dedik\u00e1lt szerveren fut\u00f3, adatb\u00e1zis adminisztr\u00e1torok \u00e1ltal fel\u00fcgyelt, teljes\u00e9rt\u00e9k\u0171 adatb\u00e1ziskezel\u0151k jelentik. Fejleszt\u00e9si id\u0151ben, lok\u00e1lis tesztel\u00e9shez azonban k\u00e9nyelmesebb egy fejleszt\u0151i adatb\u00e1ziskezel\u0151 haszn\u00e1lata. A Visual Studio telep\u00edt\u00e9s\u00e9nek r\u00e9szek\u00e9nt kapunk is egy ilyen adatb\u00e1zismotort, ez a LocalDB, mely a teljes\u00e9rt\u00e9k\u0171 SQL Server egyszer\u0171s\u00edtett v\u00e1ltozata. F\u0151bb tulajdons\u00e1gai: nem csak a Visual Studio-val, hanem k\u00fcl\u00f6n is telep\u00edthet\u0151, az adatb\u00e1zismotor szinte teljes m\u00e9rt\u00e9kben kompatibilis a teljes\u00e9rt\u00e9k\u0171 Microsoft SQL Serverrel, alapvet\u0151en arr\u00f3l a g\u00e9pr\u0151l \u00e9rhet\u0151 el, melyre telep\u00edtett\u00fck, t\u00f6bb p\u00e9ld\u00e1ny is l\u00e9trehozhat\u00f3 ig\u00e9ny szerint, a p\u00e9ld\u00e1nyok alapvet\u0151en a l\u00e9trehoz\u00f3 oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3ja sz\u00e1m\u00e1ra \u00e9rhet\u0151k el (ig\u00e9ny eset\u00e9n megoszthat\u00f3 egy p\u00e9ld\u00e1ny a felhaszn\u00e1l\u00f3k k\u00f6z\u00f6tt), a saj\u00e1t p\u00e9ld\u00e1nyok kezel\u00e9se (l\u00e9trehoz\u00e1s, t\u00f6rl\u00e9s, stb.) nem ig\u00e9nyel adminisztr\u00e1tori jogokat. ssqllocaldb parancssori eszk\u00f6z A gyakorlat sor\u00e1n nincs sz\u00fcks\u00e9g\u00fcnk erre, de a p\u00e9ld\u00e1nyok kezel\u00e9s\u00e9re az sqllocaldb parancssori eszk\u00f6z haszn\u00e1lhat\u00f3. N\u00e9h\u00e1ny parancs, melyet az sqllocaldb ut\u00e1n be\u00edrva alkalmazhatunk: Paracs Le\u00edr\u00e1s info az aktu\u00e1lis felhaszn\u00e1\u00e1l\u00f3 sz\u00e1m\u00e1ra l\u00e1that\u00f3 p\u00e9ld\u00e1nyok list\u00e1ja create \u201elocdb\u201d \u00faj p\u00e9ld\u00e1ny l\u00e9trehoz\u00e1sa \u201elocdb\u201d n\u00e9vvel delete \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny t\u00f6rl\u00e9se start \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny ind\u00edt\u00e1sa stop \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny le\u00e1ll\u00edt\u00e1sa A Visual Studio is telep\u00edt, illetve ind\u00edt LocalDB p\u00e9ld\u00e1nyokat, ez\u00e9rt \u00e9rdemes megn\u00e9zni, hogy a Visual Studio alapesetben milyen p\u00e9ld\u00e1nyokat l\u00e1t. Ind\u00edtsuk el a Visual Studio-t, a View men\u00fcb\u0151l v\u00e1lasszuk az SQL Server Object Explorer-t (SSOE). Nyissuk ki az SQL Server csom\u00f3pontot, ha alatta l\u00e1tunk tov\u00e1bbi csom\u00f3pontokat, akkor nyert \u00fcgy\u00fcnk van, nyissuk ki valamelyiket (ilyenkor indul el a p\u00e9ld\u00e1ny, ha nincs elind\u00edtva, \u00edgy lehet, hogy v\u00e1rni kell kicsit). Ha nem jelent meg semmi, akkor parancssorb\u00f3l az mssqllocaldb info parancs megadja a l\u00e9tez\u0151 p\u00e9ld\u00e1nyokat. V\u00e1lasszuk az SQL Server csom\u00f3ponton jobbklikkelve az Add SQL Server opci\u00f3t, majd adjuk meg valamelyik l\u00e9tez\u0151 p\u00e9ld\u00e1nyt, pl.: (localdb)\\MSSQLLocalDB A megjelen\u0151 Databases csom\u00f3ponton v\u00e1lasszuk a New Database opci\u00f3t, itt adjunk meg egy adatb\u00e1zisnevet. (Laboron, mivel t\u00f6bb hallgat\u00f3 is haszn\u00e1lhatja ugyanazt az oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3t, javasolt a Neptun k\u00f3d, mint n\u00e9v haszn\u00e1lata). Az \u00faj adatb\u00e1zis csom\u00f3pontj\u00e1n jobbklikkelve v\u00e1lasszuk a New Query opci\u00f3t, ami egy \u00faj query ablakot nyit. Nyissuk meg vagy t\u00f6lts\u00fck le a Northwind adatb\u00e1zis inicializ\u00e1l\u00f3 szkriptet . M\u00e1soljuk be a teljes szkriptet a query ablakba. Futtassuk le a szkriptet a kis z\u00f6ld ny\u00edllal ( Execute ). Figyelj\u00fcnk oda, hogy j\u00f3 adatb\u00e1zis (melyet fenti 4. l\u00e9p\u00e9sben hoztunk l\u00e9tre) legyen kiv\u00e1lasztva a query ablak tetej\u00e9n a leg\u00f6rd\u00fcl\u0151ben !. Ellen\u0151rizz\u00fck, hogy az adatb\u00e1zisunkban megjelentek-e t\u00e1bl\u00e1k, n\u00e9zetek. Fedezz\u00fck fel az SSOE legfontosabb funkci\u00f3it (t\u00e1bl\u00e1k adatainak, s\u00e9m\u00e1j\u00e1nak lek\u00e9rdez\u00e9se stb.). MSSQL menedzsment eszk\u00f6z\u00f6k A Visual Studio-ban k\u00e9t eszk\u00f6zzel is kezelhet\u00fcnk adatb\u00e1zisokat: a Server Explorer-rel \u00e9s az SQL Server Object Explorer-rel is. El\u0151bbi egy \u00e1ltal\u00e1nosabb eszk\u00f6z, mely nem csak adatb\u00e1zis, hanem egy\u00e9b szerver er\u0151forr\u00e1sok (pl. Azure szerverek) kezel\u00e9s\u00e9re is alkalmas, m\u00edg a m\u00e1sik kifejezetten csak adatb\u00e1ziskezel\u00e9sre van kihegyezve. Mindkett\u0151 el\u00e9rhet\u0151 a View men\u00fcb\u0151l \u00e9s mindkett\u0151 hasonl\u00f3 funkci\u00f3kat ad adatb\u00e1ziskezel\u00e9shez, ez\u00e9rt ebben a m\u00e9r\u00e9sben csak az egyiket (SQL Server Object Explorer) haszn\u00e1ljuk. Amikor nem \u00e1ll rendelkez\u00e9s\u00fcnkre a Visual Studio fejleszt\u0151k\u00f6rnyezet, akkor az adatb\u00e1zisunk menedzsel\u00e9s\u00e9re az (ingyenes) SQL Server Management Studio-t vagy a szint\u00e9n ingyenes \u00e9s multiplatform Azure Data Studio-t tudjuk haszn\u00e1lni.","title":"1. Feladat \u2013 Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se"},{"location":"labor/5-adatkezeles/#2-feladat-lekerdezes-adonet-sqldatareader-rel","text":"A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely haszn\u00e1lja a Northwind adatb\u00e1zis Shippers t\u00e1bl\u00e1j\u00e1nak rekordjait. Hozzunk l\u00e9tre egy C# nyelv\u0171 konzolos alkalmaz\u00e1st. A projekt t\u00edpusa Console App legyen, \u00e9s NE a Console App (.NET Framework) : A projekt neve legyen AdoExample A Target Framework legyen .NET 6 Pip\u00e1ljuk be a Do not use top-level statements kapcsol\u00f3t Keress\u00fck ki a connection stringet az SSOE-b\u0151l: jobbklikk az adatb\u00e1ziskapcsolatunkon (pirossal jel\u00f6lve az al\u00e1bbi \u00e1br\u00e1n) / Properties. M\u00e1soljuk a Properties ablakb\u00f3l Connection String tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t egy v\u00e1ltoz\u00f3ba a Program oszt\u00e1lyba. private const string ConnString = @\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=neptun;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\" ; SQL Server connection string form\u00e1tuma MSSQL eset\u00e9ben a connection string kulcs \u00e9rt\u00e9k p\u00e1rokat tartalmaz pontosvessz\u0151vel elv\u00e1lasztva. A Data Source kulcs alatt az SQL szerver p\u00e9ld\u00e1ny neve, az Initial Catalog kulcs alatt az adatb\u00e1zis neve szerepel. Az Integrated Security=true kapcsol\u00f3 pedig a Windows authentik\u00e1ci\u00f3t jelenti. @-os string (C# verbatim string) A @ egy speci\u00e1lis karakter (verbatim indentifier), amit itt arra haszn\u00e1lunk, hogy a connection string-ben megjelen\u0151 backslash karakter ( \\ ) ne felold\u00f3jelk\u00e9nt (escape character) ker\u00fclj\u00f6n \u00e9rtelmez\u00e9sre. Vegy\u00fck fel a projektbe a Microsoft.Data.SqlClient NuGet csomagot. Ezt k\u00e9tf\u00e9lek\u00e9ppen tehetj\u00fck meg: A) Visual Studio NuGet kezel\u0151ben: Projekten jobb gomb / Manage NuGet Packages... , a megjelen\u0151 oldalon Browse oldalra v\u00e1lt\u00e1s. A keres\u0151be Microsoft.Data.SqlClient be\u00edr\u00e1sa. A Version mez\u0151ben az 5.0.1 kiv\u00e1laszt\u00e1sa (laboron az\u00e9rt v\u00e1laszuk ki ezt a verzi\u00f3t, mert ez szerepel a g\u00e9peken a NuGet cache-ben, otthoni gyakorl\u00e1s sor\u00e1n v\u00e1lasszuk ink\u00e1bb a Latest stable -t). B) Bem\u00e1soljuk az al\u00e1bbi csomag referenci\u00e1t a a projektf\u00e1jlba: <ItemGroup> <PackageReference Include= \"Microsoft.Data.SqlClient\" Version= \"5.0.1\" /> </ItemGroup> NuGet csomagkezel\u0151 A NuGet egy olyan online csomagkezel\u0151 rendszer, ahonnan .NET alap\u00fa projektjeinbe tudunk k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket, oszt\u00e1lyk\u00f6nyvt\u00e1rakat egyszer\u0171en, verzi\u00f3zott form\u00e1ban behivatkozni. B\u0151vebben az els\u0151 el\u0151ad\u00e1son szerepel. \u00cdrjunk lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyt, mely lek\u00e9rdezi az \u00f6sszes sz\u00e1ll\u00edt\u00f3t: private static void GetShippers () { using ( var conn = new SqlConnection ( ConnString )) using ( var command = new SqlCommand ( \"SELECT ShipperID, CompanyName, Phone FROM Shippers\" , conn )) { conn . Open (); Console . WriteLine ( \"{0,-10}{1,-20}{2,-20}\" , \"ShipperID\" , \"CompanyName\" , \"Phone\" ); Console . WriteLine ( new string ( '-' , 60 )); using ( SqlDataReader reader = command . ExecuteReader ()) { while ( reader . Read ()) { Console . WriteLine ( $\"{reader[\" ShipperID \"],-10}\" + $\"{reader[\" CompanyName \"],-20}\" + $\"{reader[\" Phone \"],-20}\" ); } } } } A kapcsolat alap\u00fa modell folyamata Kapcsolat, parancs inicializ\u00e1l\u00e1sa Kapcsolat megnyit\u00e1sa Parancs futtat\u00e1sa Eredm\u00e9ny feldolgoz\u00e1sa Kapcsolat bont\u00e1sa, takar\u00edt\u00e1s N\u00e9h\u00e1ny megjegyz\u00e9s a k\u00f3dhoz A DataReader -t a parancs futtat\u00e1s\u00e1nak eredm\u00e9nyek\u00e9nt kapjuk meg, nem pedig k\u00f6zvetlen\u00fcl p\u00e9ld\u00e1nyos\u00edtjuk A parancs futtat\u00e1sa el\u0151tt meg kell nyitnunk a kapcsolatot A DbConnection p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem nyit\u00f3dik meg a kapcsolat (nem t\u00f6rt\u00e9nik h\u00e1l\u00f3zati kommunik\u00e1ci\u00f3) A DataReader.Read() f\u00fcggv\u00e9nye mutatja, hogy van-e m\u00e9g adat az eredm\u00e9nyhalmazban A DataReader -t az eredm\u00e9nyhalmazban tal\u00e1lhat\u00f3 oszlopok nev\u00e9vel indexelhetj\u00fck \u2013 az eredm\u00e9ny object lesz, \u00edgy, ha konkr\u00e9tabb t\u00edpusra van sz\u00fcks\u00e9g\u00fcnk cast-olni kell A ford\u00edt\u00f3 nem \u00e9rtelmezi az SQL parancs sz\u00f6veg\u00e9t (az csak egy string), hanem majd csak az adatb\u00e1zis, \u00edgy hib\u00e1s SQL eset\u00e9n csak fut\u00e1si idej\u0171 kiv\u00e9telt kapunk Figyelj\u00fck meg, hogy az adatb\u00e1zis s\u00e9ma v\u00e1ltoz\u00e1sa eset\u00e9n, pl. egy oszlop \u00e1tnevez\u00e9se ut\u00e1n, h\u00e1ny helyen kell k\u00e9zzel \u00e1t\u00edrni string-eket a k\u00f3dban $ -ral prefixelve string interpol\u00e1ci\u00f3t alkalmazhatunk, azaz k\u00f6zvetlen\u00fcl a stringbe \u00e1gyazhatunk ki\u00e9rt\u00e9kelend\u0151 kifejez\u00e9seket (C# 6-os k\u00e9pess\u00e9g). A $@ seg\u00edts\u00e9g\u00e9vel t\u00f6bbsoros string interpol\u00e1ci\u00f3s kifejez\u00e9seket \u00edrhatunk (a sort\u00f6r\u00e9st a {}-k k\u00f6z\u00f6tt kell betenn\u00fcnk, k\u00fcl\u00f6nben a kimeneten is megjelenik). \u00c9rdekess\u00e9g: C# 8-t\u00f3l f\u00f6lfele b\u00e1rmilyen sorrendben \u00edrhatjuk a $ \u00e9s @ karaktereket, teh\u00e1t a $@ \u00e9s a @$ is helyesnek sz\u00e1m\u00edt. A using kulcssz\u00fa blokk utas\u00edt\u00e1s helyett egysoros kifejez\u00e9sk\u00e9nt is haszn\u00e1lhat\u00f3. Ilyen esetben a using blokk v\u00e9ge az tartalmaz\u00f3 blokkig tart (eset\u00fcnkben a f\u00fcggv\u00e9ny v\u00e9g\u00e9ig.). Ezzel cs\u00f6kkenthet\u0151 a beh\u00faz\u00e1sok sz\u00e1ma, de ne legyen automatikus reflex a haszn\u00e1lata, mert el\u0151fordulhat, hogy hamarabb c\u00e9lszer\u0171 kik\u00e9nyszer\u00edteni az er\u0151forr\u00e1sok felszabad\u00edt\u00e1s\u00e1t, mint a tartalmaz\u00f3 blokk v\u00e9ge. private static void GetShippers () { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( \"SELECT ShipperID, CompanyName, Phone FROM Shippers\" , conn ); conn . Open (); Console . WriteLine ( \"{0,-10}{1,-20}{2,-20}\" , \"ShipperID\" , \"CompanyName\" , \"Phone\" ); Console . WriteLine ( new string ( '-' , 60 )); using var reader = command . ExecuteReader (); while ( reader . Read ()) { Console . WriteLine ( $\"{reader[\" ShipperID \"],-10}\" + $\"{reader[\" CompanyName \"],-20}\" + $\"{reader[\" Phone \"],-20}\" ); } } A tov\u00e1bbiakban ezt a m\u00f3dszert haszn\u00e1ljuk a beh\u00faz\u00e1sok \u00e9s z\u00e1r\u00f3jelek megsp\u00f3rol\u00e1sa \u00e9rdek\u00e9ben. H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l. private static void Main ( string [] args ) { GetShippers (); } Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Rontsuk el az SQL-t, \u00e9s \u00fagy is pr\u00f3b\u00e1ljuk ki.","title":"2. Feladat \u2013 Lek\u00e9rdez\u00e9s ADO.NET SqlDataReader-rel"},{"location":"labor/5-adatkezeles/#3-feladat-beszuras-sql-utasitassal","text":"\u00cdrjunk f\u00fcggv\u00e9nyt, mely \u00faj sz\u00e1ll\u00edt\u00f3t sz\u00far be az adatb\u00e1zisba: private static void InsertShipper ( string companyName , string phone ) { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( \"INSERT INTO Shippers(CompanyName, Phone) VALUES(@name,@phone)\" , conn ); command . Parameters . AddWithValue ( \"@name\" , companyName ); command . Parameters . AddWithValue ( \"@phone\" , phone ); conn . Open (); int affectedRows = command . ExecuteNonQuery (); Console . WriteLine ( $\"{affectedRows} rows affected\" ); } Itt olyan SQL-t kell \u00edrnunk, melynek az \u00f6ssze\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l k\u00edv\u00fclr\u0151l kapott v\u00e1ltoz\u00f3k \u00e9rt\u00e9keit is felhaszn\u00e1ltuk. A string \u00f6sszerak\u00e1s\u00e1hoz egyszer\u0171en a sztring \u00f6sszef\u0171z\u00e9s oper\u00e1tort, sztring interpol\u00e1ci\u00f3t vagy string.Format -ot is haszn\u00e1lhattunk volna, de ez biztons\u00e1gi kock\u00e1zatot (SQL Injection \u2013 b\u0151vebben l\u00e1sd lentebb) rejt \u2013 SOHA!!! ne rakjuk \u00f6ssze az SQL-t stringm\u0171velettel . Helyette \u00edrjuk meg \u00fagy az SQL-t, hogy ahov\u00e1 a v\u00e1ltoz\u00f3k \u00e9rt\u00e9keit \u00edrn\u00e1nk, oda param\u00e9terhivatkoz\u00e1sokat tesz\u00fcnk. SQL Server eset\u00e9ben a hivatkoz\u00e1s szintaxisa: @paramn\u00e9v. A parancs futtat\u00e1s\u00e1hoz a param\u00e9terek \u00e9rt\u00e9keit is \u00e1t kell adnunk az adatb\u00e1zisnak, ugyanis az fogja elv\u00e9gezni a param\u00e9terek hely\u00e9re az \u00e9rt\u00e9kek behelyettes\u00edt\u00e9s\u00e9t. A besz\u00far\u00e1si parancs kimenete nem eredm\u00e9nyhalmaz, \u00edgy az ExecuteNonQuery m\u0171velettel kell futtatnuk, mely visszaadja besz\u00fart sorok sz\u00e1m\u00e1t. H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l. GetShippers (); InsertShipper ( \"Super Shipper\" , \"49-98562\" ); GetShippers (); Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, ellen\u0151rizz\u00fck a konzolban \u00e9s az SSOE-ben is, hogy beker\u00fclt az \u00faj sor. Az SSOE-ben val\u00f3 gyors \u00e9s k\u00e9nyelmes ellen\u0151rz\u00e9shez a Shippers t\u00e1bla context men\u00fcj\u00e9b\u0151l v\u00e1lasszuk a View Data lehet\u0151s\u00e9get.","title":"3. Feladat \u2013 Besz\u00far\u00e1s SQL utas\u00edt\u00e1ssal"},{"location":"labor/5-adatkezeles/#4-feladat-modositas-tarolt-eljarassal","text":"Tanulm\u00e1nyozzuk SSOE-ben a Product_Update t\u00e1rolt elj\u00e1r\u00e1s k\u00f3dj\u00e1t. Ehhez nyissuk le a Programmability alatt tal\u00e1lhat\u00f3 Stored Procedures csom\u00f3pontot, majd a Product_Update t\u00e1rolt elj\u00e1r\u00e1s context men\u00fcj\u00e9b\u0151l v\u00e1lasszuk a View Code lehet\u0151s\u00e9get. Programk\u00f3d az adatb\u00e1zisban A nagyobb adatkezel\u0151 rendszerek lehet\u0151s\u00e9get biztos\u00edtanak arra, hogy programk\u00f3dot defini\u00e1ljunk mag\u00e1ban az adatkezel\u0151 adatb\u00e1zis\u00e1ban. Ezeket t\u00e1rol elj\u00e1r\u00e1soknak (stored procedure) nevezz\u00fck. A nyelve adatkezel\u0151 f\u00fcgg\u0151, de MSSQL eset\u00e9ben ez T-SQL. Manaps\u00e1g m\u00e1r egyre ink\u00e1bb kezd kikopni az a gyakorlat az iparb\u00f3l, hogy komolyabb \u00fczleti logik\u00e1t az adatb\u00e1zisban helyezz\u00fcnk el, mivel ezeknek az SQL dialektusoknak az eszk\u00f6zk\u00e9szlete ma m\u00e1r j\u00f3val korl\u00e1tosabb, mint egy magas szint\u0171 programoz\u00e1si nyelv\u00e9 (C#, Java). R\u00e1ad\u00e1sul a rendszer tesztelhet\u0151s\u00e9g\u00e9t nagyban rontja a t\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata. Ennek ellen\u00e9re n\u00e9ha indokolt lehet az adatb\u00e1zisban tartani valamennyi logik\u00e1t, amikor ki szeretn\u00e9nk azt haszn\u00e1lni, hogy az adatokhoz k\u00f6zel futnak a programk\u00f3djaink, pl. ha nem akarjuk megutaztatni a h\u00e1l\u00f3zaton az adatot egy egyszer\u0171 t\u00f6meges adatkarbantart\u00e1s \u00e9rdek\u00e9ben. \u00cdrjunk f\u00fcggv\u00e9nyt, mely ezt a t\u00e1rolt elj\u00e1r\u00e1st h\u00edvja private static void UpdateProduct ( int productID , string productName , decimal price ) { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( \"Product_Update\" , conn ); command . CommandType = CommandType . StoredProcedure ; command . Parameters . AddWithValue ( \"@ProductID\" , productID ); command . Parameters . AddWithValue ( \"@ProductName\" , productName ); command . Parameters . AddWithValue ( \"@UnitPrice\" , price ); conn . Open (); int affectedRows = command . ExecuteNonQuery (); Console . WriteLine ( $\"{affectedRows} rows affected\" ); } A Command -nak a t\u00e1rolt elj\u00e1r\u00e1s nev\u00e9t kellett megadni, \u00e9s a parancs t\u00edpus\u00e1t kellett \u00e1t\u00e1ll\u00edtani, egy\u00e9bk\u00e9nt szerkezetileg hasonl\u00edt a kor\u00e1bbi besz\u00far\u00f3 k\u00f3dra. H\u00edvjuk meg az \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l, p\u00e9ld\u00e1ul az al\u00e1bbi param\u00e9terez\u00e9ssel: UpdateProduct ( 1 , \"MyProduct\" , 50 ); Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, ellen\u0151rizz\u00fck a konzolban \u00e9s az SSOE-ben is, hogy m\u00f3dosult-e az 1-es azonos\u00edt\u00f3j\u00fa term\u00e9k.","title":"4. Feladat - M\u00f3dos\u00edt\u00e1s t\u00e1rolt elj\u00e1r\u00e1ssal"},{"location":"labor/5-adatkezeles/#5-feladat-sql-injection","text":"\u00cdrjuk meg a besz\u00far\u00f3 f\u00fcggv\u00e9nyt \u00fagy, hogy string interpol\u00e1ci\u00f3val rakja \u00f6ssze az SQL-t. private static void InsertShipper2 ( string companyName , string phone ) { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( $\"INSERT INTO Shippers(CompanyName, Phone) VALUES('{companyName}','{phone}')\" , conn ); conn . Open (); int affectedRows = command . ExecuteNonQuery (); Console . WriteLine ( $\"{affectedRows} row(s) inserted\" ); } H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l \u201especi\u00e1lisan\u201d param\u00e9terezve. InsertShipper2 ( \"Super Shipper\" , \"49-98562'); DELETE FROM Shippers;--\" ); \u00dagy \u00e1ll\u00edtottuk \u00f6ssze a m\u00e1sodik param\u00e9tert, hogy az lez\u00e1rja az eredeti utas\u00edt\u00e1st, ezut\u00e1n tetsz\u0151leges (!!!) SQL-t \u00edrhatunk, v\u00e9g\u00fcl kikommentezz\u00fck az erdeti utas\u00edt\u00e1s marad\u00e9k\u00e1t ( -- ). Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, hib\u00e1t kell kapjunk, mely arra utal, hogy valamelyik sz\u00e1ll\u00edt\u00f3 nem t\u00f6r\u00f6lhet\u0151 idegen kulcs hivatkoz\u00e1s miatt. Teh\u00e1t a DELETE FROM is lefutott! N\u00e9zz\u00fck meg debuggerrel (pl. a conn.Open utas\u00edt\u00e1son \u00e1llva), hogy mi a v\u00e9gleges SQL ( command.CommandText ). Tanuls\u00e1gok: SOSE f\u0171zz\u00fcnk \u00f6ssze programozottan SQL-t (semmilyen m\u00f3dszerrel), mert azzal kitessz\u00fck a k\u00f3dunkat SQL Injection alap\u00fa t\u00e1mad\u00e1snak. Az adatb\u00e1zis \u00e1ll\u00edtsa \u00f6ssze a v\u00e9gleges SQL-t SQL param\u00e9terek alapj\u00e1n, mert ilyenkor biztos\u00edtott, hogy a param\u00e9ter \u00e9rt\u00e9kek nem fognak SQL-k\u00e9nt \u00e9rtelmez\u0151dni (hi\u00e1ba \u00edrunk be SQL-t). Haszn\u00e1ljunk param\u00e9terezett SQL-t vagy t\u00e1rolt elj\u00e1r\u00e1st. Haszn\u00e1ljunk adatb\u00e1zis k\u00e9nyszereket, pl. a v\u00e9letlen t\u00f6rl\u00e9s ellen is v\u00e9d. Konfigur\u00e1ljunk adatb\u00e1zisban felhaszn\u00e1l\u00f3kat k\u00fcl\u00f6nb\u00f6z\u0151 jogosults\u00e1gokkal, a programunk connection string-j\u00e9ben megadott felhaszn\u00e1l\u00f3 csak a m\u0171k\u00f6d\u00e9shez sz\u00fcks\u00e9ges minim\u00e1lis jogokkal rendelkezzen. A mi eset\u00fcnkben nem adtunk meg felhaszn\u00e1l\u00f3t, a windows-os felhaszn\u00e1l\u00f3k\u00e9nt fogunk csatlakozni. H\u00edvjuk meg az eredeti (vagyis a biztons\u00e1gos, SQL param\u00e9tereket haszn\u00e1l\u00f3) besz\u00far\u00f3 f\u00fcggv\u00e9nyt a \u201especi\u00e1lis\u201d param\u00e9terez\u00e9ssel, hogy l\u00e1ssuk, m\u0171k\u00f6dik-e a v\u00e9delem: InsertShipper ( \"Super Shipper\" , \"49-98562'); DELETE FROM Shippers;--\" ); InsertShipper ( \"XXX');DELETE FROM Shippers;--\" , \"49-98562\" ); Az els\u0151n\u00e9l nem f\u00e9r\u00fcnk bele a m\u00e9retkorl\u00e1tba, a m\u00e1sodik lefut, de csak egy \u201efurcsa\u201d nev\u0171 sz\u00e1ll\u00edt\u00f3 ker\u00fclt be. A param\u00e9ter \u00e9rt\u00e9ke t\u00e9nyleg \u00e9rt\u00e9kk\u00e9nt \u00e9rtelmez\u0151d\u00f6tt nem pedig SQL-k\u00e9nt. Nem \u00fagy mint itt:","title":"5. Feladat - SQL Injection"},{"location":"labor/5-adatkezeles/#6-feladat-torles","text":"\u00cdrjunk egy \u00faj f\u00fcggv\u00e9nyt, mely kit\u00f6r\u00f6l egy adott sz\u00e1ll\u00edt\u00f3t. private static void DeleteShipper ( int shipperID ) { using var conn = new SqlConnection ( ConnString ); using var command = new SqlCommand ( \"DELETE FROM Shippers WHERE ShipperID = @ShipperID\" , conn ); command . Parameters . AddWithValue ( \"@ShipperID\" , shipperID ); conn . Open (); int affectedRows = command . ExecuteNonQuery (); Console . WriteLine ( $\"{affectedRows} row(s) affected\" ); } H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a Main f\u00fcggv\u00e9nyb\u0151l, pl. 1-gyel param\u00e9terezve. Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Val\u00f3sz\u00edn\u0171leg kiv\u00e9telt kapunk, ugyanis van hivatkoz\u00e1s (idegen kulcs k\u00e9nyszerrel) az adott rekordra. SSOE-b\u0151l n\u00e9zz\u00fck ki az azonos\u00edt\u00f3j\u00e1t egy olyan sz\u00e1ll\u00edt\u00f3nak, melyet mi vett\u00fcnk fel. Adjuk \u00e1t ezt az azonos\u00edt\u00f3t a t\u00f6rl\u0151 f\u00fcggv\u00e9nynek \u2013 ezt m\u00e1r ki tudja t\u00f6r\u00f6lni, hiszen nincs r\u00e1 hivatkoz\u00e1s. T\u00f6rl\u00e9si strat\u00e9gi\u00e1k L\u00e1that\u00f3, hogy a t\u00f6rl\u00e9s igen kock\u00e1zatos \u00e9s kisz\u00e1m\u00edthatatlan m\u0171velet az idegen kulcs k\u00e9nyszerek miatt. N\u00e9h\u00e1ny m\u00f3dszer a t\u00f6rl\u00e9s kezel\u00e9s\u00e9re: nem enged\u00e9lyezz\u00fck a t\u00f6rl\u00e9st : Ha hivatkoznak a t\u00f6rlend\u0151 rekordra, az adatb\u00e1zis hib\u00e1val t\u00e9r vissza (ahogy fent is l\u00e1thattuk). kaszk\u00e1d t\u00f6rl\u00e9s \u2013 az idegen kulcs k\u00e9nyszeren be\u00e1ll\u00edthat\u00f3, hogy a hivatkozott rekord t\u00f6rl\u00e9sekor a hivatkoz\u00f3 rekord is t\u00f6rl\u0151dj\u00f6n. Gyakran ez oda vezet, hogy minden idegen kulcs k\u00e9nyszer\u00fcnk ilyen lesz, \u00e9s egy (v\u00e9letlen) t\u00f6rl\u00e9ssel v\u00e9gigt\u00f6r\u00f6lhetj\u00fck ak\u00e1r a teljes adatb\u00e1zist, azaz nehezen j\u00f3solhat\u00f3 a t\u00f6rl\u00e9s hat\u00e1sa. hivatkoz\u00e1s NULL-oz\u00e1sa \u2013 az idegen kulcs k\u00e9nyszeren be\u00e1ll\u00edthat\u00f3, hogy a hivatkozott rekord t\u00f6rl\u00e9sekor a hivatkoz\u00f3 rekord idegen kulcs mez\u0151je NULL \u00e9rt\u00e9k\u0171 legyen. Csak akkor alkalmazhat\u00f3, ha a modell\u00fcnkben az adott idegen kulcs mez\u0151 NULL -ozhat\u00f3. logikai t\u00f6rl\u00e9s (soft delete) \u2013 t\u00f6rl\u00e9s m\u0171velet helyett csak egy flag oszlopot (pl. IsDeleted ) \u00e1ll\u00edtunk be. El\u0151nye, hogy nem kell az idegen kulcs k\u00e9nyszerekkel foglalkoznunk, a t\u00f6r\u00f6lt adat rendelkez\u00e9sre \u00e1ll, ha sz\u00fcks\u00e9g lenne r\u00e1 (pl. undelete m\u0171velet). \u00c1m a m\u0171k\u00f6d\u00e9s bonyol\u00f3dik, mert foglalkozni kell azzal, hogy hogyan \u00e9s mikor sz\u0171rj\u00fck a t\u00f6r\u00f6lt rekordokat (pl. hogy ne jelenjenek meg a fel\u00fcleten, statisztik\u00e1kban), vagy hogyan kezelj\u00fck, ha egy nem t\u00f6r\u00f6lt rekord t\u00f6r\u00f6ltre hivatkozik.","title":"6. Feladat - T\u00f6rl\u00e9s"},{"location":"labor/5-adatkezeles/#kitekintes","text":"A fenti ADO.NET alapm\u0171veleteket ebben az itt l\u00e1tott alapform\u00e1ban ritk\u00e1n haszn\u00e1lj\u00e1k k\u00e9t okb\u00f3l kifoly\u00f3an (m\u00e9g akkor is, ha ez a megk\u00f6zel\u00edt\u00e9s adja a legjobb teljes\u00edtm\u00e9nyt): Gyenge t\u00edpusoss\u00e1g (egy rekord adatait beolvasni egy oszt\u00e1ly property-jeibe igen k\u00f6r\u00fclm\u00e9nyes, cast-olni kell stb.) Stringbe k\u00f3dolt SQL (az elg\u00e9pel\u00e9sb\u0151l ered\u0151 hib\u00e1k csak fut\u00e1si id\u0151ben der\u00fclnek ki) Az el\u0151bbire megold\u00e1st jelenthetnek a k\u00fcl\u00f6nb\u00f6z\u0151 ADO.NET-et kieg\u00e9sz\u00edt\u0151 komponensek, pl.: Dapper PetaPoco Ezek a megold\u00e1sok egy minim\u00e1lis teljes\u00edtm\u00e9nyvesztes\u00e9g\u00e9rt cser\u00e9be nagyobb k\u00e9nyelmet k\u00edn\u00e1lnak. Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelentenek az ORM (Object-Relational-Mapping) rendszerek, cser\u00e9be ezek nagyobb overheaddel j\u00e1rnak, mint az el\u0151bb eml\u00edtett megold\u00e1sok. Az ORM-ek lek\u00e9pez\u00e9st alak\u00edtanak ki az adatb\u00e1zis \u00e9s az OO oszt\u00e1lyaink k\u00f6z\u00f6tt, \u00e9s ennek a lek\u00e9pez\u00e9snek a seg\u00edts\u00e9g\u00e9vel egyszer\u0171s\u00edtik az adatb\u00e1zis m\u0171veleteket. Az oszt\u00e1lyainkon v\u00e9gzett, t\u00edpusos k\u00f3ddal le\u00edrt m\u0171veleteinket automatikusan \u00e1tford\u00edtj\u00e1k a megfelel\u0151 adatb\u00e1zis m\u0171veletekre, \u00edgy a mem\u00f3riabeli objektummodell\u00fcnket szinkronban tartj\u00e1k az adatb\u00e1zissal. Az ORM-ek ebb\u0151l k\u00f6vetkez\u0151en kapcsolat n\u00e9lk\u00fcli modellt haszn\u00e1lnak. Ismertebb .NET-es ORM-ek: ADO.NET DataSet \u2013 els\u0151gener\u00e1ci\u00f3s ORM, ma m\u00e1r nagyon ritk\u00e1n haszn\u00e1ljuk. Entity Framework 6.x \u2013 (r\u00e9gi) .NET Framework leggyakrabban haszn\u00e1lt ORM keretrendszere Entity Framework Core (EF Core) \u2013 a jelenleg els\u0151dlegesen haszn\u00e1lt .NET ORM (open source) NHibernate \u2013 a java-s Hibernate .NET-es portja (open source) Az Entity Framework Core-ral r\u00e9szletesebben foglalkozunk az Adatvez\u00e9relt rendszerek specializ\u00e1ci\u00f3 t\u00e1rgyban illetve a Szofverfejleszt\u00e9s .NET platformon v\u00e1laszthat\u00f3 t\u00e1rgyban.","title":"Kitekint\u00e9s"},{"location":"labor/6-doc-view/","text":"6. Document-View architekt\u00fara \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.11.31 Kidolgozta: Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9ljai: UML alap\u00fa tervez\u00e9s \u00e9s n\u00e9h\u00e1ny tervez\u00e9si minta alkalmaz\u00e1sa A Document-View architekt\u00fara alkalmaz\u00e1sa a gyakorlatban UserControl szerep\u00e9nek bemutat\u00e1sa Window Forms alkalmaz\u00e1sokban, Document-View architekt\u00fara eset\u00e9n A grafikus megjelen\u00edt\u00e9s elveinek gyakorl\u00e1sa Window Forms alkalmaz\u00e1sokban (Paint esem\u00e9ny, Invalidate, Graphics haszn\u00e1lata) A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok \u00e9s kor\u00e1bbi gyakorlatok anyaga: UML alap\u00fa modellez\u00e9s (1. gyakorlat) Windows Forms alkalmaz\u00e1sfejleszt\u00e9s Szoftverarchitekt\u00far\u00e1k (Document-View architekt\u00fara) El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) A gyakorlat menete \u00b6 Az al\u00e1bbiak szerint fogunk dolgozni: A feladat/c\u00e9lok r\u00f6vid ismertet\u00e9se: egy interakt\u00edv fonteditor (bet\u0171t\u00edpus-szerkeszt\u0151) megtervez\u00e9se. A k\u00e9sz alkalmaz\u00e1st futtatva a feladat (a k\u00e9sz alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9nek) ismertet\u00e9se Az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1nak megtervez\u00e9se (oszt\u00e1lydiagram elk\u00e9sz\u00edt\u00e9se) A k\u00e9sz alkalmaz\u00e1s forr\u00e1sk\u00f3dj\u00e1nak alapj\u00e1n n\u00e9h\u00e1ny fontosabb forgat\u00f3k\u00f6nyv megval\u00f3s\u00edt\u00e1s\u00e1nak \u00e1ttekint\u00e9se Megjegyz\u00e9s gyakorlatvezet\u0151k sz\u00e1m\u00e1ra A gyakorlat elej\u00e9n t\u00f6lts\u00fck le a k\u00e9sz alkalmaz\u00e1st. A hallgat\u00f3k ekkor m\u00e9g ne t\u00f6lts\u00e9k le, ne ezt kattintgass\u00e1k, majd csak a gyakorlat m\u00e1sodik r\u00e9sz\u00e9ben. A gyakorlatvezet\u0151knek viszont sz\u00fcks\u00e9ge lesz r\u00e1, mert ennek seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik az feladat bemutat\u00e1sa. 1. Feladat - A feladat ismertet\u00e9se \u00b6 Interakt\u00edv FontEditor k\u00e9sz\u00edt\u00e9se, amelyben lehet szerkeszteni a karaktereket, \u00e9s a karakterekb\u0151l \u00e1ll\u00f3 fontokb\u00f3l tetsz\u0151leges p\u00e9ldasz\u00f6veg jelen\u00edthet\u0151 meg. Az alkalmaz\u00e1s felhaszn\u00e1l\u00f3i fel\u00fclete fut\u00e1s k\u00f6zben: A k\u00f6vetkez\u0151 funkci\u00f3kat kell t\u00e1mogatnia: T\u00f6bb bet\u0171t\u00edpus egyidej\u0171 szerkeszt\u00e9se. Ez egyes bet\u0171t\u00edpusok k\u00fcl\u00f6n tab oldalakon szerkeszthet\u0151k (MDI \u2013 Multiple Document Interface). \u00daj bet\u0171t\u00edpus a File/New men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1val hozhat\u00f3 l\u00e9tre (meg kell adni a nev\u00e9t). Ez egyes bet\u0171t\u00edpusok elmenthet\u0151k ( File/Save ), bet\u00f6lthet\u0151k ( File/Open ), \u00e9s az aktu\u00e1lis dokumentum bez\u00e1rhat\u00f3 ( File/Close ). Ezek helye megvan az alkalmaz\u00e1sban, de nincsenek r\u00e9szleteiben implement\u00e1lva (a f\u00fcggv\u00e9nyek t\u00f6rzse nincs kit\u00f6ltve \u2013 opcion\u00e1lis HF). A felhaszn\u00e1l\u00f3i fel\u00fclet fel\u00e9p\u00edt\u00e9se Az oldalak tetej\u00e9n egy mintasz\u00f6veg adhat\u00f3 meg, melyet az aktu\u00e1lis bet\u0171t\u00edpussal az alkalmaz\u00e1s megjelen\u00edt. Az oldalak k\u00f6zep\u00e9n egy karakters\u00e1v tal\u00e1lhat\u00f3. Egy adott karakteren dupl\u00e1n kattintva alatta megjelenik egy az adott karakterhez tartoz\u00f3 szerkeszt\u0151n\u00e9zet. Az oldal alj\u00e1n egym\u00e1s mellett az eddig szerkeszt\u00e9sre megnyitott karakterek szerkeszt\u0151n\u00e9zetei l\u00e1that\u00f3k. Egy karakter t\u00f6bbsz\u00f6r is megnyithat\u00f3 szerkeszt\u00e9sre, ez esetben t\u00f6bb szerkeszt\u0151n\u00e9zet j\u00f6n l\u00e9tre hozz\u00e1. Ennek az az \u00e9rtelme, hogy ugyanazt a karaktert k\u00fcl\u00f6nb\u00f6z\u0151 nagy\u00edt\u00e1ssal is l\u00e1thatjuk/szerkeszthetj\u00fck. A szerkeszt\u0151n\u00e9zetek fel\u00e9p\u00edt\u00e9se Nagy r\u00e9sze (eltekintve a fels\u0151 s\u00e1v) a szerkeszt\u0151fel\u00fclet, ahol fekete h\u00e1tt\u00e9ren s\u00e1rg\u00e1val jelennek meg az akt\u00edv pixelek. Egy adott pixelen az eg\u00e9rrel kattintva a pixel invert\u00e1l\u00f3dik. Bal fels\u0151 sarokban a megjelen\u00edtett karakter l\u00e1that\u00f3 \u2019c\u2019 gomb: Clear, minden akt\u00edv pixelt t\u00f6r\u00f6l \u2019+\u2019 gomb: nagy\u00edt\u00e1s \u2019-\u2019 gomb: kicsiny\u00edt\u00e9s Futtassuk az alkalmaz\u00e1st, \u00e9s ismertess\u00fck m\u0171k\u00f6d\u00e9s\u00e9t a fentieknek megfelel\u0151en. Azt mindenk\u00e9ppen mutassuk meg, hogy ha egy karakter szerepel a mintasz\u00f6vegben, valamint t\u00f6bbsz\u00f6r megnyitjuk szerkeszt\u00e9sre, akkor az egyik n\u00e9zetben v\u00e1ltoztatva (egy pixelt invert\u00e1lva) valamennyi n\u00e9zete friss\u00fcl. Az alkalmaz\u00e1s a k\u00f3dmennyis\u00e9g minim\u00e1lis \u00e9rt\u00e9ken tart\u00e1sa \u00e9rdek\u00e9ben minimalisztikus, pl. a hibakezel\u00e9s nincs \u00e1ltal\u00e1noss\u00e1g\u00e1ban kidolgozva, hi\u00e1nyoznak ellen\u0151rz\u00e9sek. Ugyanakkor viszonylag j\u00f3l kommentezett, ami seg\u00edti a k\u00f3d ut\u00f3lagos meg\u00e9rt\u00e9s\u00e9t. 2. Feladat - Az alkalmaz\u00e1s megtervez\u00e9se \u00b6 COMING SOON 3. Feladat - A k\u00e9sz alkalmaz\u00e1s \u00e1ttekint\u00e9se \u00b6 Az al\u00e1bbiakra min. 15 perc kell maradjon, abba sz\u0171ken bele lehet f\u00e9rni. Id\u0151 hi\u00e1ny\u00e1ban nem val\u00f3s\u00edtjuk meg az alkalmaz\u00e1st, hanem a k\u00e9sz megold\u00e1st n\u00e9zz\u00fck \u00e1t, annak is csak n\u00e9h\u00e1ny l\u00e9nyeges haszn\u00e1lati eset\u00e9t (forgat\u00f3k\u00f6nyv). Most m\u00e1r a hallgat\u00f3k is t\u00f6lts\u00e9k le a k\u00e9sz megold\u00e1st, nyiss\u00e1k meg a k\u00e9sz solution-t, futtass\u00e1k/pr\u00f3b\u00e1lj\u00e1k ki az alkalmaz\u00e1st. N\u00e9zetek megval\u00f3s\u00edt\u00e1sa \u00b6 Nyissuk meg a FontEditorView -t, el\u0151sz\u00f6r a k\u00f3dot n\u00e9zz\u00fck. A FontEditorView egyr\u00e9szt implement\u00e1lja az IV i ew interf\u00e9szt, de m\u00e1sr\u00e9szt a UserControl -b\u00f3l sz\u00e1rmazik. M\u00e9gpedig az\u00e9rt, mert \u00edgy a tervez\u0151ben (designer) tudjuk kialak\u00edtani a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t, pont \u00fagy, mint egy \u0171rlapnak. Nyissuk most meg tervez\u0151i n\u00e9zetben, \u00e9s mondjuk el, hogy a c\u00edmk\u00e9t \u00e9s gombokat a Toolboxr\u00f3l tett\u00fck r\u00e1. Rendezz\u00fck is \u00e1t egy kicsit \u0151ket, majd futtassuk az alkalmaz\u00e1st (el\u00e9g, ha mi megtessz\u00fck, a hallgat\u00f3k nem kell k\u00f6vess\u00e9k), hogy \u00e9rezhet\u0151 legyen, mir\u0151l van sz\u00f3. A SampleTextView is \u00edgy van megval\u00f3s\u00edtva, b\u00e1r annak egyszer\u0171 a fel\u00fclete, lehetett volna k\u00f6z\u00f6ns\u00e9ges Control lesz\u00e1rmazott is. Vonjuk le a tanuls\u00e1got: Windows Forms k\u00f6rnyezetben a n\u00e9zeteket tipikusan UserControl -k\u00e9nt (esetleg Control -k\u00e9nt) c\u00e9lszer\u0171 megval\u00f3s\u00edtani. Egy oldal (tab) elrendez\u00e9se \u00b6 Futtassuk az alkalmaz\u00e1st. Valahogy ki kell alak\u00edtsuk egy adott oldal (tabpage) elrendez\u00e9s\u00e9t. Lehet\u0151leg tervez\u0151i n\u00e9zetben, \u00e9s nem fut\u00e1s k\u00f6zben, k\u00f3db\u00f3l poz\u00edcion\u00e1lva az elemeket (legal\u00e1bbis ahol nem musz\u00e1j). A UserControl -ok alkalmaz\u00e1sa jelenti sz\u00e1munkra a megold\u00e1st. Nyissuk meg a FontDocumentControl -t tervez\u0151i n\u00e9zetben. Ez egy olyan control, amely egy taboldalra ker\u00fcl fel, azt t\u00f6lti ki teljesen. Az oldalt a m\u00e1r ismert layout technik\u00e1kkal alak\u00edtottuk ki ( Label , TextBox , Panel -ek Dock-kolva). Ha van id\u0151nk, akkor n\u00e9zz\u00fck meg a Document Outline ablakban. Az igazi \u201epo\u00e9n\u201d pedig az, hogy a SampleTextView -t is a Toolbox-r\u00f3l drag&drop-pal tett\u00fck fel. Annyit n\u00e9zz\u00fcnk meg, hogy val\u00f3ban ott van a Toolbox tetej\u00e9n. Forgat\u00f3k\u00f6nyv 1 \u2013 egy pixel invert\u00e1l\u00e1sa, n\u00e9zetek szinkroniz\u00e1l\u00e1sa \u00b6 \u00d6n\u00e1ll\u00f3 feladat a hallgat\u00f3knak. Keress\u00e9k meg azt a f\u00fcggv\u00e9nyt, ahol az eg\u00e9sz folyamat elindul. A FontEditorView.FontEditorView_MouseClick -be kellene eljutni. Itt egy sor a l\u00e9nyeg: private void FontEditorView_MouseClick ( object sender , MouseEventArgs e ) { int x = e . X / zoom ; int y = ( e . Y - offsetY )/ zoom ; if ( x >= CharDef . FontSize . Width ) return ; document . InvertCharDefPixel ( editedChar , x , y ); } N\u00e9zz\u00fck meg a FontEditorDocument.InvertCharDefPixel -t. Invert\u00e1lja a megfelel\u0151 CharDef pixel\u00e9t, de a l\u00e9nyeg az utols\u00f3 sor: public void InvertCharDefPixel ( char c , int x , int y ) { CharDef fd = GetCharDef ( c ); fd . Pixels [ x , y ] = ! fd . Pixels [ x , y ]; UpdateAllViews (); } A FontEditorDocument -ben vethet\u00fcnk m\u00e9g egy pillant\u00e1st a CharDef -ek sz\u00f3t\u00e1r\u00e1ra: Dictionary < char , CharDef > charDefs = new Dictionary < char , CharDef >(); Az UpdateAllViews a Document \u0151sben van, Update -et h\u00edv minden n\u00e9zetre. Ami \u00e9rdekes, hogy az Update hogy van meg\u00edrva az egyes n\u00e9zetekben. N\u00e9zz\u00fck meg pl. a FontEditView -t: /// <summary> /// Az IView interf\u00e9sz Update m\u0171velet\u00e1nek implement\u00e1ci\u00f3ja. /// </summary> public void Update () { Invalidate (); } Az Update hat\u00e1s\u00e1ra a n\u00e9zetek \u00fajra kell rajzolj\u00e1k magukat az aktu\u00e1lis dokumentum \u00e1llapot alapj\u00e1n. De az Update -ben nem tudunk rajzolni, csak a \u201ePaint\u201d-ben. \u00cdgy itt az Invalidate h\u00edv\u00e1ssal kiv\u00e1ltjuk a Paint esem\u00e9nyt. Ez megint egy tanuls\u00e1g: Windows Forms alkalmaz\u00e1sokban az Update f\u00fcggv\u00e9nyben tipikusan Invalidate h\u00edv\u00e1s szokott lenni. Z\u00e1r\u00e1sk\u00e9ppen n\u00e9zz\u00fck meg a FontEditView.Paint megval\u00f3s\u00edt\u00e1s\u00e1t. Egyetlen l\u00e9nyeges dolog van itt: a megjelen\u00edt\u00e9shez le kell k\u00e9rni a dokumentumt\u00f3l az aktu\u00e1lis CharDef -et (mert a n\u00e9zet a D-V architekt\u00far\u00e1nak megfelel\u0151en nem t\u00e1rolja). /// <summary> /// A UserControl.Paint fel\u00fcldefini\u00e1l\u00e1sa, ebben rajzolunk. /// </summary> protected override void OnPaint ( PaintEventArgs e ) { base . OnPaint ( e ); CharDef editedCharDef = document . GetCharDef ( editedChar ); for ( int y = 0 ; y < CharDef . FontSize . Height ; y ++) { for ( int x = 0 ; x < CharDef . FontSize . Width ; x ++) { e . Graphics . FillRectangle ( editedCharDef . Pixels [ x , y ] ? Brushes . Yellow : Brushes . Black , zoom * x , offsetY + zoom * y , zoom , zoom ); } } } Forgat\u00f3k\u00f6nyv 2 \u2013 \u00daj dokumentum l\u00e9trehoz\u00e1sa \u00b6 Erre a feladatra val\u00f3sz\u00edn\u0171leg nem marad m\u00e1r id\u0151. Azt n\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik egy \u00faj dokumentum l\u00e9trehoz\u00e1sa, vagyis mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor. Nyissuk meg a MainForm-ot tervez\u0151i n\u00e9zetben, v\u00e1laszuk a File/New men\u00fcelemet, hogy ugorjunk el a Click esem\u00e9nykezel\u0151h\u00f6z. Arra l\u00e1tunk p\u00e9ld\u00e1t, hogy az App oszt\u00e1ly, mint Singleton, hogy \u00e9rhet\u0151 el: App . Instance . NewDocument (); Az \u00f6sszes t\u00f6bbi men\u00fcelem esem\u00e9nykezel\u0151je hasonl\u00f3, nincs semmi logika a GUI-ban, csak egyszer\u0171 tov\u00e1bbh\u00edv\u00e1s az App -ba. Tekints\u00fck \u00e1t az az App.NewDocument t\u00f6rzs\u00e9t, \u00e9s egy-egy mondatban tekints\u00fck \u00e1t (a gyakorlat sor\u00e1n sz\u00f3ban ismertess\u00fck) a fontosabb l\u00e9p\u00e9seket. Azt, hogy a TabControl -lal mit \u00fcgyesked\u00fcnk, nem kell elmondani, nem kell tudni. /// <summary> /// L\u00e9trehoz egy \u00faj dokumentumot. /// </summary> public void NewDocument () { // Bek\u00e9rdezz\u00fck az \u00faj font t\u00edpus (dokumentum) nev\u00e9t a // felhaszn\u00e1l\u00f3t\u00f3l egy mod\u00e1lis dial\u00f3gs ablakban. NewDocForm form = new NewDocForm (); if ( form . ShowDialog () != DialogResult . OK ) return ; // \u00daj dokumentum objektum l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a // dokumentum list\u00e1ba. Document doc = new FontEditorDocument ( form . FontName ); documents . Add ( doc ); // Az els\u0151 param\u00e9ter egy kulcs, a m\u00e1sodik a tab felirata // Egy \u00faj tabra felteszi a dokumentumhoz tartoz\u00f3 fel\u00fcletelemeket. // Ezeket egy UserControl, a FontDocumentControl fogja \u00f6ssze. // \u00cdgy csak ebb\u0151l kell egy p\u00e9ld\u00e1nyt az \u00faj tabpage-re feltenni. mainForm . TabControl . TabPages . Add ( form . FontName , form . FontName ); FontDocumentControl documentControl = new FontDocumentControl (); TabPage tp = mainForm . TabControl . TabPages [ form . FontName ]; tp . Controls . Add ( documentControl ); documentControl . Dock = DockStyle . Fill ; // SampleTextView beregisztr\u00e1l\u00e1sa a documentn\u00e1l, hogy // \u00e9rtes\u00fclj\u00f6n majd a dokumentum v\u00e1ltoz\u00e1sair\u00f3l. documentControl . SampleTextView . AttachToDoc ( doc ); // Az \u00faj tab legyen a kiv\u00e1lasztott. mainForm . TabControl . SelectTab ( tp ); // Az \u00faj tab lesz az akt\u00edv, az activeDocument // tagv\u00e1ltoz\u00f3t erre kell \u00e1ll\u00edtani. UpdateActiveDocument (); } Az App.OpenDocument nincs kit\u00f6ltve, de a l\u00e9p\u00e9sek be vannak \u00edrva, remek gyakorl\u00e1si lehet\u0151s\u00e9g a hallgat\u00f3knak otthon meg\u00edrni.","title":"6. Document-View architekt\u00fara"},{"location":"labor/6-doc-view/#6-document-view-architektura","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.11.31 Kidolgozta: Benedek Zolt\u00e1n","title":"6. Document-View architekt\u00fara"},{"location":"labor/6-doc-view/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9ljai: UML alap\u00fa tervez\u00e9s \u00e9s n\u00e9h\u00e1ny tervez\u00e9si minta alkalmaz\u00e1sa A Document-View architekt\u00fara alkalmaz\u00e1sa a gyakorlatban UserControl szerep\u00e9nek bemutat\u00e1sa Window Forms alkalmaz\u00e1sokban, Document-View architekt\u00fara eset\u00e9n A grafikus megjelen\u00edt\u00e9s elveinek gyakorl\u00e1sa Window Forms alkalmaz\u00e1sokban (Paint esem\u00e9ny, Invalidate, Graphics haszn\u00e1lata) A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok \u00e9s kor\u00e1bbi gyakorlatok anyaga: UML alap\u00fa modellez\u00e9s (1. gyakorlat) Windows Forms alkalmaz\u00e1sfejleszt\u00e9s Szoftverarchitekt\u00far\u00e1k (Document-View architekt\u00fara)","title":"A gyakorlat c\u00e9lja"},{"location":"labor/6-doc-view/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)","title":"El\u0151felt\u00e9telek"},{"location":"labor/6-doc-view/#a-gyakorlat-menete","text":"Az al\u00e1bbiak szerint fogunk dolgozni: A feladat/c\u00e9lok r\u00f6vid ismertet\u00e9se: egy interakt\u00edv fonteditor (bet\u0171t\u00edpus-szerkeszt\u0151) megtervez\u00e9se. A k\u00e9sz alkalmaz\u00e1st futtatva a feladat (a k\u00e9sz alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9nek) ismertet\u00e9se Az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1nak megtervez\u00e9se (oszt\u00e1lydiagram elk\u00e9sz\u00edt\u00e9se) A k\u00e9sz alkalmaz\u00e1s forr\u00e1sk\u00f3dj\u00e1nak alapj\u00e1n n\u00e9h\u00e1ny fontosabb forgat\u00f3k\u00f6nyv megval\u00f3s\u00edt\u00e1s\u00e1nak \u00e1ttekint\u00e9se Megjegyz\u00e9s gyakorlatvezet\u0151k sz\u00e1m\u00e1ra A gyakorlat elej\u00e9n t\u00f6lts\u00fck le a k\u00e9sz alkalmaz\u00e1st. A hallgat\u00f3k ekkor m\u00e9g ne t\u00f6lts\u00e9k le, ne ezt kattintgass\u00e1k, majd csak a gyakorlat m\u00e1sodik r\u00e9sz\u00e9ben. A gyakorlatvezet\u0151knek viszont sz\u00fcks\u00e9ge lesz r\u00e1, mert ennek seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik az feladat bemutat\u00e1sa.","title":"A gyakorlat menete"},{"location":"labor/6-doc-view/#1-feladat-a-feladat-ismertetese","text":"Interakt\u00edv FontEditor k\u00e9sz\u00edt\u00e9se, amelyben lehet szerkeszteni a karaktereket, \u00e9s a karakterekb\u0151l \u00e1ll\u00f3 fontokb\u00f3l tetsz\u0151leges p\u00e9ldasz\u00f6veg jelen\u00edthet\u0151 meg. Az alkalmaz\u00e1s felhaszn\u00e1l\u00f3i fel\u00fclete fut\u00e1s k\u00f6zben: A k\u00f6vetkez\u0151 funkci\u00f3kat kell t\u00e1mogatnia: T\u00f6bb bet\u0171t\u00edpus egyidej\u0171 szerkeszt\u00e9se. Ez egyes bet\u0171t\u00edpusok k\u00fcl\u00f6n tab oldalakon szerkeszthet\u0151k (MDI \u2013 Multiple Document Interface). \u00daj bet\u0171t\u00edpus a File/New men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1val hozhat\u00f3 l\u00e9tre (meg kell adni a nev\u00e9t). Ez egyes bet\u0171t\u00edpusok elmenthet\u0151k ( File/Save ), bet\u00f6lthet\u0151k ( File/Open ), \u00e9s az aktu\u00e1lis dokumentum bez\u00e1rhat\u00f3 ( File/Close ). Ezek helye megvan az alkalmaz\u00e1sban, de nincsenek r\u00e9szleteiben implement\u00e1lva (a f\u00fcggv\u00e9nyek t\u00f6rzse nincs kit\u00f6ltve \u2013 opcion\u00e1lis HF). A felhaszn\u00e1l\u00f3i fel\u00fclet fel\u00e9p\u00edt\u00e9se Az oldalak tetej\u00e9n egy mintasz\u00f6veg adhat\u00f3 meg, melyet az aktu\u00e1lis bet\u0171t\u00edpussal az alkalmaz\u00e1s megjelen\u00edt. Az oldalak k\u00f6zep\u00e9n egy karakters\u00e1v tal\u00e1lhat\u00f3. Egy adott karakteren dupl\u00e1n kattintva alatta megjelenik egy az adott karakterhez tartoz\u00f3 szerkeszt\u0151n\u00e9zet. Az oldal alj\u00e1n egym\u00e1s mellett az eddig szerkeszt\u00e9sre megnyitott karakterek szerkeszt\u0151n\u00e9zetei l\u00e1that\u00f3k. Egy karakter t\u00f6bbsz\u00f6r is megnyithat\u00f3 szerkeszt\u00e9sre, ez esetben t\u00f6bb szerkeszt\u0151n\u00e9zet j\u00f6n l\u00e9tre hozz\u00e1. Ennek az az \u00e9rtelme, hogy ugyanazt a karaktert k\u00fcl\u00f6nb\u00f6z\u0151 nagy\u00edt\u00e1ssal is l\u00e1thatjuk/szerkeszthetj\u00fck. A szerkeszt\u0151n\u00e9zetek fel\u00e9p\u00edt\u00e9se Nagy r\u00e9sze (eltekintve a fels\u0151 s\u00e1v) a szerkeszt\u0151fel\u00fclet, ahol fekete h\u00e1tt\u00e9ren s\u00e1rg\u00e1val jelennek meg az akt\u00edv pixelek. Egy adott pixelen az eg\u00e9rrel kattintva a pixel invert\u00e1l\u00f3dik. Bal fels\u0151 sarokban a megjelen\u00edtett karakter l\u00e1that\u00f3 \u2019c\u2019 gomb: Clear, minden akt\u00edv pixelt t\u00f6r\u00f6l \u2019+\u2019 gomb: nagy\u00edt\u00e1s \u2019-\u2019 gomb: kicsiny\u00edt\u00e9s Futtassuk az alkalmaz\u00e1st, \u00e9s ismertess\u00fck m\u0171k\u00f6d\u00e9s\u00e9t a fentieknek megfelel\u0151en. Azt mindenk\u00e9ppen mutassuk meg, hogy ha egy karakter szerepel a mintasz\u00f6vegben, valamint t\u00f6bbsz\u00f6r megnyitjuk szerkeszt\u00e9sre, akkor az egyik n\u00e9zetben v\u00e1ltoztatva (egy pixelt invert\u00e1lva) valamennyi n\u00e9zete friss\u00fcl. Az alkalmaz\u00e1s a k\u00f3dmennyis\u00e9g minim\u00e1lis \u00e9rt\u00e9ken tart\u00e1sa \u00e9rdek\u00e9ben minimalisztikus, pl. a hibakezel\u00e9s nincs \u00e1ltal\u00e1noss\u00e1g\u00e1ban kidolgozva, hi\u00e1nyoznak ellen\u0151rz\u00e9sek. Ugyanakkor viszonylag j\u00f3l kommentezett, ami seg\u00edti a k\u00f3d ut\u00f3lagos meg\u00e9rt\u00e9s\u00e9t.","title":"1. Feladat - A feladat ismertet\u00e9se"},{"location":"labor/6-doc-view/#2-feladat-az-alkalmazas-megtervezese","text":"COMING SOON","title":"2. Feladat - Az alkalmaz\u00e1s megtervez\u00e9se"},{"location":"labor/6-doc-view/#3-feladat-a-kesz-alkalmazas-attekintese","text":"Az al\u00e1bbiakra min. 15 perc kell maradjon, abba sz\u0171ken bele lehet f\u00e9rni. Id\u0151 hi\u00e1ny\u00e1ban nem val\u00f3s\u00edtjuk meg az alkalmaz\u00e1st, hanem a k\u00e9sz megold\u00e1st n\u00e9zz\u00fck \u00e1t, annak is csak n\u00e9h\u00e1ny l\u00e9nyeges haszn\u00e1lati eset\u00e9t (forgat\u00f3k\u00f6nyv). Most m\u00e1r a hallgat\u00f3k is t\u00f6lts\u00e9k le a k\u00e9sz megold\u00e1st, nyiss\u00e1k meg a k\u00e9sz solution-t, futtass\u00e1k/pr\u00f3b\u00e1lj\u00e1k ki az alkalmaz\u00e1st.","title":"3. Feladat - A k\u00e9sz alkalmaz\u00e1s \u00e1ttekint\u00e9se"},{"location":"labor/6-doc-view/#nezetek-megvalositasa","text":"Nyissuk meg a FontEditorView -t, el\u0151sz\u00f6r a k\u00f3dot n\u00e9zz\u00fck. A FontEditorView egyr\u00e9szt implement\u00e1lja az IV i ew interf\u00e9szt, de m\u00e1sr\u00e9szt a UserControl -b\u00f3l sz\u00e1rmazik. M\u00e9gpedig az\u00e9rt, mert \u00edgy a tervez\u0151ben (designer) tudjuk kialak\u00edtani a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t, pont \u00fagy, mint egy \u0171rlapnak. Nyissuk most meg tervez\u0151i n\u00e9zetben, \u00e9s mondjuk el, hogy a c\u00edmk\u00e9t \u00e9s gombokat a Toolboxr\u00f3l tett\u00fck r\u00e1. Rendezz\u00fck is \u00e1t egy kicsit \u0151ket, majd futtassuk az alkalmaz\u00e1st (el\u00e9g, ha mi megtessz\u00fck, a hallgat\u00f3k nem kell k\u00f6vess\u00e9k), hogy \u00e9rezhet\u0151 legyen, mir\u0151l van sz\u00f3. A SampleTextView is \u00edgy van megval\u00f3s\u00edtva, b\u00e1r annak egyszer\u0171 a fel\u00fclete, lehetett volna k\u00f6z\u00f6ns\u00e9ges Control lesz\u00e1rmazott is. Vonjuk le a tanuls\u00e1got: Windows Forms k\u00f6rnyezetben a n\u00e9zeteket tipikusan UserControl -k\u00e9nt (esetleg Control -k\u00e9nt) c\u00e9lszer\u0171 megval\u00f3s\u00edtani.","title":"N\u00e9zetek megval\u00f3s\u00edt\u00e1sa"},{"location":"labor/6-doc-view/#egy-oldal-tab-elrendezese","text":"Futtassuk az alkalmaz\u00e1st. Valahogy ki kell alak\u00edtsuk egy adott oldal (tabpage) elrendez\u00e9s\u00e9t. Lehet\u0151leg tervez\u0151i n\u00e9zetben, \u00e9s nem fut\u00e1s k\u00f6zben, k\u00f3db\u00f3l poz\u00edcion\u00e1lva az elemeket (legal\u00e1bbis ahol nem musz\u00e1j). A UserControl -ok alkalmaz\u00e1sa jelenti sz\u00e1munkra a megold\u00e1st. Nyissuk meg a FontDocumentControl -t tervez\u0151i n\u00e9zetben. Ez egy olyan control, amely egy taboldalra ker\u00fcl fel, azt t\u00f6lti ki teljesen. Az oldalt a m\u00e1r ismert layout technik\u00e1kkal alak\u00edtottuk ki ( Label , TextBox , Panel -ek Dock-kolva). Ha van id\u0151nk, akkor n\u00e9zz\u00fck meg a Document Outline ablakban. Az igazi \u201epo\u00e9n\u201d pedig az, hogy a SampleTextView -t is a Toolbox-r\u00f3l drag&drop-pal tett\u00fck fel. Annyit n\u00e9zz\u00fcnk meg, hogy val\u00f3ban ott van a Toolbox tetej\u00e9n.","title":"Egy oldal (tab) elrendez\u00e9se"},{"location":"labor/6-doc-view/#forgatokonyv-1-egy-pixel-invertalasa-nezetek-szinkronizalasa","text":"\u00d6n\u00e1ll\u00f3 feladat a hallgat\u00f3knak. Keress\u00e9k meg azt a f\u00fcggv\u00e9nyt, ahol az eg\u00e9sz folyamat elindul. A FontEditorView.FontEditorView_MouseClick -be kellene eljutni. Itt egy sor a l\u00e9nyeg: private void FontEditorView_MouseClick ( object sender , MouseEventArgs e ) { int x = e . X / zoom ; int y = ( e . Y - offsetY )/ zoom ; if ( x >= CharDef . FontSize . Width ) return ; document . InvertCharDefPixel ( editedChar , x , y ); } N\u00e9zz\u00fck meg a FontEditorDocument.InvertCharDefPixel -t. Invert\u00e1lja a megfelel\u0151 CharDef pixel\u00e9t, de a l\u00e9nyeg az utols\u00f3 sor: public void InvertCharDefPixel ( char c , int x , int y ) { CharDef fd = GetCharDef ( c ); fd . Pixels [ x , y ] = ! fd . Pixels [ x , y ]; UpdateAllViews (); } A FontEditorDocument -ben vethet\u00fcnk m\u00e9g egy pillant\u00e1st a CharDef -ek sz\u00f3t\u00e1r\u00e1ra: Dictionary < char , CharDef > charDefs = new Dictionary < char , CharDef >(); Az UpdateAllViews a Document \u0151sben van, Update -et h\u00edv minden n\u00e9zetre. Ami \u00e9rdekes, hogy az Update hogy van meg\u00edrva az egyes n\u00e9zetekben. N\u00e9zz\u00fck meg pl. a FontEditView -t: /// <summary> /// Az IView interf\u00e9sz Update m\u0171velet\u00e1nek implement\u00e1ci\u00f3ja. /// </summary> public void Update () { Invalidate (); } Az Update hat\u00e1s\u00e1ra a n\u00e9zetek \u00fajra kell rajzolj\u00e1k magukat az aktu\u00e1lis dokumentum \u00e1llapot alapj\u00e1n. De az Update -ben nem tudunk rajzolni, csak a \u201ePaint\u201d-ben. \u00cdgy itt az Invalidate h\u00edv\u00e1ssal kiv\u00e1ltjuk a Paint esem\u00e9nyt. Ez megint egy tanuls\u00e1g: Windows Forms alkalmaz\u00e1sokban az Update f\u00fcggv\u00e9nyben tipikusan Invalidate h\u00edv\u00e1s szokott lenni. Z\u00e1r\u00e1sk\u00e9ppen n\u00e9zz\u00fck meg a FontEditView.Paint megval\u00f3s\u00edt\u00e1s\u00e1t. Egyetlen l\u00e9nyeges dolog van itt: a megjelen\u00edt\u00e9shez le kell k\u00e9rni a dokumentumt\u00f3l az aktu\u00e1lis CharDef -et (mert a n\u00e9zet a D-V architekt\u00far\u00e1nak megfelel\u0151en nem t\u00e1rolja). /// <summary> /// A UserControl.Paint fel\u00fcldefini\u00e1l\u00e1sa, ebben rajzolunk. /// </summary> protected override void OnPaint ( PaintEventArgs e ) { base . OnPaint ( e ); CharDef editedCharDef = document . GetCharDef ( editedChar ); for ( int y = 0 ; y < CharDef . FontSize . Height ; y ++) { for ( int x = 0 ; x < CharDef . FontSize . Width ; x ++) { e . Graphics . FillRectangle ( editedCharDef . Pixels [ x , y ] ? Brushes . Yellow : Brushes . Black , zoom * x , offsetY + zoom * y , zoom , zoom ); } } }","title":"Forgat\u00f3k\u00f6nyv 1 \u2013 egy pixel invert\u00e1l\u00e1sa, n\u00e9zetek szinkroniz\u00e1l\u00e1sa"},{"location":"labor/6-doc-view/#forgatokonyv-2-uj-dokumentum-letrehozasa","text":"Erre a feladatra val\u00f3sz\u00edn\u0171leg nem marad m\u00e1r id\u0151. Azt n\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik egy \u00faj dokumentum l\u00e9trehoz\u00e1sa, vagyis mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor. Nyissuk meg a MainForm-ot tervez\u0151i n\u00e9zetben, v\u00e1laszuk a File/New men\u00fcelemet, hogy ugorjunk el a Click esem\u00e9nykezel\u0151h\u00f6z. Arra l\u00e1tunk p\u00e9ld\u00e1t, hogy az App oszt\u00e1ly, mint Singleton, hogy \u00e9rhet\u0151 el: App . Instance . NewDocument (); Az \u00f6sszes t\u00f6bbi men\u00fcelem esem\u00e9nykezel\u0151je hasonl\u00f3, nincs semmi logika a GUI-ban, csak egyszer\u0171 tov\u00e1bbh\u00edv\u00e1s az App -ba. Tekints\u00fck \u00e1t az az App.NewDocument t\u00f6rzs\u00e9t, \u00e9s egy-egy mondatban tekints\u00fck \u00e1t (a gyakorlat sor\u00e1n sz\u00f3ban ismertess\u00fck) a fontosabb l\u00e9p\u00e9seket. Azt, hogy a TabControl -lal mit \u00fcgyesked\u00fcnk, nem kell elmondani, nem kell tudni. /// <summary> /// L\u00e9trehoz egy \u00faj dokumentumot. /// </summary> public void NewDocument () { // Bek\u00e9rdezz\u00fck az \u00faj font t\u00edpus (dokumentum) nev\u00e9t a // felhaszn\u00e1l\u00f3t\u00f3l egy mod\u00e1lis dial\u00f3gs ablakban. NewDocForm form = new NewDocForm (); if ( form . ShowDialog () != DialogResult . OK ) return ; // \u00daj dokumentum objektum l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a // dokumentum list\u00e1ba. Document doc = new FontEditorDocument ( form . FontName ); documents . Add ( doc ); // Az els\u0151 param\u00e9ter egy kulcs, a m\u00e1sodik a tab felirata // Egy \u00faj tabra felteszi a dokumentumhoz tartoz\u00f3 fel\u00fcletelemeket. // Ezeket egy UserControl, a FontDocumentControl fogja \u00f6ssze. // \u00cdgy csak ebb\u0151l kell egy p\u00e9ld\u00e1nyt az \u00faj tabpage-re feltenni. mainForm . TabControl . TabPages . Add ( form . FontName , form . FontName ); FontDocumentControl documentControl = new FontDocumentControl (); TabPage tp = mainForm . TabControl . TabPages [ form . FontName ]; tp . Controls . Add ( documentControl ); documentControl . Dock = DockStyle . Fill ; // SampleTextView beregisztr\u00e1l\u00e1sa a documentn\u00e1l, hogy // \u00e9rtes\u00fclj\u00f6n majd a dokumentum v\u00e1ltoz\u00e1sair\u00f3l. documentControl . SampleTextView . AttachToDoc ( doc ); // Az \u00faj tab legyen a kiv\u00e1lasztott. mainForm . TabControl . SelectTab ( tp ); // Az \u00faj tab lesz az akt\u00edv, az activeDocument // tagv\u00e1ltoz\u00f3t erre kell \u00e1ll\u00edtani. UpdateActiveDocument (); } Az App.OpenDocument nincs kit\u00f6ltve, de a l\u00e9p\u00e9sek be vannak \u00edrva, remek gyakorl\u00e1si lehet\u0151s\u00e9g a hallgat\u00f3knak otthon meg\u00edrni.","title":"Forgat\u00f3k\u00f6nyv 2 \u2013 \u00daj dokumentum l\u00e9trehoz\u00e1sa"},{"location":"labor/7-tervezesi-mintak/","text":"7. Tervez\u00e9si mint\u00e1k \u00b6 Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.11.01 Kidolgozta: Benedek Zolt\u00e1n A gyakorlat c\u00e9lja \u00b6 A gyakorlat c\u00e9ljai: Egy \u00f6sszetettebb p\u00e9lda alapj\u00e1n n\u00e9h\u00e1ny tervez\u00e9si minta gyakorlati alkalmaz\u00e1sa (els\u0151dlegesen Singleton, Command Processor \u00e9s Memento). A Document-View minta tov\u00e1bbi gyakorl\u00e1sa, illetve annak demonstr\u00e1l\u00e1sa, hogy a mint\u00e1nak t\u00f6bb vari\u00e1nsa l\u00e9tezik. Alapszint\u0171 betekint\u00e9st nyerni az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got t\u00e1mogat\u00f3 oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek fejleszt\u00e9s\u00e9nek vil\u00e1g\u00e1ba. Jelent\u0151s\u00e9g\u00fcknek megfelel\u0151en tov\u00e1bb gyakoroljuk az objektumorient\u00e1lt paradigma legfontosabb koncepci\u00f3it (pl. felel\u0151ss\u00e9gek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa). Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Tervez\u00e9si mint\u00e1k Szoftver architekt\u00far\u00e1k t\u00e9mak\u00f6rb\u0151l a Document-View architekt\u00fara Windows Forms alkalmaz\u00e1sok fejleszt\u00e9se El\u0151felt\u00e9telek \u00b6 A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas) Bevezet\u0151 \u00b6 Elm\u00e9leti h\u00e1tt\u00e9r \u00b6 A komplexebb alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n sz\u00e1mos tervez\u0151i d\u00f6nt\u00e9st kell meghoznunk, melyek sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk. Amennyiben ezen pontokban olyan d\u00f6nt\u00e9seket hozunk, melyek nem k\u00f6vetik az objektumorient\u00e1lt szeml\u00e9letm\u00f3d alapelveit, nem tartjuk szem el\u0151tt az alkalmaz\u00e1sunk k\u00f6nny\u0171 karbantarthat\u00f3s\u00e1g\u00e1t, illetve egyszer\u0171en megval\u00f3s\u00edthat\u00f3 tov\u00e1bbfejleszt\u00e9si lehet\u0151s\u00e9g\u00e9t, k\u00f6nnyen hamar r\u00e9m\u00e1lomm\u00e1 v\u00e1lhat a fejleszt\u00e9s. Az egyes hib\u00e1k jav\u00edt\u00e1sa folyamatosan \u00faj hib\u00e1kat sz\u00fcl. Ezen fel\u00fcl a megrendel\u0151i v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyek a k\u00f3d nagym\u00e9rt\u00e9k\u0171 folyamatos \u00e1t\u00edr\u00e1s\u00e1t ig\u00e9nylik ahelyett, hogy a k\u00f3d p\u00e1r j\u00f3l meghat\u00e1rozott pontj\u00e1ban t\u00f6rt\u00e9n\u0151 b\u0151v\u00edt\u00e9s\u00e9vel - a megl\u00e9v\u0151 k\u00f3d jelent\u0151s m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl - el tudn\u00e1nk ezt \u00e9rni. A tervez\u00e9si mint\u00e1k j\u00f3l bev\u00e1lt megold\u00e1sokat mutatnak bizonyos gyakran el\u0151fordul\u00f3 tervez\u00e9si probl\u00e9m\u00e1kra: ezen megold\u00e1sok abban seg\u00edtenek, hogy k\u00f3dunk k\u00f6nnyebben b\u0151v\u00edthet\u0151, karbantarthat\u00f3 \u00e9s min\u00e9l nagyobb m\u00e9rt\u00e9kben \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. Ugyanakkor ne ess\u00fcnk \u00e1t a l\u00f3 t\u00faloldal\u00e1ra: csak akkor \u00e9rdemes egy adott tervez\u00e9si mint\u00e1t bevetni, ha adott esetben val\u00f3s el\u0151nyt jelent az alkalmaz\u00e1sa. Ellenkez\u0151 esetben csak a megval\u00f3s\u00edt\u00e1s komplexit\u00e1s\u00e1t n\u00f6veli feleslegesen. A feladat ismertet\u00e9se \u00b6 A feladatunk egy vektorgrafikus rajzol\u00f3program kifejleszt\u00e9se: Az alkalmaz\u00e1sban vektorgrafikus alakzatokat lehet l\u00e9trehozni, \u00fagymint t\u00e9glalap, ellipszis, stb. A m\u00e1r l\u00e9trehozott alakzatokat egy grafikus fel\u00fcleten meg kell jelen\u00edteni (ki kell rajzolni). A m\u00e1r l\u00e9trehozott alakzatok fontosabb param\u00e9tereit, \u00fagymint koordin\u00e1t\u00e1k, befoglal\u00f3 t\u00e9glalap meg kell jelen\u00edteni egy list\u00e1ban egy inform\u00e1ci\u00f3s panelen. Windows Forms technol\u00f3gi\u00e1ra \u00e9p\u00edtve dolgozunk. Document-View architekt\u00far\u00e1t k\u00f6vetj\u00fck, de egyszerre csak egy dokumentum lehet megnyitva (nincsenek dokumentumonk\u00e9nt tabf\u00fclek vagy ablakok). Egy adott pontig el\u0151k\u00e9sz\u00edtett k\u00f6rnyezetet visz\u00fcnk tov\u00e1bb. A munka mennyis\u00e9g\u00e9nek kezelhet\u0151 szinten tart\u00e1sa v\u00e9gett csak bizonyos pontig vissz\u00fck tov\u00e1bb a fejleszt\u00e9st, nem val\u00f3s\u00edtjuk meg a teljes \u00e9rt\u00e9k\u0171 megold\u00e1st. kiemelt h\u00e1tt\u00e9r jelzi. 1. Feladat - A kiindul\u00e1si k\u00f6rnyezet megismer\u00e9se \u00b6 COMING SOON 2. Feladat - Command Processor minta \u00b6 COMING SOON 3- Feladat \u2013 Memento minta \u00b6 COMING SOON","title":"7. Tervez\u00e9si mint\u00e1k"},{"location":"labor/7-tervezesi-mintak/#7-tervezesi-mintak","text":"Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.11.01 Kidolgozta: Benedek Zolt\u00e1n","title":"7. Tervez\u00e9si mint\u00e1k"},{"location":"labor/7-tervezesi-mintak/#a-gyakorlat-celja","text":"A gyakorlat c\u00e9ljai: Egy \u00f6sszetettebb p\u00e9lda alapj\u00e1n n\u00e9h\u00e1ny tervez\u00e9si minta gyakorlati alkalmaz\u00e1sa (els\u0151dlegesen Singleton, Command Processor \u00e9s Memento). A Document-View minta tov\u00e1bbi gyakorl\u00e1sa, illetve annak demonstr\u00e1l\u00e1sa, hogy a mint\u00e1nak t\u00f6bb vari\u00e1nsa l\u00e9tezik. Alapszint\u0171 betekint\u00e9st nyerni az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got t\u00e1mogat\u00f3 oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek fejleszt\u00e9s\u00e9nek vil\u00e1g\u00e1ba. Jelent\u0151s\u00e9g\u00fcknek megfelel\u0151en tov\u00e1bb gyakoroljuk az objektumorient\u00e1lt paradigma legfontosabb koncepci\u00f3it (pl. felel\u0151ss\u00e9gek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa). Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Tervez\u00e9si mint\u00e1k Szoftver architekt\u00far\u00e1k t\u00e9mak\u00f6rb\u0151l a Document-View architekt\u00fara Windows Forms alkalmaz\u00e1sok fejleszt\u00e9se","title":"A gyakorlat c\u00e9lja"},{"location":"labor/7-tervezesi-mintak/#elofeltetelek","text":"A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Visual Studio 2022 Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)","title":"El\u0151felt\u00e9telek"},{"location":"labor/7-tervezesi-mintak/#bevezeto","text":"","title":"Bevezet\u0151"},{"location":"labor/7-tervezesi-mintak/#elmeleti-hatter","text":"A komplexebb alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n sz\u00e1mos tervez\u0151i d\u00f6nt\u00e9st kell meghoznunk, melyek sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk. Amennyiben ezen pontokban olyan d\u00f6nt\u00e9seket hozunk, melyek nem k\u00f6vetik az objektumorient\u00e1lt szeml\u00e9letm\u00f3d alapelveit, nem tartjuk szem el\u0151tt az alkalmaz\u00e1sunk k\u00f6nny\u0171 karbantarthat\u00f3s\u00e1g\u00e1t, illetve egyszer\u0171en megval\u00f3s\u00edthat\u00f3 tov\u00e1bbfejleszt\u00e9si lehet\u0151s\u00e9g\u00e9t, k\u00f6nnyen hamar r\u00e9m\u00e1lomm\u00e1 v\u00e1lhat a fejleszt\u00e9s. Az egyes hib\u00e1k jav\u00edt\u00e1sa folyamatosan \u00faj hib\u00e1kat sz\u00fcl. Ezen fel\u00fcl a megrendel\u0151i v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyek a k\u00f3d nagym\u00e9rt\u00e9k\u0171 folyamatos \u00e1t\u00edr\u00e1s\u00e1t ig\u00e9nylik ahelyett, hogy a k\u00f3d p\u00e1r j\u00f3l meghat\u00e1rozott pontj\u00e1ban t\u00f6rt\u00e9n\u0151 b\u0151v\u00edt\u00e9s\u00e9vel - a megl\u00e9v\u0151 k\u00f3d jelent\u0151s m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl - el tudn\u00e1nk ezt \u00e9rni. A tervez\u00e9si mint\u00e1k j\u00f3l bev\u00e1lt megold\u00e1sokat mutatnak bizonyos gyakran el\u0151fordul\u00f3 tervez\u00e9si probl\u00e9m\u00e1kra: ezen megold\u00e1sok abban seg\u00edtenek, hogy k\u00f3dunk k\u00f6nnyebben b\u0151v\u00edthet\u0151, karbantarthat\u00f3 \u00e9s min\u00e9l nagyobb m\u00e9rt\u00e9kben \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. Ugyanakkor ne ess\u00fcnk \u00e1t a l\u00f3 t\u00faloldal\u00e1ra: csak akkor \u00e9rdemes egy adott tervez\u00e9si mint\u00e1t bevetni, ha adott esetben val\u00f3s el\u0151nyt jelent az alkalmaz\u00e1sa. Ellenkez\u0151 esetben csak a megval\u00f3s\u00edt\u00e1s komplexit\u00e1s\u00e1t n\u00f6veli feleslegesen.","title":"Elm\u00e9leti h\u00e1tt\u00e9r"},{"location":"labor/7-tervezesi-mintak/#a-feladat-ismertetese","text":"A feladatunk egy vektorgrafikus rajzol\u00f3program kifejleszt\u00e9se: Az alkalmaz\u00e1sban vektorgrafikus alakzatokat lehet l\u00e9trehozni, \u00fagymint t\u00e9glalap, ellipszis, stb. A m\u00e1r l\u00e9trehozott alakzatokat egy grafikus fel\u00fcleten meg kell jelen\u00edteni (ki kell rajzolni). A m\u00e1r l\u00e9trehozott alakzatok fontosabb param\u00e9tereit, \u00fagymint koordin\u00e1t\u00e1k, befoglal\u00f3 t\u00e9glalap meg kell jelen\u00edteni egy list\u00e1ban egy inform\u00e1ci\u00f3s panelen. Windows Forms technol\u00f3gi\u00e1ra \u00e9p\u00edtve dolgozunk. Document-View architekt\u00far\u00e1t k\u00f6vetj\u00fck, de egyszerre csak egy dokumentum lehet megnyitva (nincsenek dokumentumonk\u00e9nt tabf\u00fclek vagy ablakok). Egy adott pontig el\u0151k\u00e9sz\u00edtett k\u00f6rnyezetet visz\u00fcnk tov\u00e1bb. A munka mennyis\u00e9g\u00e9nek kezelhet\u0151 szinten tart\u00e1sa v\u00e9gett csak bizonyos pontig vissz\u00fck tov\u00e1bb a fejleszt\u00e9st, nem val\u00f3s\u00edtjuk meg a teljes \u00e9rt\u00e9k\u0171 megold\u00e1st. kiemelt h\u00e1tt\u00e9r jelzi.","title":"A feladat ismertet\u00e9se"},{"location":"labor/7-tervezesi-mintak/#1-feladat-a-kiindulasi-kornyezet-megismerese","text":"COMING SOON","title":"1. Feladat - A kiindul\u00e1si k\u00f6rnyezet megismer\u00e9se"},{"location":"labor/7-tervezesi-mintak/#2-feladat-command-processor-minta","text":"COMING SOON","title":"2. Feladat - Command Processor minta"},{"location":"labor/7-tervezesi-mintak/#3-feladat-memento-minta","text":"COMING SOON","title":"3- Feladat \u2013 Memento minta"}]}